<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title> JSXGraph book</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        <script type="text/javascript" src="files/jquery.js"></script>
        <script type="text/javascript" src="files/jsxgraphcore.js"></script>
        <link rel="stylesheet" href="files/jsxgraph.css">

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
        <script type="text/x-mathjax-config">
          MathJax.Hub.Config({
              "HTML-CSS": {availableFonts: ["TeX"],scale: 90},
               tex2jax: {inlineMath: [["$","$"]],  displayMath: [["$$","$$"]],  processEscapes: true},
                config:["TeX-AMS_HTML.js"]});
        </script>
        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li><a href="1_introduction.html"><strong aria-hidden="true">1.</strong> {lang=EN}Introduction{/lang} {lang=SI}Uvod{/lang} {lang=CZ}Úvod{/lang}</a></li><li><a href="2_setup.html"><strong aria-hidden="true">2.</strong> {lang=EN}How to setup{/lang}{lang=SI}How to setup{/lang}{lang=CZ}Jak začít{/lang}</a></li><li><a href="3_basics.html"><strong aria-hidden="true">3.</strong> {lang=EN}Basics{/lang}{lang=SI}Basics{/lang}{lang=CZ}Základy{/lang}</a></li><li><ol class="section"><li><a href="3_1_board.html"><strong aria-hidden="true">3.1.</strong> {lang=EN}Drawing area{/lang}{lang=SI}Drawing area{/lang}{lang=CZ}Nákresna{/lang}</a></li><li><a href="3_2_basic_objects.html"><strong aria-hidden="true">3.2.</strong> {lang=EN}Creating points{/lang}{lang=SI}Creating points{/lang}{lang=CZ}Vytváření bodů{/lang}</a></li><li><a href="3_2a_lines.html"><strong aria-hidden="true">3.3.</strong> {lang=EN}Creating lines{/lang}{lang=SI}Creating lines{/lang}{lang=CZ}Kreslení přímek{/lang}</a></li><li><a href="3_2b_objects_drawing.html"><strong aria-hidden="true">3.4.</strong> {lang=EN}Adding attributes to the objects{/lang}{lang=SI}Adding properties to the objects{/lang}{lang=CZ}Nastavení vlastností objektů{/lang}</a></li><li><a href="3_2c_example.html"><strong aria-hidden="true">3.5.</strong> {lang=EN}Example{/lang}{lang=SI}Example{/lang}{lang=CZ}Příklad{/lang}</a></li><li><a href="3_3_circles.html"><strong aria-hidden="true">3.6.</strong> {lang=EN}Circles{/lang}{lang=SI}Circles{/lang}{lang=CZ}Kružnice{/lang}</a></li><li><a href="3_4_polygons.html"><strong aria-hidden="true">3.7.</strong> {lang=EN}Polygons{/lang}{lang=SI}Polygons{/lang}{lang=CZ}Mnohoúhelníky{/lang}</a></li><li><a href="3_5_intersections.html"><strong aria-hidden="true">3.8.</strong> {lang=EN}Intersections{/lang}{lang=SI}Intersections{/lang}{lang=CZ}Průsečíky{/lang}</a></li><li><a href="3_6_angles.html"><strong aria-hidden="true">3.9.</strong> {lang=EN}Angles{/lang}{lang=SI}Angles{/lang}{lang=CZ}Úhly{/lang}</a></li><li><a href="3_7_curves.html"><strong aria-hidden="true">3.10.</strong> {lang=EN}Curves{/lang}{lang=SI}Curves{/lang}{lang=CZ}Křivky{/lang}</a></li><li><a href="3_8_functions.html"><strong aria-hidden="true">3.11.</strong> {lang=EN}Drawing functions{/lang}{lang=SI}Drawing functions{/lang}{lang=CZ}Zobrazení grafu funkce{/lang}</a></li></ol></li><li><a href="4_animations.html"><strong aria-hidden="true">4.</strong> {lang=EN}Animating{/lang}{lang=SI}Animating{/lang}{lang=CZ}Animating{/lang}</a></li><li><ol class="section"><li><a href="4_1_moving.html"><strong aria-hidden="true">4.1.</strong> {lang=EN}Moving objects{/lang}{lang=SI}Moving objects{/lang}{lang=CZ}Moving objects{/lang}</a></li><li><a href="4_1a_example.html"><strong aria-hidden="true">4.2.</strong> {lang=EN}Example{/lang}{lang=SI}Example{/lang}{lang=CZ}Example{/lang}</a></li><li><a href="4_2_sliders.html"><strong aria-hidden="true">4.3.</strong> {lang=EN}Sliders{/lang}{lang=SI}Sliders{/lang}{lang=CZ}Sliders{/lang}</a></li><li><a href="4_3_animation_sliders.html"><strong aria-hidden="true">4.4.</strong> {lang=EN}Animating with sliders{/lang}{lang=SI}Animating with sliders{/lang}{lang=CZ}Animating with sliders{/lang}</a></li><li><a href="4_3a_example.html"><strong aria-hidden="true">4.5.</strong> {lang=EN}Example{/lang}{lang=SI}Example{/lang}{lang=CZ}Example{/lang}</a></li><li><a href="4_4_transformations.html"><strong aria-hidden="true">4.6.</strong> {lang=EN}Transformations{/lang}{lang=SI}Transformations{/lang}{lang=CZ}Transformations{/lang}</a></li></ol></li><li><a href="5_advanced.html"><strong aria-hidden="true">5.</strong> {lang=EN}Advanced topics{/lang}{lang=SI}Advanced topics{/lang}{lang=CZ}Advanced topics{/lang}</a></li><li><ol class="section"><li><a href="5_1_adding_images.html"><strong aria-hidden="true">5.1.</strong> {lang=EN}Adding images{/lang}{lang=SI}Adding images{/lang}{lang=CZ}Adding images{/lang}</a></li><li><a href="5_1_screencapture.html"><strong aria-hidden="true">5.2.</strong> {lang=EN}Capture the construction as image{/lang}{lang=SI}Capture the construction as image{/lang}{lang=CZ}Capture the construction as image{/lang}</a></li><li><a href="5_2_jsxoptions.html"><strong aria-hidden="true">5.3.</strong> {lang=EN}JSXGraph options{/lang}{lang=SI}JSXGraph options{/lang}{lang=CZ}JSXGraph options{/lang}</a></li><li><a href="5_3_trigers.html"><strong aria-hidden="true">5.4.</strong> {lang=EN}Events{/lang}{lang=SI}Events{/lang}{lang=CZ}Events{/lang}</a></li><li><a href="5_4_user_actions.html"><strong aria-hidden="true">5.5.</strong> {lang=EN}Saving user actions{/lang}{lang=SI}Saving user actions{/lang}{lang=CZ}Saving user actions{/lang}</a></li><li><a href="5_5_jessie_code.html"><strong aria-hidden="true">5.6.</strong> {lang=EN}Jessie Code{/lang}{lang=SI}Jessie Code{/lang}{lang=CZ}Jessie Code{/lang}</a></li></ol></li><li><a href="6_moodle.html"><strong aria-hidden="true">6.</strong> {lang=EN}JSXGraph and Moodle{/lang}{lang=SI}JSXGraph and Moodle{/lang}{lang=CZ}JSXGraph and Moodle{/lang}</a></li><li><ol class="section"><li><a href="6_1_jsxfilter.html"><strong aria-hidden="true">6.1.</strong> {lang=EN}JSXGraph as a Moodle Filter{/lang}{lang=SI}JSXGraph as a Moodle Filter{/lang}{lang=CZ}JSXGraph as a Moodle Filter{/lang}</a></li><li><a href="6_2_formulas.html"><strong aria-hidden="true">6.2.</strong> {lang=EN}JSXGraph and Moodle Formulas{/lang}{lang=SI}JSXGraph and Moodle Formulas{/lang}{lang=CZ}JSXGraph and Moodle Formulas{/lang}</a></li><li><a href="6_3_stack.html"><strong aria-hidden="true">6.3.</strong> {lang=EN}JSXGraph and Stack{/lang}{lang=SI}JSXGraph and Stack{/lang}{lang=CZ}JSXGraph and Stack{/lang}</a></li></ol></li><li><a href="7_templates.html"><strong aria-hidden="true">7.</strong> {lang=EN}Templates{/lang}{lang=SI}Templates{/lang}{lang=CZ}Templates{/lang}</a></li><li><a href="8_gui.html"><strong aria-hidden="true">8.</strong> {lang=EN}JSX Gui{/lang}{lang=SI}JSX Gui{/lang}{lang=CZ}JSX Gui{/lang}</a></li><li class="spacer"></li><li class="affix"><a href="contributors.html">{lang=EN}Contributors{/lang}{lang=SI}Contributors{/lang}{lang=CZ}Contributors{/lang}</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>

                            <button id="lang-toggle" class="icon-button" type="button" style="font-weight: bold;color: black" title="Change language" aria-label="Change language" aria-haspopup="true" aria-expanded="false" aria-controls="lang-list">
                                EN
                            </button>
                            <ul id="lang-list" class="theme-popup" aria-label="Languages" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="EN">English</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="CZ">Čeština</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="SI">Slovenščina</button></li>
                            </ul>

                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>



                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            

                        </div>

                        <h1 class="menu-title" id="menu-title">{lang=EN}JSXGraph Book{/lang}{lang=SI}Knjiga o JSXGraphu{/lang}{lang=CZ}Příručka JSXGraph{/lang}</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>

                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p>{lang=EN}</p>
<h2><a class="header" href="#this-is-a-manual-about-the-a-hrefhttpsjsxgraphorgjsxgrapha" id="this-is-a-manual-about-the-a-hrefhttpsjsxgraphorgjsxgrapha">This is a manual about the <a href="https://jsxgraph.org/">JSXGraph</a>.</a></h2>
<h4><a class="header" href="#work-in-progress" id="work-in-progress">(Work in progress)</a></h4>
<p>JSXGraph is a cross-browser JavaScript library for interactive geometry, function plotting, charting, and data visualization in the web browser.</p>
<p>This book covers the basics, how to build simple constructions and also some advanced topics on how to include JSXGraph in Moodle. </p>
<p><strong><em>To build JSXGraph constructions you don't need to be programmer (although it helps), but is rather more like
putting together
elements of the construction.</em></strong></p>
<p>Below is an example of power of JSXGraph.<br />
<em>Hint: Move the dot and observe.</em> 
{/lang}</p>
<p>{lang=CZ}</p>
<h2><a class="header" href="#příručka-pro-práci-v-a-hrefhttpsjsxgraphorgjsxgraphua" id="příručka-pro-práci-v-a-hrefhttpsjsxgraphorgjsxgraphua">Příručka pro práci v <a href="https://jsxgraph.org/">JSXGraphu</a>.</a></h2>
<h4><a class="header" href="#na-tomto-díle-se-stále-pracuje" id="na-tomto-díle-se-stále-pracuje">(Na tomto díle se stále pracuje)</a></h4>
<p>JSXGraph je knihovna JavaScriptu pro realizaci dynamické interaktivní geometrie, vykreslování funkcí, grafů a další vizualizace dat přímo ve webovém prohlížeči, nezávisle na jeho typu.</p>
<p>Tato příručka je věnována především úvodu do základních konstrukcí v JSXGraphu, nevyhýbá se však ani pokročilejším tématům, především v souvislosti se začleněním JSXGraphu do Moodle.</p>
<p><strong><em>Chcete-li tvořit dynamické materiály v JSXGraphu, nemusíte být nutně programátorem (i když by Vám to samozřejmě pomohlo), ve většině případů práce připomíná spíše skládání prvků stavebnice.</em></strong></p>
<p>Níže je uvedena ukázka možností JSXGraphu 
(Návod: Pohybujte posuvníkem - bodem na úsečce při dolním okraji okna a sledujte, co se děje).
{/lang}</p>
<p>{lang=SI}
To je priročnik o JSXGraphu.</p>
<p>JSXGraph je knjižnica JavaScript v brskalniku za interaktivno geometrijo, risanje funkcij, grafikone in vizualizacijo podatkov v spletnem brskalniku.</p>
<p>Ta knjiga zajema osnove, kako zgraditi preproste konstrukcije in tudi nekatere napredne teme o tem, kako vključiti JSXGraph v Moodle.</p>
<p>Če želite zgraditi JSXGraph konstrukcije, vam ni treba biti programer (čeprav pomaga), ampak je bolj podoben sestavljanju elementov konstrukcije.</p>
<p>Spodaj je primer moči JSXGraph.
Namig: premaknite piko in opazujte.
{/lang}</p>
<div id="box16" class="jxgbox" style="width:500px; height:333px;margin-left:auto; margin-right:auto;"></div> 
<script type='text/javascript'>
    JXG.Options.board.showNavigation = false;
    var color1 = "crimson";
	var brd16 = JXG.JSXGraph.initBoard('box16', {boundingbox: [-10.4625,7.6,10.4625,-5]});
	brd16.options.point.visible = false;
	brd16.options.point.fixed = false;
	brd16.options.polygon.borders.visible = false;
	var kot16 = brd16.create('slider', [[-9.5,-4],[-0.5,-4],[90,90,-60]], {withlabel:false});	
	var B116 = brd16.create('point', [-1,-4], {name:'B116'});
	var Vues16 = brd16.create('point', [function(){return kot16.Value() > 0 ? -0.9217 : (kot16.Value() < -30 ? -Math.PI/2 : -0.9217+(-Math.PI/2+0.9217)/30*(-kot16.Value()))}, function(){return kot16.Value() > -30 ? -0.55088 : (kot16.Value() < -29 ? -0.55088+(-1+0.55088)/30*(-30-kot16.Value()) : -1)}], {name:'Vues16', color:color1});
	var zoom16 = 1.6;
	var x16 = function(){return -zoom16 * Math.cos(Vues16.X()) * Math.sin(Vues16.Y())};
	var X16 = brd16.create('point', [function(){return B116.X() + zoom16 * Math.sin(Vues16.X())}, function(){return B116.Y()+x16}], {name:'X'});
	var u16 = brd16.create('point', [function(){return zoom16*Math.sin(Vues16.X());},x16], {name:'u16'});
	var k16 = -1;
	var Z16 = brd16.create('point', [function(){return B116.X()}, function(){return B116.Y()+zoom16*Math.cos(Vues16.Y())}], {name:'Z16'});
	var w16 = brd16.create('point', [0,function(){return zoom16*Math.cos(Vues16.Y());}], {name:'w16'});
	var Y_16 = brd16.create('point', [function(){return B116.X()+zoom16*Math.cos(Vues16.X())}, function(){return B116.Y()+zoom16*Math.sin(Vues16.X())*Math.sin(Vues16.Y())}], {name:'Y'});
	var v16 = brd16.create('point', [function(){return zoom16*Math.cos(Vues16.X())},function(){return zoom16*Math.sin(Vues16.X())*Math.sin(Vues16.Y());}], {name:'v16'});
	var O16 = brd16.create('point', [1,2], {name:'O16'});
	var a16 = 1;
	var b16 = 1;
	var d16 = 2; 
	var vzorec16 = brd16.create('slider', [[18,5.5],[18,-2],[1,1,11]], {withlabel:false});
	var K16 = brd16.create('point', [function(){return O16.X() + a16 * u16.X() + b16 * v16.X()},function(){return O16.Y() + a16 * u16.Y() + b16 * v16.Y()}], {name:'K16'});
	var L16 = brd16.create('point', [function(){return O16.X() - a16 * u16.X() + b16 * v16.X()},function(){return O16.Y() - a16 * u16.Y() + b16 * v16.Y()}], {name:'L16'});
	var M16 = brd16.create('point', [function(){return O16.X() - a16 * u16.X() - b16 * v16.X()},function(){return O16.Y() - a16 * u16.Y() - b16 * v16.Y()}], {name:'M16'});
	var N16 = brd16.create('point', [function(){return O16.X() + a16 * u16.X() - b16 * v16.X()},function(){return O16.Y() + a16 * u16.Y() - b16 * v16.Y()}], {name:'N16'});
	brd16.create('polygon', [L16,K16,N16,M16], {fillopacity:0.05});
	brd16.create('segment', [L16,K16], {});
	brd16.create('segment', [K16,N16], {});
	brd16.create('segment', [N16,M16], {});
	brd16.create('segment', [M16,L16], {});
	var P16 = brd16.create('point', [function(){return O16.X() + a16 * u16.X() + b16 * v16.X() + d16 * Math.cos((kot16.Value() < 0 ? 0 : kot16.Value())*Math.PI/180) * u16.X() + d16 * Math.sin((kot16.Value() < 0 ? 0 : kot16.Value())*Math.PI/180) * w16.X()},function(){return O16.Y() + a16 * u16.Y() + b16 * v16.Y() + d16 * Math.cos((kot16.Value() < 0 ? 0 : kot16.Value())*Math.PI/180) * u16.Y() + d16 * Math.sin((kot16.Value() < 0 ? 0 : kot16.Value())*Math.PI/180) * w16.Y()}], {name:'P16'});
	var Q16 = brd16.create('point', [function(){return O16.X() + a16 * u16.X() - b16 * v16.X() + d16 * Math.cos((kot16.Value() < 0 ? 0 : kot16.Value())*Math.PI/180) * u16.X() + d16 * Math.sin((kot16.Value() < 0 ? 0 : kot16.Value())*Math.PI/180) * w16.X()},function(){return O16.Y() + a16 * u16.Y() - b16 * v16.Y() + d16 * Math.cos((kot16.Value() < 0 ? 0 : kot16.Value())*Math.PI/180) * u16.Y() + d16 * Math.sin((kot16.Value() < 0 ? 0 : kot16.Value())*Math.PI/180) * w16.Y()}], {name:'Q16'});
	var R16 = brd16.create('point', [function(){return O16.X() - a16 * u16.X() + b16 * v16.X() - d16 * Math.cos((kot16.Value() < 0 ? 0 : kot16.Value())*Math.PI/180) * u16.X() + d16 * Math.sin((kot16.Value() < 0 ? 0 : kot16.Value())*Math.PI/180) * w16.X()},function(){return O16.Y() - a16 * u16.Y() + b16 * v16.Y() - d16 * Math.cos((kot16.Value() < 0 ? 0 : kot16.Value())*Math.PI/180) * u16.Y() + d16 * Math.sin((kot16.Value() < 0 ? 0 : kot16.Value())*Math.PI/180) * w16.Y()}], {name:'R16'});
	var S16 = brd16.create('point', [function(){return O16.X() - a16 * u16.X() - b16 * v16.X() - d16 * Math.cos((kot16.Value() < 0 ? 0 : kot16.Value())*Math.PI/180) * u16.X() + d16 * Math.sin((kot16.Value() < 0 ? 0 : kot16.Value())*Math.PI/180) * w16.X()},function(){return O16.Y() - a16 * u16.Y() - b16 * v16.Y() - d16 * Math.cos((kot16.Value() < 0 ? 0 : kot16.Value())*Math.PI/180) * u16.Y() + d16 * Math.sin((kot16.Value() < 0 ? 0 : kot16.Value())*Math.PI/180) * w16.Y()}], {name:'S16'});
	brd16.create('polygon', [K16,P16,Q16,N16]);
	brd16.create('segment', [K16,P16], {});
	brd16.create('segment', [P16,Q16], {});
	brd16.create('segment', [Q16,N16], {});
	brd16.create('segment', [N16,K16], {});
	brd16.create('polygon', [L16,M16,S16,R16], {opacity:function(){return vzorec16.Value()==1||vzorec16.Value()==2||vzorec16.Value()==3||vzorec16.Value()==4||vzorec16.Value()==7||vzorec16.Value()==7||vzorec16.Value()==8||vzorec16.Value()==9||vzorec16.Value()==10?0.25:0;}});
	brd16.create('segment', [L16,M16], {});
	brd16.create('segment', [M16,S16], {opacity:function(){return vzorec16.Value()!=5&&vzorec16.Value()!=6&&vzorec16.Value()!=11?1:0}});
	brd16.create('segment', [S16,R16], {opacity:function(){return vzorec16.Value()!=5&&vzorec16.Value()!=6&&vzorec16.Value()!=11?1:0}});
	brd16.create('segment', [R16,L16], {opacity:function(){return vzorec16.Value()!=5&&vzorec16.Value()!=6&&vzorec16.Value()!=11?1:0}});
	var T16 = brd16.create('point', [function(){return O16.X() + a16 * u16.X() + b16 * v16.X() + d16 * Math.cos((kot16.Value() < 0 ? 0 : kot16.Value())*Math.PI/180) * v16.X() + d16 * Math.sin((kot16.Value() < 0 ? 0 : kot16.Value())*Math.PI/180) * w16.X()},function(){return O16.Y() + a16 * u16.Y() + b16 * v16.Y() + d16 * Math.cos((kot16.Value() < 0 ? 0 : kot16.Value())*Math.PI/180) * v16.Y() + d16 * Math.sin((kot16.Value() < 0 ? 0 : kot16.Value())*Math.PI/180) * w16.Y()}], {name:'T16'});
	var U16 = brd16.create('point', [function(){return O16.X() - a16 * u16.X() + b16 * v16.X() + d16 * Math.cos((kot16.Value() < 0 ? 0 : kot16.Value())*Math.PI/180) * v16.X() + d16 * Math.sin((kot16.Value() < 0 ? 0 : kot16.Value())*Math.PI/180) * w16.X()},function(){return O16.Y() - a16 * u16.Y() + b16 * v16.Y() + d16 * Math.cos((kot16.Value() < 0 ? 0 : kot16.Value())*Math.PI/180) * v16.Y() + d16 * Math.sin((kot16.Value() < 0 ? 0 : kot16.Value())*Math.PI/180) * w16.Y()}], {name:'U16'});
	var V16 = brd16.create('point', [function(){return O16.X() + a16 * u16.X() - b16 * v16.X() - d16 * Math.cos((kot16.Value() < 0 ? 0 : kot16.Value())*Math.PI/180) * v16.X() + d16 * Math.sin((kot16.Value() < 0 ? 0 : kot16.Value())*Math.PI/180) * w16.X()},function(){return O16.Y() + a16 * u16.Y() - b16 * v16.Y() - d16 * Math.cos((kot16.Value() < 0 ? 0 : kot16.Value())*Math.PI/180) * v16.Y() + d16 * Math.sin((kot16.Value() < 0 ? 0 : kot16.Value())*Math.PI/180) * w16.Y()}], {name:'V16'});
	var W16 = brd16.create('point', [function(){return O16.X() - a16 * u16.X() - b16 * v16.X() - d16 * Math.cos((kot16.Value() < 0 ? 0 : kot16.Value())*Math.PI/180) * v16.X() + d16 * Math.sin((kot16.Value() < 0 ? 0 : kot16.Value())*Math.PI/180) * w16.X()},function(){return O16.Y() - a16 * u16.Y() - b16 * v16.Y() - d16 * Math.cos((kot16.Value() < 0 ? 0 : kot16.Value())*Math.PI/180) * v16.Y() + d16 * Math.sin((kot16.Value() < 0 ? 0 : kot16.Value())*Math.PI/180) * w16.Y()}], {name:'W16'});
	brd16.create('polygon', [N16,V16,W16,M16], {opacity:function(){return vzorec16.Value()==1||vzorec16.Value()==5||vzorec16.Value()==6||vzorec16.Value()==10||vzorec16.Value()==11?0.25:0;}});
	brd16.create('segment', [N16,V16], {opacity:function(){return vzorec16.Value()==1||vzorec16.Value()==5||vzorec16.Value()==6||vzorec16.Value()==10||vzorec16.Value()==11?1:0}});
	brd16.create('segment', [V16,W16], {opacity:function(){return vzorec16.Value()==1||vzorec16.Value()==5||vzorec16.Value()==6||vzorec16.Value()==10||vzorec16.Value()==11?1:0}});
	brd16.create('segment', [W16,M16], {opacity:function(){return vzorec16.Value()==1||vzorec16.Value()==5||vzorec16.Value()==6||vzorec16.Value()==10||vzorec16.Value()==11?1:0}});
	brd16.create('segment', [M16,N16], {});
	brd16.create('polygon', [K16,T16,U16,L16], {opacity:function(){return vzorec16.Value()<7?0.25:0;}});
	brd16.create('segment', [K16,T16], {opacity:function(){return vzorec16.Value()<7?1:0}});
	brd16.create('segment', [T16,U16], {opacity:function(){return vzorec16.Value()<7?1:0}});
	brd16.create('segment', [U16,L16], {opacity:function(){return vzorec16.Value()!=7&&vzorec16.Value()!=8&&vzorec16.Value()!=9&&vzorec16.Value()!=10&&vzorec16.Value()!=11?1:0}});
	brd16.create('segment', [L16,K16], {opacity:function(){return vzorec16.Value()==5?1:0}});
	var A16 = brd16.create('point', [function(){return O16.X() + a16 * u16.X() + b16 * v16.X() + d16 * Math.cos((kot16.Value() < 0 ? 0 : kot16.Value())*Math.PI/180) * u16.X() + d16 * Math.sin((kot16.Value() < 0 ? 0 : kot16.Value())*Math.PI/180) * w16.X() + 2 * a16 * Math.cos(2 * (kot16.Value() < 0 ? 0 : kot16.Value())*Math.PI/180) * u16.X() + b16 * Math.sin(2 * (kot16.Value() < 0 ? 0 : kot16.Value())*Math.PI/180) * w16.X()},function(){return O16.Y() + a16 * u16.Y() + b16 * v16.Y() + d16 * Math.cos((kot16.Value() < 0 ? 0 : kot16.Value())*Math.PI/180) * u16.Y() + d16 * Math.sin((kot16.Value() < 0 ? 0 : kot16.Value())*Math.PI/180) * w16.Y() + 2 * a16 * Math.cos(2 * (kot16.Value() < 0 ? 0 : kot16.Value())*Math.PI/180) * u16.Y() + b16 * Math.sin(2 * (kot16.Value() < 0 ? 0 : kot16.Value())*Math.PI/180) * w16.Y()}], {name:'A16'});
	var B16 = brd16.create('point', [function(){return O16.X() + a16 * u16.X() - b16 * v16.X() + d16 * Math.cos((kot16.Value() < 0 ? 0 : kot16.Value())*Math.PI/180) * u16.X() + d16 * Math.sin((kot16.Value() < 0 ? 0 : kot16.Value())*Math.PI/180) * w16.X() + 2 * a16 * Math.cos(2 * (kot16.Value() < 0 ? 0 : kot16.Value())*Math.PI/180) * u16.X() + b16 * Math.sin(2 * (kot16.Value() < 0 ? 0 : kot16.Value())*Math.PI/180) * w16.X()},function(){return O16.Y() + a16 * u16.Y() - b16 * v16.Y() + d16 * Math.cos((kot16.Value() < 0 ? 0 : kot16.Value())*Math.PI/180) * u16.Y() + d16 * Math.sin((kot16.Value() < 0 ? 0 : kot16.Value())*Math.PI/180) * w16.Y() + 2 * a16 * Math.cos(2 * (kot16.Value() < 0 ? 0 : kot16.Value())*Math.PI/180) * u16.Y() + b16 * Math.sin(2 * (kot16.Value() < 0 ? 0 : kot16.Value())*Math.PI/180) * w16.Y()}], {name:'B16'});
	brd16.create('polygon', [B16,Q16,P16,A16], {opacity:function(){return vzorec16.Value()<9&&vzorec16.Value()!=7?0.25:0;}});
	brd16.create('segment', [B16,Q16], {opacity:function(){return vzorec16.Value()!=7&&vzorec16.Value()!=9&&vzorec16.Value()!=10&&vzorec16.Value()!=11?1:0}});
	brd16.create('segment', [Q16,P16], {});
	brd16.create('segment', [P16,A16], {opacity:function(){return vzorec16.Value()!=7&&vzorec16.Value()!=9&&vzorec16.Value()!=10&&vzorec16.Value()!=11?1:0}});
	brd16.create('segment', [A16,B16], {opacity:function(){return vzorec16.Value()!=7&&vzorec16.Value()!=9&&vzorec16.Value()!=10&&vzorec16.Value()!=11?1:0}});
	brd16.options.text.anchory = 'top';
	brd16.options.text.fontsize = 16;
	var ploscina16 = brd16.create('slider', [[0.5,-4],[9.5,-4],[0,0,8]], {withlabel:false});
		ploscina16.setDisplayRendNode(false);
		ploscina16.highline.setDisplayRendNode(false);
		ploscina16.baseline.setDisplayRendNode(false);
	brd16.create('text', [function(){return V16.X() + 1.3},function(){return V16.Y()-0.3}, function(){return 'a'}], {opacity:function(){return ploscina16.Value() > 0 ? 1 : 0}});
	brd16.create('text', [function(){return W16.X() + 0.3},function(){return W16.Y()+1.375}, function(){return 'a'}], {opacity:function(){return ploscina16.Value() > 0 ? 1 : 0}});
	brd16.create('text', [function(){return V16.X() + 1.2},function(){return V16.Y() + 1.75}, function(){return 'a^2'}], {opacity:function(){return ploscina16.Value() > 1 ? 1 : 0}});
	brd16.create('text', [function(){return N16.X() + 1.2},function(){return N16.Y() + 1.75}, function(){return 'a^2'}], {opacity:function(){return ploscina16.Value() > 2 ? 1 : 0}});
	brd16.create('text', [function(){return M16.X() + 1.2},function(){return M16.Y() + 1.75}, function(){return 'a^2'}], {opacity:function(){return ploscina16.Value() > 3 ? 1 : 0}});
	brd16.create('text', [function(){return Q16.X() + 1.2},function(){return Q16.Y() + 1.75}, function(){return 'a^2'}], {opacity:function(){return ploscina16.Value() > 4 ? 1 : 0}});
	brd16.create('text', [function(){return B16.X() + 1.2},function(){return B16.Y() + 1.75}, function(){return 'a^2'}], {opacity:function(){return ploscina16.Value() > 5 ? 1 : 0}});
	brd16.create('text', [function(){return K16.X() + 1.2},function(){return K16.Y() + 1.75}, function(){return 'a^2'}], {opacity:function(){return ploscina16.Value() > 6 ? 1 : 0}});
	brd16.create('text', [function(){return L16.X() + 1.2},function(){return L16.Y() + 1.75}, function(){return 'P=?'}], {opacity:function(){return ploscina16.Value() > 7 ? 1 : 0}});
	kot16.on('drag', function(){
		if(kot16.Value() > -60){
			ploscina16.setDisplayRendNode(false);
			ploscina16.highline.setDisplayRendNode(false);
			ploscina16.baseline.setDisplayRendNode(false);
			ploscina16.moveTo([-9.5,-4]);
		} else {
			ploscina16.showElement();
			ploscina16.highline.showElement();
			ploscina16.baseline.showElement();
			ploscina16.moveTo([-9.75,-4]);
		}
	});
</script>
<p><a href="https://itemspro.eu"><img src="files/images/items_logo_blue.png" alt="ITEMS" /></a>
<a href="https://ec.europa.eu/programmes/erasmus-plus/"><img src="files/images/eu_flag_co_funded_pos_rgb_left_small.jpg" alt="Cofunded by the Erasmus+ programme of the European union" /></a></p>
<p>{lang=EN}</p>
<h2><a class="header" href="#how-to-setup" id="how-to-setup">How to setup</a></h2>
<p>When we prepare JSX construction it is most convenient to prepare it locally. For that we have to create some file (eg. 
example.htm), copy paste template provided below and we can start constructing. After we save the program, we can open it in our
favorite browser (Firefox, Chrome, etc). 
We can repeat following: edit the file, save it and refresh it (<em>(F5)</em> in a browser) until we're not satisfied with result.</p>
<p>Basic template for building and testing is below
{/lang}
{lang=CZ}</p>
<h2><a class="header" href="#jak-začít" id="jak-začít">Jak začít</a></h2>
<p>Když chceme vytvořit novou konstrukci v JSXGraphu, nejlepší je připravit si ji lokálně, ve svém počítači. 
Není nutné ji nahrávat na nějaký server, stačí, když ji uložíme formou HTML souboru do svého počítače a následně otevřeme v našem oblíbeném prohlížeči.</p>
<p>Níže je uveden vzor obsahu HTML souboru webové stránky pro tvorbu a testování JSX appletu. 
Stačí jednoduše vytvořit soubor, řekněme s názvem <em>priklad.html</em>, a zkopírovat do něj obsah níže uvedeného okna. Jediné, co potom budeme při tvorbě vlastního appletu
měnit, je pasáž mezi tagy <em>&lt;script&gt;, &lt;/script&gt;</em>.</p>
<p>Dokud nejsme spokojeni s podobou appletu, opakujeme následující akce: editace souboru, jeho uložení a prohlédnutí prohlížečem (zobrazení stránky v prohlížeči aktualizujeme stisknutím <em>(F5)</em>).<br />
{/lang}
{lang=SI}
When we prepare JSX construction it is most convenient to prepare it locally. We don't need to upload it to some server, 
we just need to save it and refresh the page <em>(F5)</em> in browser. 
Very simple template for building and testing is below
{/lang}</p>
<pre><code class="language-HTML">&lt;!DOCTYPE HTML&gt;
&lt;html lang=&quot;en&quot;&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot;&gt;
        &lt;title&gt;JSXGraph template&lt;/title&gt;
        &lt;meta content=&quot;text/html; charset=utf-8&quot; http-equiv=&quot;Content-Type&quot;&gt;
        &lt;script type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot; src=&quot;https://cdnjs.cloudflare.com/ajax/libs/jsxgraph/0.99.7
/jsxgraphcore.js&quot;&gt;&lt;/script&gt;
        &lt;script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js' async&gt;&lt;/script&gt;
        &lt;script type=&quot;text/x-mathjax-config&quot;&gt;
          MathJax.Hub.Config({
              &quot;HTML-CSS&quot;: {availableFonts: [&quot;TeX&quot;],scale: 90},
               tex2jax: {inlineMath: [[&quot;$&quot;,&quot;$&quot;]],  displayMath: [[&quot;$$&quot;,&quot;$$&quot;]],  processEscapes: true},
                config:[&quot;TeX-AMS_HTML.js&quot;]});
        &lt;/script&gt;   
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/jsxgraph/0.99.7/jsxgraph.css
&quot; /&gt;
    &lt;/head&gt;
  &lt;body&gt;

     &lt;div id=&quot;jxgbox&quot; class=&quot;jxgbox&quot; style=&quot;width:500px; height:200px;&quot;&gt;&lt;/div&gt;

     &lt;script&gt;
        var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-5, 2, 5, -2]});
     &lt;/script&gt;

  &lt;/body&gt;
&lt;/html&gt;

</code></pre>
<p>{lang=EN}
<em>This scripts are all downloaded from the internet, therefore we need an constant internet connection.</em>
{/lang}
{lang=CZ}
<em>Všechny použité skripty jsou nahrávány z internetu, proto je třeba mít trvalé internetové připojení.</em>
{/lang}
{lang=SI}
<em>This scripts are all downloaded from the internet, therefore we need an constant internet connection.</em>
{/lang}</p>
<p>{lang=EN}</p>
<h2><a class="header" href="#basics" id="basics">Basics</a></h2>
<p>JSXGraph construction is composed from:</p>
<ul>
<li>drawing board</li>
<li>objects (points, lines, etc.)</li>
<li>relations between objects (optional, if we want some dynamics in the construction)</li>
<li>events (optional, if we want some additional actions to be triggered)</li>
</ul>
<p>In this section we will cover how to create drawing board, objects and use them to construct some simple examples.</p>
<p>{/lang}</p>
<p>{lang=EN}</p>
<h2><a class="header" href="#drawing-area" id="drawing-area">Drawing area</a></h2>
<p>JSXGraph needs canvas as a place to put constructions on. Because we have HTML and Javascript we need an element in 
HTML which we will tell Javascript to use as canvas. First we create a place in HTML where we will our construction be. 
For this we use <code>div</code> element with some properties.</p>
<pre><code class="language-HTML">&lt;div id=&quot;jxgbox&quot; class=&quot;jxgbox&quot; style=&quot;width:500px; height:200px;&quot;&gt;&lt;/div&gt;
</code></pre>
<p>If look at the line closely we see few properties. For us it is important <code>id=&quot;jxgbox&quot;</code> which we use to connect with JSXGraph.
Next is <code>class=&quot;jxgbox&quot;</code> where we can specify how our board will look like. This is more advanced topic and will be discussed later.
Last property is `style=&quot;width:500px; height:200px;&quot; where we define size of our drawing board.<br />
<em>Important: here we do not define our coordinate system, but only the size of our canvas</em></p>
<p>When we have defined our canvas, we have to connect them with JSXGraph. This is done with following line, which should be put inside</p>
<pre><code class="language-JS">var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-5, 2, 5, -2]});
</code></pre>
<p>We can see we called function initBoard, which constructs our drawing board . This function needs at least one argument, 
which is the <em>id</em> of the element <code>div</code> we defined in our example <code>jxgbox</code>. <code>boundingbox: [-5, 2, 5, -2]</code> tells
JSXGraph coordinate system of our construction.</p>
<p>Observing both lines we see, that we have two measures for size. With <code>div</code> we created canvas with the size in pixels. 
Then we declared also coordinate system with board where we defined our coordinate system, which we will use to place 
objects on the board. 
{/lang}</p>
<p>{lang=SI}
JSXGraph needs canvas as a place to put constructions on. Because we have HTML and Javascript we need an element in 
HTML which we will tell Javascript to use as canvas. This is done like this</p>
<pre><code class="language-HTML">&lt;div id=&quot;jxgbox&quot; class=&quot;jxgbox&quot; style=&quot;width:500px; height:200px;&quot;&gt;&lt;/div&gt;
</code></pre>
<p>If look at the line closely we see few properties. For us it is important <code>id=&quot;jxgbox&quot;</code> which we use to connect with JSXGraph.
Next is <code>class=&quot;jxgbox&quot;</code> where we can specify how our board will look like. This is more advanced topic and will be discussed later.
Last property is `style=&quot;width:500px; height:200px;&quot; where we define size of our drawing board.<br />
<em>Important: here we do not define our coordinate system, but only the size of our canvas</em></p>
<p>When we have defined our canvas, we have to connect them with JSXGraph. This is done with following line, which should be put inside</p>
<pre><code class="language-JS">var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-5, 2, 5, -2]});
</code></pre>
<p>We can see we called function initBoard, which constructs our drawing board . This function need at least one argument, 
which is the name of id we defined earlier for div in our example <code>jxgbox</code>. <code>boundingbox: [-5, 2, 5, -2]</code> tells
JSXGraph coordinate system of our construction.</p>
<p>Code of whole example is then following:{/lang}</p>
<p>{lang=CZ}</p>
<h2><a class="header" href="#nákresna" id="nákresna">Nákresna</a></h2>
<p>JSXGraph potřebuje nějakou zobrazovací plochu, nákresnu, na kterou může vykreslovat konstrukce. Jelikož využíváme HTML a Javascript, potřebujeme vytvořit prvek v HTML, který bude Javascript používat jako své plátno. Nejprve vybereme v HTML místo, kde bude naše konstrukce umístěna. K tomu využijeme blokový prvek <code>&lt;div&gt;</code>, kterému nastavíme potřebné atributy.</p>
<pre><code class="language-HTML">&lt;div id=&quot;jxgbox&quot; class=&quot;jxgbox&quot; style=&quot;width:500px; height:200px;&quot;&gt;&lt;/div&gt;
</code></pre>
<p>Pokud se na řádek s kódem pozorně zaměříme, odhalíme několik nadefinovaných vlastností. Pro nás nejdůležitější je <code>id=&quot;jxgbox&quot;</code>, který slouží k identifikaci nákresny a její propojení s JSXGraph. Následuje <code>class=&quot;jxgbox&quot;</code>, což je přiřazení třídy, které slouží k nadefinování vzhledu naší nákresny. To je však pokročilejší téma, kterému se budeme věnovat později. Poslední vlastností je <code>style=&quot;width:500px; height:200px;&quot;</code>. Ta slouží k určení velikosti naší nákresny na webové stránce. </p>
<p><em>Důležité: zde nenastavujeme podobu a polohu naší soustavy souřadnic, ale pouze velikost zobrazované nákresny</em></p>
<p>Jakmile jsme si nadefinovali naší nákresnu, musíme ji propojit s JSXGraph. Toho dosáhneme následujícím řádkem, který však musíme umístit do prvku <code>&lt;script&gt;</code>, abychom jednoznačně určili, že se již jedná o samotný skript.</p>
<pre><code class="language-JS">var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-5, 2, 5, -2]});
</code></pre>
<p>Vidíme, že jsme využili funkci <code>initBoard</code>, která po svém zavolání vytvoří naší nákresnu. Tato funkce pro správné fungování potřebuje alespoň jeden argument. V našem případě jsme jako argument použili <em>id</em> námi definovaného prvku <code>&lt;div&gt;</code> tj. <code>jxgbox</code>. Atribut <code>boundingbox: [-5, 2, 5, -2]</code> poté JSXGraph sděluje, jakou část systému souřadnic chceme pro svou konstrukci zobrazovat.</p>
<p>Pokud mezi sebou porovnáme oba řádky kódu, zjistíme, že pro nastavení velikostí využíváme dvě různé míry. Pomocí <code>&lt;div&gt;</code> jsme určili velikost nákresny v pixelech. Poté jsme na nákresně definovali systém souřadnic, který bude sloužit k umisťování objektů do nákresny.
{/lang}</p>
<p>{lang=EN}</p>
<h2><a class="header" href="#creating-points" id="creating-points">Creating points</a></h2>
<p>Points are one of the most basic objects in JSXGraph. We always create objects on the JSX board, therefore we must use same 
board variable for the construction of all objects that will be on board.
{/lang}</p>
<p>{lang=SI}</p>
<h2><a class="header" href="#risanje-točk" id="risanje-točk">Risanje točk</a></h2>
<p>{/lang}</p>
<p>{lang=CZ}</p>
<h2><a class="header" href="#vytváření-bodů" id="vytváření-bodů">Vytváření bodů</a></h2>
<p>Body jsou základními a nejjednoduššími objekty v JSXGraph. V tomto příkladu zakreslíme do nákresny dva body. 
{/lang}</p>
<pre><code class="language-JS">&lt;div id=&quot;jxgbox&quot; class=&quot;jxgbox&quot; style=&quot;width:500px; height:200px;&quot;&gt;&lt;/div&gt;
&lt;script&gt;
 var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-5, 2, 5, -2]});
 board.create('point',[-2,1]);
 var q = board.create('point',[3,0]);
&lt;/script&gt;
</code></pre>
<div id="jxgbox" class="jxgbox" style="width:500px; height:200px;"></div>
<script>
 var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-5, 2, 5, -2]});
 board.create('point',[-3,1]);
 var q = board.create('point',[3,0]);
</script>
<p>{lang=EN}
Let us now observe <code>board.create('point',[-2,1]);</code>. Here we use variable board and call a method <em>create</em> which takes 
two arguments. First argument is the type of the object and second the coordinates where this object should be. If we
define coordinates outside of the bounding box, the object will exist but won't be visible because it is outside visible 
area of our drawing board. </p>
<p>Next line <code>var q = board.create('point',[3,0]);</code> is very similar to the previous line, with only one diference. We start 
the line with <code>var q = </code> which we use to store this object in variable <em>q</em>. This is good and necessary practice, because 
in the constructions we often reference different object and define their relationships, which will be more apparent in following pages.</p>
<p>{/lang}
{lang=CZ}
Zaměřme se nyní na <code>board.create('point',[-2,1]);</code>. Zde využíváme proměnnou <em>board</em> a metodu <em>create</em>, která vyžaduje dva argumenty. Prvním argumentem určujeme, jaký typ objekt se má v nákresně vytvořit, což je v našem případě bod, <em>point</em>. Druhý argument určuje souřadnice, na kterých bude bod v nákresně sestrojen. Pokud použijeme souřadnice, které leží mimo námi nadefinovaný systém souřadnic, tak se bod stejně sestrojí. Vytvořený bod ale nebude na naší nákresně viditelný, neboť bude sestrojen mimo zobrazovanou plochu. Pohybem po nákresně pomocí zoomu a šipek v jejím pravém dolním rohu je však možné sestrojený bod objevit.</p>
<p>Další řádek <code>var q = board.create('point',[3,0]);</code> je velice podobný předchozí konstrukci pouze s jedním rozdílem. Naší konstrukci začínáme <code>var q = </code>. Toto přiřazení slouží obecně k ukládání objektů do proměnných. V naší ukázce sestrojený bod ukládáme do proměnné <em>q</em>.</p>
<p>Ukládání objektů do proměnných je dobrou a často nezbytnou praxí. V konstrukcích se budeme často odkazovat na existující objekty a definovat mezi nimi vztahy a to právě pomocí proměnných. Toto bude patrnější na následujících stránkách.
{/lang}</p>
<p>{lang=EN}</p>
<h2><a class="header" href="#creating-lines" id="creating-lines">Creating lines</a></h2>
<p>Lines are the next type of the objects that we will learn. Line is defined by two points through which line is drawn.
Here is an example of a board with two lines.
{/lang}
{lang=SI}
Creating basic objects
{/lang}
{lang=CZ}</p>
<h2><a class="header" href="#kreslení-přímek" id="kreslení-přímek">Kreslení přímek</a></h2>
<p>Dalším objektem, s jehož konstrukcí se seznámíme, je přímka.
Ta je v JSXGraphu definována dvěma body, kterými prochází. </p>
<p>Níže je uveden příklad kódu, kterým jsou v nákresně narýsovány dvě přímky. 
První z nich je zadána přímo souřadnicemi určujících bodů, druhá je potom definována pomocí proměnných, které jsou 
jejím určujícím bodům přiřazeny.</p>
<p>{/lang}</p>
<pre><code class="language-JS">&lt;div id=&quot;jxgbox&quot; class=&quot;jxgbox&quot; style=&quot;width:500px; height:200px;&quot;&gt;&lt;/div&gt;
&lt;script&gt;
 var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-5, 2, 5, -2]});
 var line1 = board.create(&quot;line&quot;,[[-3,1],[3,-1]]);

 var p = board.create('point',[-2,-1]);
 var q = board.create('point',[3,1]);
 var line2 = board.create(&quot;line&quot;,[p,q]);
&lt;/script&gt;
</code></pre>
<p>{lang=EN}
Result:
{/lang}</p>
<p>{lang=CZ}
Výsledek:
{/lang}</p>
<div id="jxgbox" class="jxgbox" style="width:500px; height:200px;"></div>
<script>
 var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-5, 2, 5, -2]});
 var line1 = board.create("line",[[-3,1],[3,-1]]);
 var p = board.create('point',[-2,-1]);
 var q = board.create('point',[3,1]);
 var line2 = board.create("line",[p,q]);
</script>
<p>{lang=EN}
Line of code <code>var line1 = board.create(&quot;line&quot;,[[-3,1],[3,-1]]);</code> creates $line1$ through two points <code>[-3,1]</code> and <code>[3,-1]</code>. 
For each point again we had to define $x$ and $y$ coordinate. Because for the line we need to provide a list of two points, 
we enclose both points in square brackets, therefore the list of two points is <code>[[-3,1],[3,-1]]</code>.</p>
<p>For the second $line2$ we first defined two points $p$ and $q$ and used them as `[p,q] when defining the $line2$. Here we already
see why ìt is useful to store objects in variables, because now we could define third line, that could also go through point $p$ or $q$ 
and we don't need to worry if coordinates are correct.</p>
<p><em>Note: In Javascript lists are written in square brackets <strong>[ ]</strong>.</em> 
{/lang}</p>
<p>{lang=CZ}
Řádek s kódem <code>var line1 = board.create(&quot;line&quot;,[[-3,1],[3,-1]]);</code> vytváří přímku $line1$, která prochází 
body <code>[-3,1]</code> a <code>[3,-1]</code>. 
Každý bod je definován uspořádanou dvojicí (seznamem) souřadnic $x$ a $y$. Uspořádaný seznam je uzavřen do hranatých
závorek [...]. Protože přímka je určena dvěma body, zapisujeme do její definice seznam těchto bodů<code>[[-3,1],[3,-1]]</code>.</p>
<p>V případě druhé přímky $line2$ jsme nejprve definovali dva body $p$ a $q$ a v definici přímky použili 
jejich proměnné <code>[p,q]</code>. Již na tomto jednoduchém příkladě vidíme, jak je užitečné
ukládat objekty do proměnných. Potom můžeme například klidně definovat třetí přímku, procházející 
některým z bodů $p$, $q$ a nemusíme se strachovat, zda jeho souřadnice opisujeme dobře.</p>
<p><em>Poznámka: V Javascriptu je seznam uváděn v hranatých závorkách <strong>[ ]</strong>.</em> 
{/lang}</p>
<p>{lang=EN}</p>
<h2><a class="header" href="#adding-attributes-to-the-objects" id="adding-attributes-to-the-objects">Adding attributes to the objects</a></h2>
<p>Objects in JSXGraph have attributes, which describes them. Some of them are common (like color, name, etc.) and some are 
more specific. Points have properties for e.g. shape, where line has other attribute e.g. if (attribute straightLast) and 
how line ends at the second point (more <a href="https://jsxgraph.uni-bayreuth.de/docs/symbols/Line.html">here</a>). 
We can always look at the <a href="https://jsxgraph.uni-bayreuth.de/docs/index.html">JSXGraph API documentation</a>, which describes 
all the objects and their attributes. </p>
<p>Let us look now at the example. 
{/lang}</p>
<p>{lang=SI}</p>
<h2><a class="header" href="#adding-attributes-to-the-objects-1" id="adding-attributes-to-the-objects-1">Adding attributes to the objects</a></h2>
<p>Objects in JSXGraph have attributes, which describes them. Some of them are common (like color, name, etc.) and some are 
more specific. Points have properties for e.g. shape, where line has other attribute e.g. if (attribute straightLast) and 
how line ends at the second point (more <a href="https://jsxgraph.uni-bayreuth.de/docs/symbols/Line.html">here</a>). 
We can always look at the <a href="https://jsxgraph.uni-bayreuth.de/docs/index.html">JSXGraph API documentation</a>, which describes 
all the objects and their attributes. </p>
<p>Let us look now at the example. 
{/lang}</p>
<p>{lang=CZ}</p>
<h2><a class="header" href="#nastavení-vlastností-objektů" id="nastavení-vlastností-objektů">Nastavení vlastností objektů</a></h2>
<p>Objekty v JSXGraphu mají atributy, které je charakterizují. Některé z nich jsou společné všem 
(jako barva, jméno apod.), některé jsou typické pro objekty konkrétního druhu. 
Body mají například různé tvary, u přímky pak lze např. stanovit, zda bude končit v druhém ze svých určujících bodů
(atribut <em>straightLast</em>) a jak v něm bude končit (více <a href="https://jsxgraph.uni-bayreuth.de/docs/symbols/Line.html">zde</a>). </p>
<p>Popisy všech atributů objektů JSXGraphu jsou uvedeny v dokumentaci <a href="https://jsxgraph.uni-bayreuth.de/docs/index.html">JSXGraph Reference</a>. </p>
<p>Podívejme se na následující příklad: 
{/lang}</p>
<pre><code class="language-JS">&lt;div id=&quot;jxgbox&quot; class=&quot;jxgbox&quot; style=&quot;width:500px; height:200px;&quot;&gt;&lt;/div&gt;
&lt;script&gt;
 var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-5, 2, 5, -2]});

 var p = board.create('point',[-2,-1],{name:&quot;first&quot;, size:5, color:&quot;FF0000&quot;});
 var q = board.create('point',[3,1],{name:&quot;last&quot;,fixed:true, face:&quot;[]&quot;});

 var line2 = board.create(&quot;line&quot;,[p,q],{straightLast:false, dash:&quot;4&quot; });
&lt;/script&gt;
</code></pre>
<p>{lang=EN}
Result:
{/lang}</p>
<p>{lang=SI}
Result:
{/lang}</p>
<p>{lang=CZ}
Výsledek:
{/lang}</p>
<div id="jxgbox" class="jxgbox" style="width:500px; height:200px;"></div>
<script>
 var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-5, 2, 5, -2]});
 var p = board.create('point',[-2,-1],{name:"first", size:5, color:"FF0000"});
 var q = board.create('point',[3,1],{name:"last",fixed:true, face:"[]"});
 var line2 = board.create("line",[p,q],{straightLast:false, dash:"4" });
</script>
<p>{lang=EN}
In this example we added some attributes to the both points and to the line. 
In all three examples we defined attributes as a list written between <code>{ }</code>. For each attribute we must write its name
and a value. As we mentioned earlier, objects can have specific attributes and also more general borrowed (inherited) 
from other objects.</p>
<p>In <code>var p = board.create('point',[-2,-1],{name:&quot;first&quot;, size:5, color:&quot;FF0000&quot;});</code> first attribute is <em>name</em> which is borrowed 
from <a href="https://jsxgraph.uni-bayreuth.de/docs/symbols/JXG.GeometryElement.html#name">GeometryElement</a>, attribute <em>color</em> is also 
borowed, where attribute <a href="https://jsxgraph.uni-bayreuth.de/docs/symbols/Point.html#size"><em>size</em></a> is not borrowed but belongs to object Point.
We can read from the documentation: <em>Size of a point, either in pixel or user coordinates. Means radius resp. half the 
width of a point (depending on the face).</em></p>
<p>Second point has some interesting attributes <code>var q = board.create('point',[3,1],{name:&quot;last&quot;,fixed:true, face:&quot;[]&quot;});</code>
First is the attribute <em>fixed</em> which defines whether objects can be moved (dragged) on the board. <em>Default</em> value for this
attribute is false, which means we can move all objects on the board if they are not explicitly fixed. Now we first mentioned
<em>default value</em>, which is used when do not explicitly set another value for some attribute. In the documentation for each 
attribute default value is also presented. The second new attribute is <a href="https://jsxgraph.uni-bayreuth.de/docs/symbols/Point.html#face"><em>face</em></a>
where we used one of the possible shapes of a point. </p>
<p>When we defined <code>var line2 = board.create(&quot;line&quot;,[p,q],{straightLast:false, dash:&quot;4&quot; });</code>, we used two attributes,
first defining how line will end at second point (<em>straightLast</em>) and second defining how the line will be drawn (<em>dash</em>).
Again, <em>dash</em>  can have different values, <a href="https://jsxgraph.uni-bayreuth.de/docs/symbols/JXG.GeometryElement.html#dash">documentation for dash attribute</a> 
tells us which are possible values.</p>
<p>All objects have attributes, also Board object has <a href="https://jsxgraph.uni-bayreuth.de/docs/symbols/JXG.Board.html">them</a>. 
One of the attributes is <em>boundingbox</em>, which we used from first example, but didn't talk about it until now. 
E.g. if you don't like the navigation (bottom right), then you can add attribute <em>showNavigation</em> and set it to false. Try it!</p>
<p><em><em>We can see that we can use attributes to fine tune on how our construction will behave and look.</em></em></p>
<p><strong>Documentation is a great resource for discovering attributes and also has some
examples of their usage.</strong>
{/lang}</p>
<p>{lang=SI}
In this example we added some attributes to the both points and to the line. 
In all three examples we defined attributes as a list written between <code>{ }</code>. For each attribute we must write its name
and a value. As we mentioned earlier, objects can have specific attributes and also more general borrowed (inherited) 
from other objects.</p>
<p>In <code>var p = board.create('point',[-2,-1],{name:&quot;first&quot;, size:5, color:&quot;FF0000&quot;});</code> first attribute is <em>name</em> which is borrowed 
from <a href="https://jsxgraph.uni-bayreuth.de/docs/symbols/JXG.GeometryElement.html#name">GeometryElement</a>, attribute <em>color</em> is also 
borowed, where attribute <a href="https://jsxgraph.uni-bayreuth.de/docs/symbols/Point.html#size"><em>size</em></a> is not borrowed but belongs to object Point.
We can read from the documentation: <em>Size of a point, either in pixel or user coordinates. Means radius resp. half the 
width of a point (depending on the face).</em></p>
<p>Second point has some interesting attributes <code>var q = board.create('point',[3,1],{name:&quot;last&quot;,fixed:true, face:&quot;[]&quot;});</code>
First is the attribute <em>fixed</em> which defines whether objects can be moved (dragged) on the board. <em>Default</em> value for this
attribute is false, which means we can move all objects on the board if they are not explicitly fixed. Now we first mentioned
<em>default value</em>, which is used when do not explicitly set another value for some attribute. In the documentation for each 
attribute default value is also presented. The second new attribute is <a href="https://jsxgraph.uni-bayreuth.de/docs/symbols/Point.html#face"><em>face</em></a>
where we used one of the possible shapes of a point. </p>
<p>When we defined <code>var line2 = board.create(&quot;line&quot;,[p,q],{straightLast:false, dash:&quot;4&quot; });</code>, we used two attributes,
first defining how line will end at second point (<em>straightLast</em>) and second defining how the line will be drawn (<em>dash</em>).
Again, <em>dash</em>  can have different values, <a href="https://jsxgraph.uni-bayreuth.de/docs/symbols/JXG.GeometryElement.html#dash">documentation for dash attribute</a> 
tells us which are possible values.</p>
<p>All objects have attributes, also Board object has <a href="https://jsxgraph.uni-bayreuth.de/docs/symbols/JXG.Board.html">them</a>. 
One of the attributes is <em>boundingbox</em>, which we used from first example, but didn't talk about it until now. 
E.g. if you don't like the navigation (bottom right), then you can add attribute <em>showNavigation</em> and set it to false. Try it!</p>
<p><em><em>We can see that we can use attributes to fine tune on how our construction will behave and look.</em></em></p>
<p><strong>Documentation is a great resource for discovering attributes and also has some
examples of their usage.</strong>
{/lang}</p>
<p>{lang=CZ}
V tomto příkladu jsme přidali některé atributy jak k bodům, tak i k přímce.
Ve všech třech případech jsme definovali vlastnosti objektů pomocí seznamu atributů uvedených v závorkách <code>{ }</code>.
Pro každý atribut musíme napsat jeho jméno a hodnotu. Jak již bylo uvedeno dříve, objekty mohou mít jak specifické atributy,
tak i atributy obecné, sdílené s více objekty. </p>
<p>V kódu <code>var p = board.create('point',[-2,-1],{name:&quot;first&quot;, size:5, color:&quot;FF0000&quot;});</code> 
je prvním atributem jméno objektu <em>name</em>, které je společné třídě <a href="https://jsxgraph.uni-bayreuth.de/docs/symbols/JXG.GeometryElement.html#name">GeometryElement</a>, 
atribut barvy <em>color</em> je také společný, zatímco atribut velikosti <a href="https://jsxgraph.uni-bayreuth.de/docs/symbols/Point.html#size"><em>size</em></a> 
není obecný, ale je typický pro objekt <em>Point</em> (bod).
V dokumentaci se dočteme: <em>Velikost bodu, buď v pixelech nebo v jednotkách určených uživatelem. Znamená poloměr nebo polovinu
šířky bodu (v závislosti na jeho vzhledu).</em></p>
<p>Kód <code>var q = board.create('point',[3,1],{name:&quot;last&quot;,fixed:true, face:&quot;[]&quot;});</code> definující druhý bod 
obsahuje další zajímavé atributy. První z nich je atribut <em>fixed</em>, který určuje, zda může být objekt přemisťován (tažen) 
po nákresně. <em>Nastavená</em> (<em>Default</em>) hodnota pro tento atribut je <em>false</em>, což znamená, že pokud objekty nejsou explicitně fixovány,
můžeme s nimi hýbat po nákresně. <em>Nastavená hodnota</em> (<em>default value</em>) je použita vždy, když není pro daný atribut explicitně zadána jiná hodnota. 
V dokumentaci jsou uvedeny nastavené hodnoty pro všechny atributy. Druhým novým atributem v uvedeném kódu je
<a href="https://jsxgraph.uni-bayreuth.de/docs/symbols/Point.html#face"><em>face</em></a>, kterým nastavíme jeden z možných tvarů bodu. </p>
<p>V kódu <code>var line2 = board.create(&quot;line&quot;,[p,q],{straightLast:false, dash:&quot;4&quot; });</code> definice přímky byly použity dva
atributy, první z nich <em>straightLast</em> určuje, že přímka skončí ve druhém z určujících bodů, druhý <em>dash</em> potom určuje, jak bude čára nakreslena.
Parametr <em>dash</em> může nabývat různých hodnot, jejich přehled viz <a href="https://jsxgraph.uni-bayreuth.de/docs/symbols/JXG.GeometryElement.html#dash">dokumentace pro atribut &quot;dash&quot;</a>.</p>
<p>Tak jako v3echny objekty i nákresna (<em>Board</em>) má své <a href="https://jsxgraph.uni-bayreuth.de/docs/symbols/JXG.Board.html">atributy</a>. 
Jedním z nich je <em>boundingbox</em>, který používáme již od první ukázky kódu nákresny, ale ještě jsme ho nekomentovali. 
Dalším atributem nákresny je <em>showNavigation</em>, který nám dovoluje skrýt navigační tlačítka v pravém dolním rohu nákresny,
pokud mu nastavíme hodnotu <em>false</em>. Vyzkoušejte to!</p>
<p><em><em>Vidíme, že pomocí nastavení hodnot atributů můžeme vyladit chování i vzhled naší konstrukce.</em></em></p>
<p><strong>Dokumentace je velkým zdrojem pro poznání všech atributů, které můžeme použít. Obsahuje také konkrétní příklady jejich použití.</strong>
{/lang}</p>
<p>{lang=EN}</p>
<h2><a class="header" href="#example" id="example">Example</a></h2>
<p><strong>Harmonic conjugate points.</strong> Given three collinear points <em>A</em>, <em>B</em> and <em>C</em>; <em>C</em> being outside the line segment <em>AB</em>.
Determine the point <em>D</em> of the segment <em>AB</em> so that the ratio of its distances to <em>A</em> and <em>B</em>, respectively, is equal to the 
ratio of distances of the point <em>C</em> to points <em>A</em> and <em>B</em>, respectively, i.e. <em>|AD|/|BD|=|AC|/|BC|</em>. </p>
<p>This point <em>D</em> is called the <em>harmonic conjugate of C with respect to A and B</em> and points <em>A</em>, <em>B</em>, <em>C</em> and <em>D</em> together 
form the so called <em>harmonic quadruple</em>.
{/lang}</p>
<p>{lang=CZ}</p>
<h2><a class="header" href="#příklad" id="příklad">Příklad</a></h2>
<p><strong>Harmonická čtveřice bodů.</strong> Jsou dány tři kolineární body <em>A</em>, <em>B</em> a <em>C</em>; <em>C</em> leží vně úsečky <em>AB</em>.
Určete bod <em>D</em> úsečky <em>AB</em> takový, že poměr jeho vzdáleností od bodů <em>A</em> a <em>B</em>, v daném pořadí, je roven poměru
vzdáleností bodu <em>C</em> od bodů <em>A</em> a <em>B</em>, tj. <em>|AD|/|BD|=|AC|/|BC|</em>. </p>
<p>Bod <em>D</em> potom nazýváme <em>harmonicky sdružený s bodem C vzhledem k bodům A a B</em>, takové body <em>A</em>, <em>B</em>, <em>C</em> a <em>D</em> potom společně
vytváří tzv. <em>harmonickou čtveřici</em>.
{/lang}</p>
<p>{lang=SI}</p>
<h2><a class="header" href="#example-1" id="example-1">Example</a></h2>
<p><strong>Harmonic conjugate points.</strong> Given three collinear points <em>A</em>, <em>B</em> and <em>C</em>; <em>C</em> being outside the line segment <em>AB</em>.
Determine the point <em>D</em> of the segment <em>AB</em> so that the ratio of its distances to <em>A</em> and <em>B</em>, respectively, is equal to the 
ratio of distances of the point <em>C</em> to points <em>A</em> and <em>B</em>, respectively, i.e. <em>|AD|/|BD|=|AC|/|BC|</em>. </p>
<p>This point <em>D</em> is called the <em>harmonic conjugate of C with respect to A and B</em> and points <em>A</em>, <em>B</em>, <em>C</em> and <em>D</em> together 
form the so called <em>harmonic quadruple</em>.
{/lang}</p>
<p>{lang=EN}
<em>Result:</em>
To solve the task, we construct the so called <a href="https://en.wikipedia.org/wiki/Complete_quadrangle">complete quadrangle</a>,
as shown below.
{/lang}</p>
<p>{lang=CZ}
<em>Výsledek:</em>
K řešení úlohy využijeme konstrukci tzv. <a href="https://en.wikipedia.org/wiki/Complete_quadrangle">úplného čtyřrohu</a>,
jak vidíme níže.
{/lang}</p>
<p>{lang=SI}
<em>Result:</em>
To solve the task, we construct the so called <a href="https://en.wikipedia.org/wiki/Complete_quadrangle">complete quadrangle</a>,
as shown below.
{/lang}</p>
<div id="jxgbox" class="jxgbox" style="width:500px; height:400px;"></div>
<script>
 var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-5, 5, 5, -3]});
 var A = board.create('point',[-4,-2]);
 var B = board.create('point',[0,-2]);
 var p = board.create('line',[A,B],{name: 'p',withLabel: true, color: 'green'});
 var C = board.create('glider', [4, 0, p]);
 var E = board.create('point', [1,4], {name: 'E',size:2, color: 'blue'});
 var q = board.create('line',[A,E],{name: 'q',withLabel: true, color: 'green'});
 var r = board.create('line',[B,E],{name: 'r',withLabel: true, color: 'green'});
 var F = board.create('glider', [0,0,q], {name: 'F',size:2, color: 'blue'});
 var s = board.create('line',[C,F],{name: 's',withLabel: true, color: 'green'});
 var G = board.create('intersection', [s, r,0], {name: 'G',size:2, color: 'blue'});
 var t = board.create('line',[A,G],{color: 'grey', dash:"2"});
 var u = board.create('line',[B,F],{color: 'grey', dash:"2"});
 var H = board.create('intersection', [t, u], {name: 'H',size:2, color: 'blue'});
 var v = board.create('line', [E,H],{color: 'grey', dash:"2"});
 var D = board.create('intersection', [p, v, 0]);
</script>
<p>{lang=EN}
<em>Programming:</em></p>
<p>First, we define the bounding box and create two points <em>A</em> and <em>B</em> with the line <em>p</em> passing through them:
{/lang}</p>
<p>{lang=CZ}
<em>Programování:</em></p>
<p>Nejprve definujeme parametry nákresny, tj. rozměry okna a rozsah souřadnic, a v ní sestrojíme body <em>A</em> a <em>B</em> 
spolu s přímkou <em>p</em>, která jimi prochází:
{/lang}</p>
<p>{lang=SI}
<em>Programming:</em></p>
<p>First, we define the bounding box and create two points <em>A</em> and <em>B</em> with the line <em>p</em> passing through them:
{/lang}</p>
<pre><code class="language-JS">&lt;div id=&quot;jxgbox&quot; class=&quot;jxgbox&quot; style=&quot;width:500px; height:400px;&quot;&gt;&lt;/div&gt;
&lt;script&gt;
 var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-5, 5, 5, -3]});
 var A = board.create('point',[-4,-2]);
 var B = board.create('point',[0,-2]);
 var p = board.create('line',[A,B],{name: 'p',withLabel: true, color: 'green'});
&lt;/script&gt; 
</code></pre>
<p>{lang=EN}
Then, we put the point <em>C</em> on <em>p</em> so that it can move along it:
{/lang}</p>
<p>{lang=CZ}
Potom na přímku <em>p</em> umístíme bod <em>C</em> tak, aby byl po ní volně pohyblivý:
{/lang}</p>
<p>{lang=SI}
Then, we put the point <em>C</em> on <em>p</em> so that it can move along it:
{/lang}</p>
<pre><code class="language-JS">&lt;div id=&quot;jxgbox&quot; class=&quot;jxgbox&quot; style=&quot;width:500px; height:400px;&quot;&gt;&lt;/div&gt;
&lt;script&gt;
 var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-5, 5, 5, -3]});
 var A = board.create('point',[-4,-2]);
 var B = board.create('point',[0,-2]);
 var p = board.create('line',[A,B],{name: 'p',withLabel: true, color: 'green'});
 var C = board.create('glider', [4, 0, p]);
&lt;/script&gt; 
</code></pre>
<p>{lang=EN}
Now, we put the fourth point <em>E</em> above the line <em>p</em> and connect it by the straight lines <em>q</em> and <em>r</em> to points
<em>A</em> and <em>B</em>, respectively:
{/lang}</p>
<p>{lang=CZ}
Nyní umístíme čtvrtý bod <em>E</em> nad přímku <em>p</em> a přímkami <em>q</em> a <em>r</em> ho spojíme v daném pořadí postupně s body
<em>A</em> a <em>B</em>:
{/lang}</p>
<p>{lang=SI}
Now, we put the fourth point <em>E</em> above the line <em>p</em> and connect it by the straight lines <em>q</em> and <em>r</em> to points
<em>A</em> and <em>B</em>, respectively:
{/lang}</p>
<pre><code class="language-JS">&lt;div id=&quot;jxgbox&quot; class=&quot;jxgbox&quot; style=&quot;width:500px; height:400px;&quot;&gt;&lt;/div&gt;
&lt;script&gt;
 var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-5, 5, 5, -3]});
 var A = board.create('point',[-4,-2]);
 var B = board.create('point',[0,-2]);
 var p = board.create('line',[A,B],{name: 'p',withLabel: true, color: 'green'});
 var C = board.create('glider', [4, 0, p]);
 var E = board.create('point', [1,4], {name: 'E',size:2, color: 'blue'});
 var q = board.create('line',[A,E],{name: 'q',withLabel: true, color: 'green'});
 var r = board.create('line',[B,E],{name: 'r',withLabel: true, color: 'green'});
&lt;/script&gt; 
</code></pre>
<p>{lang=EN}
After this, we put the point <em>F</em> on <em>r</em>, somewhere between <em>A</em> and <em>E</em>, draw a line <em>s</em> passing through
points <em>C</em> and <em>F</em> and determine its intersection <em>G</em> with the line <em>r</em>:
{/lang}</p>
<p>{lang=CZ}
Poté umístíme na přímku <em>r</em> bod <em>F</em>, někam mezi body <em>A</em> a <em>E</em>, sestrojíme přímku <em>s</em> procházející body <em>C</em> a <em>F</em> 
a určíme jejich průsečík <em>G</em> s přímkou <em>r</em>:
{/lang}</p>
<p>{lang=SI}
After this, we put the point <em>F</em> on <em>r</em>, somewhere between <em>A</em> and <em>E</em>, draw a line <em>s</em> passing through
points <em>C</em> and <em>F</em> and determine its intersection <em>G</em> with the line <em>r</em>:
{/lang}</p>
<pre><code class="language-JS">&lt;div id=&quot;jxgbox&quot; class=&quot;jxgbox&quot; style=&quot;width:500px; height:400px;&quot;&gt;&lt;/div&gt;
&lt;script&gt;
 var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-5, 5, 5, -3]});
 var A = board.create('point',[-4,-2]);
 var B = board.create('point',[0,-2]);
 var p = board.create('line',[A,B],{name: 'p',withLabel: true, color: 'green'});
 var C = board.create('glider', [4, 0, p]);
 var E = board.create('point', [1,4], {name: 'E',size:2, color: 'blue'});
 var q = board.create('line',[A,E],{name: 'q',withLabel: true, color: 'green'});
 var r = board.create('line',[B,E],{name: 'r',withLabel: true, color: 'green'});
 var F = board.create('glider', [0,0,q], {name: 'F',size:2, color: 'blue'});
 var s = board.create('line',[C,F],{name: 's',withLabel: true, color: 'green'});
 var G = board.create('intersection', [s, r,0], {name: 'G',size:2, color: 'blue'});
&lt;/script&gt; 
</code></pre>
<p>{lang=EN}
Finally, we draw lines <em>t=AG</em> and <em>u=BF</em>, denote <em>H</em> their point of intersection, construct
the line <em>v</em> passing points <em>H</em> and <em>E</em> and determine the desired point <em>D</em> as the intersection of lines <em>v</em> and <em>p</em>:
{/lang}</p>
<p>{lang=CZ}
Nakonec sestrojíme přímky <em>t=AG</em> a <em>u=BF</em>, určíme a označíme <em>H</em> jejich průsečík, sestrojíme přímku <em>v</em>
procházející body <em>H</em> a <em>E</em> a určíme hledaný bod <em>D</em> jako průsečík přímek <em>v</em> a <em>p</em>:
{/lang}</p>
<p>{lang=SI}
Finally, we draw lines <em>t=AG</em> and <em>u=BF</em>, denote <em>H</em> their point of intersection, construct
the line <em>v</em> passing points <em>H</em> and <em>E</em> and determine the desired point <em>D</em> as the intersection of lines <em>v</em> and <em>p</em>:
{/lang}</p>
<pre><code class="language-JS">&lt;div id=&quot;jxgbox&quot; class=&quot;jxgbox&quot; style=&quot;width:500px; height:400px;&quot;&gt;&lt;/div&gt;
&lt;script&gt;
 var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-5, 5, 5, -3]});
 var A = board.create('point',[-4,-2]);
 var B = board.create('point',[0,-2]);
 var p = board.create('line',[A,B],{name: 'p',withLabel: true, color: 'green'});
 var C = board.create('glider', [4, 0, p]);
 var E = board.create('point', [1,4], {name: 'E',size:2, color: 'blue'});
 var q = board.create('line',[A,E],{name: 'q',withLabel: true, color: 'green'});
 var r = board.create('line',[B,E],{name: 'r',withLabel: true, color: 'green'});
 var F = board.create('glider', [0,0,q], {name: 'F',size:2, color: 'blue'});
 var s = board.create('line',[C,F],{name: 's',withLabel: true, color: 'green'});
 var G = board.create('intersection', [s, r,0], {name: 'G',size:2, color: 'blue'});
 var t = board.create('line',[A,G],{color: 'grey', dash:&quot;2&quot;});
 var u = board.create('line',[B,F],{color: 'grey', dash:&quot;2&quot;});
 var H = board.create('intersection', [t, u], {name: 'H',size:2, color: 'blue'});
 var v = board.create('line', [E,H],{color: 'grey', dash:&quot;2&quot;});
 var D = board.create('intersection', [p, v, 0]);
&lt;/script&gt;
</code></pre>
<p>{lang=EN}</p>
<h2><a class="header" href="#circles" id="circles">Circles</a></h2>
<p>In JSXGraph we don't have only points and lines. In this section we will learn about circles. They can be constructed 
with different <a href="https://jsxgraph.uni-bayreuth.de/docs/symbols/JXG.Circle.html#method">methods</a>, here we will present how to
create with two points and a point and a radius. 
Let us now look at the example.
{/lang}</p>
<p>{lang=SI}##Circles{/lang}</p>
<p>{lang=CZ}</p>
<h2><a class="header" href="#kružnice" id="kružnice">Kružnice</a></h2>
<p>V JSXGraphu nemáme k dispozici jenom body a přímky. Jsou zde definovány ještě další objekty, se kterými se postupně seznámíme.
Tato kapitola pojednává o kružnicích. Ty mohou být sestrojeny různými <a href="https://jsxgraph.uni-bayreuth.de/docs/symbols/JXG.Circle.html#method">metodami</a>. 
Zaměříme se na dvě z nich, konstrukci kružnice dané dvěma body a konstrukci kružnice dané bodem a poloměrem.
Podívejme se na následující příklad:
{/lang}</p>
<pre><code class="language-JS">&lt;div id=&quot;jxgbox&quot; class=&quot;jxgbox&quot; style=&quot;width:500px; height:200px;&quot;&gt;&lt;/div&gt;
&lt;script&gt;
 var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-5, 2, 5, -2],
     keepAspectRatio:true});

 var p = board.create('point',[-1,-1],{name:&quot;A&quot;});
 var q = board.create('point',[0,0],{name:&quot;B&quot;});

 var circle1 = board.create(&quot;circle&quot;,[p,q],{strokeColor:&quot;red&quot;, strokeWidth:4});
 var circle2 = board.create(&quot;circle&quot;,[&quot;B&quot;,1.8],{method:&quot;pointRadius&quot;, fillColor:&quot;gray&quot;, 
     fillOpacity:0.2});
&lt;/script&gt;
</code></pre>
<div id="jxgbox" class="jxgbox" style="width:500px; height:200px;"></div>
<script>
 var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-5, 2, 5, -2],keepAspectRatio:true});
 var p = board.create('point',[-1,-1],{name:"A"});
 var q = board.create('point',[0,0],{name:"B"});
 var circle1 = board.create("circle",[p,q],{strokeColor:"red", strokeWidth:4});
 var circle2 = board.create("circle",["B",1.8],{method:"pointRadius", fillColor:"gray", fillOpacity:0.2});
</script>
<p>{lang=EN}
First what we notice is, that when we initialized the board with a new argument <code>keepAspectRatio:true</code> which we use
to tell JSXGraph that we want that html object and drawing board keep the aspect ratio between $x$ and $y$ axis. Setting this to
true is necessary if circles should look like circles and not like ellipses. </p>
<p>After creating both points we create two circles. <em>Circle1</em> is created with <code>var circle1 = board.create(&quot;circle&quot;,[p,q],{strokecolor:&quot;red&quot;, strokeWidth:4});</code>.
We can see, that here we created circle with two points which is default method for creating the circles. We used 
two additional attributes which we used to set the color and width of the stroke. Color here was not defined with 
RGB system, but with the color name (REF needed). </p>
<p><em>Circle2</em> is more interesting <code>var circle2 = board.create(&quot;circle&quot;,[&quot;B&quot;,1.5],{method:&quot;pointRadius&quot;, fillcolor:&quot;gray&quot;, fillopacity:0.2});</code>
since we created it with the point and radius method. We explicitly set this as a attribute.
Also instead of using variable name for the point, we used name of the point <code>&quot;B&quot;</code>, which can be very useful when having 
many objects in the construction (and generating objects dynamically). We also used two attributes for filling the area of circle,
namely <em>fillColor</em> which defines the color of the fill and <em>fillOpacity</em> sets the opacity of the area (ranging from $0$ to $1$, where $1$ means solid color with no opacity).
{/lang}</p>
<p>{lang=SI}
First what we notice is, that when we initialized the board with a new argument <code>keepAspectRatio:true</code> which we use
to tell JSXGraph that we want that html object and drawing board keep the aspect ratio between $x$ and $y$ axis. Setting this to
true is necessary if circles should look like circles and not like ellipses. </p>
<p>After creating both points we create two circles. <em>Circle1</em> is created with <code>var circle1 = board.create(&quot;circle&quot;,[p,q],{strokecolor:&quot;red&quot;, strokeWidth:4});</code>.
We can see, that here we created circle with two points which is default method for creating the circles. We used 
two additional attributes which we used to set the color and width of the stroke. Color here was not defined with 
RGB system, but with the color name (REF needed). </p>
<p><em>Circle2</em> is more interesting <code>var circle2 = board.create(&quot;circle&quot;,[&quot;B&quot;,1.5],{method:&quot;pointRadius&quot;, fillcolor:&quot;gray&quot;, fillopacity:0.2});</code>
since we created it with the point and radius method. We explicitly set this as a attribute.
Also instead of using variable name for the point, we used name of the point <code>&quot;B&quot;</code>, which can be very useful when having 
many objects in the construction (and generating objects dynamically). We also used two attributes for filling the area of circle,
namely <em>fillColor</em> which defines the color of the fill and <em>fillOpacity</em> sets the opacity of the area (ranging from $0$ to $1$, where $1$ means solid color with no opacity).
{/lang}</p>
<p>{lang=CZ}
Především je třeba zmínit, že jsme v příkazu pro inicializaci nákresny použili nový atribut <code>keepAspectRatio:true</code>, kterým
dáváme JSXGraphu pokyn, aby byl zachován poměr stran nákresny odpovídající rozsahům hodnot na osách $x$ a $y$.
Nastavení hodnoty <em>true</em> je nezbytné pro to, aby kružnice vypadaly v nákresně skutečně jako kružnice a ne jako elipsy. </p>
<p>Nyní k vlastní konstrukci kružnice. Kružnice <em>Circle1</em> je definována kódem <code>var circle1 = board.create(&quot;circle&quot;,[p,q],{strokecolor:&quot;red&quot;, strokeWidth:4});</code>,
kde <em>p</em>, <em>q</em> jsou dva body, které jí určují, <em>p</em> je střed kružnice a <em>q</em> je bod, kterým kružnice prochází. V definici jsou užity dva 
atributy pro barvu a tloušťku čáry. Barva přitom není definována systémem RGB, ale jménem barvy (je potřeba REF). </p>
<p>Kružnice <em>Circle2</em> je zajímavější, protože je dána středem a poloměrem. Definujeme ji kódem
<code>var circle2 = board.create(&quot;circle&quot;,[&quot;B&quot;,1.5],{method:&quot;pointRadius&quot;, fillcolor:&quot;gray&quot;, fillopacity:0.2});</code>
Tato metoda konstrukce kružnice musí být zadána explicitně formou atributu, na rozdíl od té předchozí, která je v JSXGraphu implicitní.
Také stojí za povšimnutí, že jsme v tomto kódu nepoužili jméno proměnné <em>q</em>, do které je bod uložen, ale přímo jméno &quot;B&quot; tohoto bodu.
Což může být velmi užitečné, když máme v konstrukci více objektů a když jsou objekty generovány dynamicky. </p>
<p>Použili jsme dva atributy pro vyplnění vnitřku kružnice (vytvoření kruhu), konkrétně <em>fillColor</em>, který definuje barvu
výplně a <em>fillOpacity</em>, kterým nastavíme neprůhlednost této plochy (kruhu) 
(nabývá hodnot od $0$ do $1$, kde $1$ znamená jednobarevnou výplň bez průhlednosti).
{/lang}</p>
<p>{lang=EN}</p>
<h2><a class="header" href="#polygons" id="polygons">Polygons</a></h2>
<p>Polygons are very useful objects which can be used to construct a closed area with arbitrary many points (minimum is three). 
Polygons can be convex or concave, depending on the input points. We can again define different <a href="https://jsxgraph.uni-bayreuth.de/docs/symbols/Polygon.html">attributes</a>
to the object.</p>
<p>Example:
{/lang}</p>
<p>{lang=SI}</p>
<h2><a class="header" href="#polygons-1" id="polygons-1">Polygons</a></h2>
<p>{/lang}</p>
<p>{lang=CZ}</p>
<h2><a class="header" href="#mnohoúhelníky" id="mnohoúhelníky">Mnohoúhelníky</a></h2>
<p>Mnohoúhelníky jsou v geometrii velmi frekventované objekty. Můžeme je chápat jako části roviny ohraničené uzavřenou 
lomenou čarou s libovolným počtem vrcholů (minimum jsou tři). Mnohoúhelník může být <em>konvexní</em> nebo <em>konkávní</em> (říkáme též <em>nekonvexní</em>), 
v závislosti na rozložení určujících bodů (vrcholů). Stejně jako jiným objektům i mnohoúhelníkům můžeme přiřadit různé 
<a href="https://jsxgraph.uni-bayreuth.de/docs/symbols/Polygon.html">atributy</a>.</p>
<p>Příklad:
{/lang}</p>
<pre><code class="language-JS">&lt;div id=&quot;jxgbox&quot; class=&quot;jxgbox&quot; style=&quot;width:500px; height:200px;&quot;&gt;&lt;/div&gt;
&lt;script&gt;
 var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-5, 2, 5, -2],
     keepAspectRatio:true, showCopyright:false, showNavigation:false });

 var p = board.create('point',[-2,0],{name:&quot;A&quot;});
 var q = board.create('point',[-1,-1],{name:&quot;B&quot;});
 var r = board.create('point',[1,-0.5],{name:&quot;C&quot;});
 var s = board.create('point',[1,1],{name:&quot;D&quot;});
 var t = board.create('point',[-1,1.5],{name:&quot;E&quot;});

 var poly1 = board.create('polygon',[p,q,r,s,t],{name:&quot;Polygon 1&quot;,withLabel:true});

 var points = [[2,-1],[4,1],[1,1],[-1,-1]];
 var poly2 = board.create('polygon',points,{name:&quot;Polygon 2&quot;,withLabel:true,
     hasInnerPoints:true, withLines:false, vertices:{visible:false}});
&lt;/script&gt;
</code></pre>
<div id="jxgbox" class="jxgbox" style="width:500px; height:200px;"></div>
<script>
 var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-5, 2, 5, -2],keepAspectRatio:true, showCopyright:false, showNavigation:false });
 var p = board.create('point',[-2,0],{name:"A"});
 var q = board.create('point',[-1,-1],{name:"B"});
 var r = board.create('point',[1,-0.5],{name:"C"});
 var s = board.create('point',[1,1],{name:"D"});
 var t = board.create('point',[-1,1.5],{name:"E"});
 var poly1 = board.create('polygon',[p,q,r,s,t],{name:"Polygon 1",withLabel:true});
 var points = [[2,-1],[4,1],[1,1],[-1,-1]];
 var poly2 = board.create('polygon',points,{name:"Polygon 2",withLabel:true,hasInnerPoints:true, withLines:false, vertices:{visible:false}});
</script>
<p>{lang=EN}
As we mentioned earlier we need at least three points to make a polygon. In our example we created five points which then used
to create a polygon. We used an attribute <em>withLabel</em> which tells JSXGraph to show the name of the polygon. </p>
<p>For the second polygon we created a list of points, which is another approach to create a polygon. Here we again few new 
attributes. Attribute <em>hasInnerPoints</em> enables user to move entire polygon. For example, moving Polygon 1 is not possible,
only its points can be moved. Adding this attribute will enable moving the polygon. 
Next attribute, <em>withLines</em> tells JSXgraph whether to draw borders of the polygon or not. The last attribute <em>vertices</em> is
particullary interesting, because it does not have just a value, but a dictionary on the right side of <code>:</code>. The reason behind
is that we can control the vertices with more than one attribute.
{/lang}</p>
<p>{lang=SI}
As we mentioned earlier we need at least three points to make a polygon. In our example we created five points which then used
to create a polygon. We used an attribute <em>withLabel</em> which tells JSXGraph to show the name of the polygon. </p>
<p>For the second polygon we created a list of points, which is another approach to create a polygon. Here we again few new 
attributes. Attribute <em>hasInnerPoints</em> enables user to move entire polygon. For example, moving Polygon 1 is not possible,
only its points can be moved. Adding this attribute will enable moving the polygon. 
Next attribute, <em>withLines</em> tells JSXgraph whether to draw borders of the polygon or not. The last attribute <em>vertices</em> is
particullary interesting, because it does not have just a value, but a dictionary on the right side of <code>:</code>. The reason behind
is that we can control the vertices with more than one attribute.
{/lang}</p>
<p>{lang=CZ}
Jak je zřejmé z geometrické podstaty mnohoúhelníku, pro jeho vytvoření potřebujeme alespoň tři body. 
V uvedeném příkladě jsme vytvořili pět bodů, které jsme pojmenovali <em>A</em>, <em>B</em>, <em>C</em>, <em>D</em>, <em>E</em> a použili jsme je 
k určení prvního mnohoúhelníku, pětiúhelníku <em>ABCDE</em>. V jeho definici jsme použili atribut <em>withLabel</em> s hodnotou <em>true</em>, kterým
jsme zajistili zobrazení jména pětiúhelníku <em>Polygon 1</em>. </p>
<p>K určení druhého mnohoúhelníku, tentokrát se jedná o čtyřúhelník, jsme použili předem vytvořenou posloupnost vrcholů, což je 
další přístup k definování mnohoúhelníku v JSXGraphu. V definici jsme použili několik dalších nových atributů. </p>
<p>Atribut <em>hasInnerPoints</em> přináší možnost pohybovat v nákresně s celým mnohoúhelníkem. Srovnejme s pětiúhelníkem <em>ABCDE</em> (<em>Polygon 1</em>),
který nemůžeme celý přemístit, můžeme pohybovat pouze s jeho jednotlivými vrcholy.</p>
<p>Další atribut, <em>withLines</em> je zodpovědný za to, zda se bude (implicitní nastavení, při použití atributu <em>withLines</em> hodnota <em>true</em>) 
nebo nebude (atribut <em>withLines</em> s hodnotou <em>false</em>) kreslit hranice mnohoúhelníku.</p>
<p>Poslední atribut <em>vertices</em>, který se týká vrcholů mnohoúhelníku, je zajímavý tím, že mu za dvojtečkou <code>:</code> není přiřazena 
jedna hodnota, ale seznam dalších atributů s jejich hodnotami. Důvodem je skutečnost, že výskyt vrcholů může být ovládán více atributy.
{/lang}</p>
<p>{lang=EN}</p>
<h2><a class="header" href="#intersections" id="intersections">Intersections</a></h2>
<p>Sometimes we want to distinguish some intersections of our objects ( lines and circles). Usually we have to compute the
intersections, but JSXGraph has very convenient objects <a href="https://jsxgraph.uni-bayreuth.de/docs/symbols/Intersection.html"><em>Intersection</em></a> 
which we can use, to do just that. In order to create an intersection, we need to use two lines, two circles or mix of them.
We cannot use other objects to create this object.
{/lang}</p>
<p>{lang=SI}</p>
<h2><a class="header" href="#intersections-1" id="intersections-1">Intersections</a></h2>
<p>{/lang}</p>
<p>{lang=CZ}</p>
<h2><a class="header" href="#průsečíky" id="průsečíky">Průsečíky</a></h2>
<p>Pro určení průsečíků přímek a kružnic můžeme v JSXGraphu použít přímo objekt 
<a href="https://jsxgraph.uni-bayreuth.de/docs/symbols/Intersection.html"><em>Intersection</em></a> (<em>průsečík</em>), nemusíme tyto průsečíky počítat. 
Pro jeho zadání potřebujeme dvě  přímky, dvě kružnice nebo jednu přímku a jednu kružnici. Jiné objekty pro určení jejich průsečíku
nelze použít.</p>
<p>{/lang}</p>
<pre><code class="language-JS">&lt;div id=&quot;jxgbox&quot; class=&quot;jxgbox&quot; style=&quot;width:500px; height:200px;&quot;&gt;&lt;/div&gt;
&lt;script&gt;
 var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-5, 2, 5, -2],keepAspectRatio:true, showCopyright:false, showNavigation:false });
 var p = board.create('point',[-2,0],{name:&quot;A&quot;});
 var q = board.create('point',[-1,-1],{name:&quot;B&quot;, visible:false});
 var r = board.create('point',[0,0],{name:&quot;C&quot;});
 var circle1 = board.create('circle', [p,q]);
 var circle2 = board.create('circle', [r,p]);
 var inter1 = board.create('intersection',[circle1,circle2,0],{name:'I_1'});
 var inter2 = board.create('intersection',[circle1,circle2,1],{name:'I_2'});
 var line = board.create('line',[inter1,inter2]);
&lt;/script&gt;
</code></pre>
<div id="jxgbox" class="jxgbox" style="width:500px; height:200px;"></div>
<script>
 var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-5, 2, 5, -2],keepAspectRatio:true, showCopyright:false, showNavigation:false });
 var p = board.create('point',[-2,0],{name:"A"});
 var q = board.create('point',[-1,-1],{name:"B", visible:false});
 var r = board.create('point',[0,0],{name:"C"});
 var circle1 = board.create('circle', [p,q]);
 var circle2 = board.create('circle', [r,p]);
 var inter1 = board.create('intersection',[circle1,circle2,0],{name:'I_1'});
 var inter2 = board.create('intersection',[circle1,circle2,1],{name:'I_2'});
 var line = board.create('line',[inter1,inter2]);
</script>
<p>{lang=EN}
After we created points and two circles, we created two objects - <em>intersections</em>. </p>
<p>In <code>var inter1 = board.create('intersection',[circle1,circle2,0],{name:'I_1'});</code> we used a third argument <code>0</code> which we use
in the case if there are two intersecting points and we decide which intersection we will use (with $0$ and $1$). 
Notice that in <code>{name:'I_2'})</code> we used underscore in the name. 
This is <a href="https://www.mathjax.org/">$LATEX$</a> notation and can be used for the labels to typeset beautiful math. </p>
<p>As last we created new line <code>var line = board.create('line',[inter1,inter2]);</code>
with the intersection objects. We can therefore use newly created objects as regular points in our constructions.
{/lang}</p>
<p>{lang=SI}</p>
<p>{/lang}</p>
<p>{lang=CZ}
Po vytvoření bodů a dvou kružnic jsme definovali dva objekty typu průsečík - <em>intersections</em>. </p>
<p>V kódu <code>var inter1 = board.create('intersection',[circle1,circle2,0],{name:'I_1'});</code> jsme použili za výčtem dvou kružnic třetí
argument, zde konkrétně s hodnotou <code>0</code>, který zadáváme v případě, že objekty mají dva průsečíky a my chceme ovlivnit, který
z nich použijeme (uvedením $0$ nebo $1$). 
Za povšimnutí stojí, že jsme v atributu <code>{name:'I_2'})</code> použili ve jménu symbol podtržítka pro zápis dolního indexu.
Jedná se o syntaxi typografického systému <a href="https://www.mathjax.org/">$LATEX$</a>, která může být v JSXGraphu použita při zápisu
jmenovek pro dosažení lépe vypadajícího matematického zápisu. </p>
<p>Nakonec jsme definovali novou přímku <code>var line = board.create('line',[inter1,inter2]);</code>
procházející získanými průsečíky. Z toho je vidět, jak můžeme nově získané objekty hned použít jako určující body pro další konstrukci.</p>
<p>{/lang}</p>
<p>{lang=EN}</p>
<h2><a class="header" href="#angles" id="angles">Angles</a></h2>
<p>When we need to emphasise some angle in our construction, we can do this with object <a href="https://jsxgraph.uni-bayreuth.de/docs/symbols/Angle.html"><em>Angle</em></a>. 
As an input we need to provide three points $p1, p2, p3$ and the angle is drawn counterclockwise from $p1$ to $p3$ around $p2$. 
Other combinations include two lines and a two direction (by +/- 1) or line and two coordinates.
{/lang}</p>
<p>{lang=SI}</p>
<h2><a class="header" href="#angles-1" id="angles-1">Angles</a></h2>
<p>{/lang}</p>
<p>{lang=CZ}</p>
<h2><a class="header" href="#Úhly" id="Úhly">Úhly</a></h2>
<p>Pro zvýraznění konkrétních úhlů v konstrukci nabízí JSXGraph objekt <a href="https://jsxgraph.uni-bayreuth.de/docs/symbols/Angle.html"><em>Angle</em></a> (<em>Úhel</em>). 
Jako vstupní údaje je třeba zadat tři body $p1, p2, p3$, úhel je pak vykreslen v kladném smyslu (tj. proti směru pohybu hodinových ručiček)
od bodu $p1$ (bod na počátečním rameni) do bodu $p3$ (bod na koncovém rameni), kolem $p2$ (vrchol). </p>
<p>Dalšími možnostmi zadání vstupních údajů pro zobrazení úhlu jsou <em>dvě přímky a dva směry (ve tvaru +/- 1)</em> nebo <em>dvě přímky a dva body</em> 
(kolmý průmět každého z těchto bodů na jemu příslušnou přímku, dle pořadí v zápisu, určuje polopřímku, která je ramenem úhlu).
{/lang}</p>
<pre><code class="language-JS">&lt;div id=&quot;jxgbox&quot; class=&quot;jxgbox&quot; style=&quot;width:500px; height:200px;&quot;&gt;&lt;/div&gt;
&lt;script&gt;
 var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-5, 2, 5, -2],keepAspectRatio:true, showCopyright:false, showNavigation:false });
 var p = board.create('point',[-2,0],{name:&quot;A&quot;});
 var q = board.create('point',[1,1.5],{name:&quot;B&quot;});
 var r = board.create('point',[1,-1],{name:&quot;C&quot;});
 var line1 = board.create('line',[p,q]);
 var line2 = board.create('line',[p,r]);
 var angle1 = board.create('angle',[&quot;C&quot;, &quot;A&quot;, &quot;B&quot;], {radius:2});
 var angle2 = board.create('angle',[line2,line1,-1,-1], {radius:1,color:'green'});
 var angle3 = board.create('angle',[line2,line1,1,1], {radius:1,color:'blue'});
&lt;/script&gt;
</code></pre>
<div id="jxgbox" class="jxgbox" style="width:500px; height:200px;"></div>
<script>
 var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-5, 2, 5, -2],keepAspectRatio:true, showCopyright:false, showNavigation:false });
 var p = board.create('point',[-2,0],{name:"A", fixed:true});
 var q = board.create('point',[1,1.5],{name:"B"});
 var r = board.create('point',[1,-1],{name:"C"});
 var line1 = board.create('line',[p,q]);
 var line2 = board.create('line',[p,r]);
 var angle1 = board.create('angle',["C", "A", "B"], {radius:2});
 var angle2 = board.create('angle',[line2,line1,-1,-1], {radius:1,color:'green'});
 var angle3 = board.create('angle',[line2,line1,1,1], {radius:1,color:'blue'});
</script>
<p>{lang=EN}</p>
<p>In this example we first created three points and then through them created two lines with common/intersection point $A$. </p>
<p>Then we created first angle with <code>var angle = board.create('angle',[r, p, q], {radius:2});</code> using three points. Remember, 
when defining angle with three points we have to provide them in counterclockwise order, where the angle is centered by the second point. Additionaly, we set an attribute
<em>radius</em> to $2$, which tells JSXGraph how big the arc of an angle should be. </p>
<p>Then the second angle $\beta$ was created using two lines and two directions (+/- 1) with following line
<code>var angle2 = board.create('angle',[line2,line1,-1,-1], {radius:1,color:'green'});</code>. This line presents another possible 
method to input the parameters of an angle. We can combine them differently to get different angles at the intersection point $A$.</p>
<p>Last angle is only a variation of <code>angle2</code> which different directions and as a result we can see that <code>angle1</code> and <code>angle3</code> 
describe the same angle but with different input parameters.
{/lang}</p>
<p>{lang=SI}
In this example we first created three points and then through them created two lines with common/intersection point $A$. </p>
<p>Then we created first angle with <code>var angle = board.create('angle',[r, p, q], {radius:2});</code> using three points. Remember, 
when defining angle with three points we have to provide them in counterclockwise order, where the angle is centered by the second point. Additionaly, we set an attribute
<em>radius</em> to $2$, which tells JSXGraph how big the arc of an angle should be. </p>
<p>Then the second angle $\beta$ was created using two lines and two directions (+/- 1) with following line
<code>var angle2 = board.create('angle',[line2,line1,-1,-1], {radius:1,color:'green'});</code>. This line presents another possible 
method to input the parameters of an angle. We can combine them differently to get different angles at the intersection point $A$.</p>
<p>Last angle is only a variation of <code>angle2</code> which different directions and as a result we can see that <code>angle1</code> and <code>angle3</code> 
describe the same angle but with different input parameters.</p>
<p>{/lang}</p>
<p>{lang=CZ}
Nejprve jsme vytvořili tři body <em>A</em>, <em>B</em>, <em>C</em> a jimi určené dvě přímky se společným bodem $A$. </p>
<p>První úhel (programem označený jako $\alpha$) jsme definovali pomocí těchto tří bodů. Zapsali jsme ho kódem  <code>var angle1 = board.create('angle',[&quot;C&quot;, &quot;A&quot;, &quot;B&quot;], {radius:2});</code>
K pořadí uvedení bodů připomeňme, že úhel zadáváme třemi body ve směru proti pohybu hodinových ručiček, 
přitom jako prostřední uvádíme vrchol úhlu. Nakonec jsme uvedli atribut poloměru oblouku úhlu <em>radius</em> s hodnotou $2$,
abychom JSXGraphu sdělili, jak velkým obloukem má úhel vykreslit. </p>
<p>Kódem <code>var angle2 = board.create('angle',[line2,line1,-1,-1], {radius:1,color:'green'});</code> byl vytvořen druhý úhel $\beta$, 
užitím dvou přímek a stanovením směrů (+/- 1) jeho ramen, která na těchto přímkách leží. 
Jedná se o další možnost zadání úhlu. Různými kombinacemi hodnot (+/- 1) směrů můžeme vyjádřit všechny možné 
úhly s vrcholem v $A$.</p>
<p>Poslední úhel $\gamma$ je pouhou variací předchozího úhlu $\beta$ (též <code>angle2</code>) získanou právě změnou směrů ramen. Vidíme tak,
že proměnné <code>angle1</code> a <code>angle3</code> popisují stejný úhel, avšak s použitím různých vstupních údajů.</p>
<p>{/lang}</p>
<p>{lang=EN}</p>
<h2><a class="header" href="#curves" id="curves">Curves</a></h2>
<p><a href="https://jsxgraph.uni-bayreuth.de/docs/symbols/Curve.html">Curves</a> in JSXgraph does not mean just curves from functions 
or polynomials, but also parametric curves, polar curves or data plots. In our example we will show how to use data 
for data plotting, for other uses please check API documentation.
{/lang}</p>
<p>{lang=SI}</p>
<h2><a class="header" href="#curves-1" id="curves-1">Curves</a></h2>
<p>{/lang}</p>
<p>{lang=CZ}</p>
<h2><a class="header" href="#křivky" id="křivky">Křivky</a></h2>
<p>Objekt <em>křivka</em> (<a href="https://jsxgraph.uni-bayreuth.de/docs/symbols/Curve.html">Curve</a>) v JSXgraphu nezahrnuje jenom
grafy funkcí nebo polynomů, ale také parametrické křivky, křivky definované v polárních souřadnicích nebo různé grafické
reprezentace dat. Následujícím příkladem ilustrujeme užití objektu <em>Curve</em> ke grafické reprezentaci dat. Další možnosti 
tohoto objektu viz <a href="https://jsxgraph.uni-bayreuth.de/docs/symbols/Curve.html">JSXGraph Reference</a>.
{/lang}</p>
<pre><code class="language-JS">&lt;div id=&quot;jxgbox&quot; class=&quot;jxgbox&quot; style=&quot;width:500px; height:200px;&quot;&gt;&lt;/div&gt;
&lt;script&gt;
 var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-1, 10, 11, -2], 
			axis:true, showCopyright:false, showNavigation:false });
 var x = [1,2,3,4,5,6,7,8,9,10];
 var y = [8.4,1,0.1,9,3.3,3.3,4.5,8,9,4];
 var curve = board.create('curve',[x,y],{curveType:'plot'});
&lt;/script&gt;
</code></pre>
<div id="jxgbox" class="jxgbox" style="width:500px; height:200px;"></div>
<script>
 var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-1, 10, 11, -2], axis:true, showCopyright:false, showNavigation:false });
 var x = [1,2,3,4,5,6,7,8,9,10];
 var y = [8.4,1,0.1,9,3.3,3.3,4.5,8,9,4];
 var curve = board.create('curve',[x,y],{curveType:'plot'});
</script>
<p>{lang=EN}
In this example we had to change the bounding box of the board in order to accommodate the data. Otherwise not all points 
will be visible.</p>
<p>To draw a data plot we need first two lists of data. In our case we used two lists <code>x</code> and <code>y</code> and filled them with numbers. 
But is not the only way how to obtain the data (e.g. see this <a href="https://jsxgraph.uni-bayreuth.de/wiki/index.php/Data_plot">example</a>).
As last we had to set the type of curve using attribute <a href="https://jsxgraph.uni-bayreuth.de/docs/symbols/Curve.html#curveType"><em>curveType</em></a>.
{/lang}</p>
<p>{lang=SI}
In this example we had to change the bounding box of the board in order to accommodate the data. Otherwise not all points 
will be visible.</p>
<p>To draw a data plot we need first two lists of data. In our case we used two lists <code>x</code> and <code>y</code> and filled them with numbers. 
But is not the only way how to obtain the data (e.g. see this <a href="https://jsxgraph.uni-bayreuth.de/wiki/index.php/Data_plot">example</a>).
As last we had to set the type of curve using attribute <a href="https://jsxgraph.uni-bayreuth.de/docs/symbols/Curve.html#curveType"><em>curveType</em></a>.
{/lang}</p>
<p>{lang=CZ}
V tomto příkladu jsme především upravili nastavení nákresny, aby více odpovídala potřebám zobrazení daných dat. Kromě změny
rozsahu souřadnic, aby byly vidět všechny body, jsme mimo jiné atributem <em>axis</em> s hodnotou <em>true</em> zajistili zobrazení souřadnicových os.</p>
<p>Pro grafické zobrazení dat potřebujeme dva datové seznamy. V uvedeném příkladě jsou použity seznamy <code>x</code> a <code>y</code>, vyplněné čísly. 
To ale není jediný způsob zadání dat (viz např. tento <a href="https://jsxgraph.uni-bayreuth.de/wiki/index.php/Data_plot">příklad</a>).</p>
<p>Způsob zobrazení křivky je nastaven pomocí atributu <a href="https://jsxgraph.uni-bayreuth.de/docs/symbols/Curve.html#curveType"><em>curveType</em></a>.
{/lang}</p>
<p>{lang=EN}</p>
<h2><a class="header" href="#drawing-mathematical-functions" id="drawing-mathematical-functions">Drawing mathematical functions</a></h2>
<p>In the constructions we often need to draw mathematical functions, e.g. sine or cosine, polynomals or other known functions.
JSXGraph provide convenient method to draw such functions. Lets look at the example.
{/lang}</p>
<p>{lang=SI}</p>
<h2><a class="header" href="#functions-drawing" id="functions-drawing">Functions drawing</a></h2>
<p>{/lang}</p>
<p>{lang=CZ}</p>
<h2><a class="header" href="#zobrazení-grafu-funkce" id="zobrazení-grafu-funkce">Zobrazení grafu funkce</a></h2>
<p>JSXGraph poskytuje pohodlný způsob zobrazování grafů funkcí, např. sinu, kosinu, algebraických funkcí, ale i dalších známých funkcí.</p>
<p>{/lang}</p>
<pre><code class="language-JS">&lt;div id=&quot;jxgbox&quot; class=&quot;jxgbox&quot; style=&quot;width:300px; height:300px; margin:auto&quot;&gt;&lt;/div&gt;
&lt;script&gt;
 var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-4, 4, 4, -4], axis:true,  showCopyright:false, showNavigation:false });
 var graph1 = board.create('functiongraph', [function(x){return Math.sin(x);}, -Math.PI, Math.PI],{name:'sin(x)', withLabel:true});
 var graph2 = board.create('functiongraph', [function(x){return x*x-2;}, -3, 3],{name:'x^2 - 2', withLabel:true, strokeColor:'red'});
&lt;/script&gt;
</code></pre>
<div id="jxgbox" class="jxgbox" style="width:300px; height:300px; margin:auto"></div>
<script>
 var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-4, 4, 4, -4], axis:true,  showCopyright:false, showNavigation:false });
 var graph1 = board.create('functiongraph', [function(x){return Math.sin(x);},-Math.PI,Math.PI],{name:'sin(x)', withLabel:true});
 var graph2 = board.create('functiongraph', [function(x){return x*x-2;},-3,3],{name:'x^2 - 2', withLabel:true, strokeColor:'red'});
</script>
<p>{lang=EN}
In this example we first changed properties of <code>div</code> and set the width and heigth to form a square area, because we wanted 
nicer looking construction (other posibility would be to use attribute <em>keepAspectRatio</em> in initBoard()). Then we created
two functions. </p>
<p>To draw a $\sin (x)$ function we used <em>functiongraph</em> as a type 
<code>var graph1 = board.create('functiongraph', </code>.<br />
But what follows is something new.
Let us look closely to <code>[function(x){return Math.sin(x);},-Math.PI,Math.PI]</code>. With type <em>functiongraph</em> we told JSXGraph that
we will be drawing a function on some interval, therefore we need to provide the function we want to draw. 
<code>function(x){return Math.sin(x);}</code> does just that. Here we use anonymous function <code>function(x)</code> where we provide parameter <code>x</code>,
that is used by JSXgraph to provide <code>x</code> values from the interval we have set with second and third element of the list. In our 
case this is <code>-Math.PI, Math.PI</code>. Now we have to define a function that will return a value ($y-coordinate$) for the given $x$.
This was done by <code>{return Math.sin(x);}</code>. We have to use reserved word <code>return</code> which is followed by a function, in our case
<code>Math.sin(x)</code>. We end this with <code>;}</code> which must use to end the statement and the function.</p>
<p>In the second <em>graph2</em> we have drawn a quadratic function <code>{return x*x-2;}</code> on the interval <code>-3, 3</code>. We also used some attributes
which we already explained on previous pages.</p>
<p>Note: For the <em>sine</em> function we used <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math">Javascript Math</a> library. 
{/lang}</p>
<p>{lang=SI}
In this example we first changed properties of <code>div</code> and set the width and heigth to form a square area, because we wanted 
nicer looking construction (other posibility would be to use attribute <em>keepAspectRatio</em> in initBoard()). Then we created
two functions. </p>
<p>To draw a $\sin (x)$ function we used <em>functiongraph</em> as a type 
<code>var graph1 = board.create('functiongraph', </code>.<br />
But what follows is something new.
Let us look closely to <code>[function(x){return Math.sin(x);},-Math.PI,Math.PI]</code>. With type <em>functiongraph</em> we told JSXGraph that
we will be drawing a function on some interval, therefore we need to provide the function we want to draw. 
<code>function(x){return Math.sin(x);}</code> does just that. Here we use anonymous function <code>function(x)</code> where we provide parameter <code>x</code>,
that is used by JSXgraph to provide <code>x</code> values from the interval we have set with second and third element of the list. In our 
case this is <code>-Math.PI, Math.PI</code>. Now we have to define a function that will return a value ($y-coordinate$) for the given $x$.
This was done by <code>{return Math.sin(x);}</code>. We have to use reserved word <code>return</code> which is followed by a function, in our case
<code>Math.sin(x)</code>. We end this with <code>;}</code> which must use to end the statement and the function.</p>
<p>In the second <em>graph2</em> we have drawn a quadratic function <code>{return x*x-2;}</code> on the interval <code>-3, 3</code>. We also used some attributes
which we already explained on previous pages.</p>
<p>Note: For the <em>sine</em> function we used <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math">Javascript Math</a> library. 
{/lang}</p>
<p>{lang=CZ}</p>
<p>V tomto příkladě jsme nejprve změnili vlastnosti bloku <code>div</code>, konkrétně jsme nastavili šířku (<em>width</em>) a výšku (<em>heigth</em>)
nákresny tak, aby měla čtvercový tvar (další možností by bylo použití atributu <em>keepAspectRatio</em> ve funkci <em>initBoard()</em>, 
viz kapitola <em>3.6 Kružnice</em>). Potom jsme zadali zobrazení grafů dvou funkcí. </p>
<p>Pro zobrazení grafu funkce $\sin (x)$ jsme použili objekt typu <em>functiongraph</em> známým způsobem <code>var graph1 = board.create('functiongraph', ...</code>, 
ale to, co následuje, je něco nového. </p>
<p>Pojďme se detailně zaměřit na část kódu <code>[function(x){return Math.sin(x);},-Math.PI,Math.PI]</code>. 
Uvedením typu <em>functiongraph</em> jsme JSXGraph informovali o tom, že budeme zobrazovat graf funkce na nějakém intervalu.
Nejprve parametrem <code>function(x){return Math.sin(x);}</code> zadáme výraz $\sin (x)$ definující hodnotu funkce pro dané $x$.
Užitím anonymní funkce <code>function(x)</code> zavedeme parametr <code>x</code>, kterému JSXGraph přiřazuje hodnoty ($x-souřadnice$) z intervalu, jehož 
meze jsou dány druhým a třetím prvkem seznamu parametrů, tj. hodnotami <code>-Math.PI, Math.PI</code>. 
Argumentem <code>{return Math.sin(x);}</code> je pro JSXGraph definována funkce, která pro dané $x$ vrátí příslušnou 
funkční hodnotu ($y-souřadnici$). Museli jsme použít klíčové slovo <code>return</code> následované příslušnou funkcí, 
v našem případě <code>Math.sin(x)</code>. Zadání funkce zakončíme znakem <code>;</code> a ukončíme závorku <code>}</code>.</p>
<p>Druhý graf <em>graph2</em> přísluší kvadratické funkci <code>{return x*x-2;}</code> on the interval <code>-3, 3</code>. Samozřejmě, k nastavení vzhledu 
grafů používáme i atributy, které byly představeny v předchozích kapitolách.</p>
<p>Poznámka: Pro funkci <em>sinus</em> byla použita knihovna <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math">Javascript Math</a>. 
{/lang}</p>
<p>{lang=EN}</p>
<h2><a class="header" href="#animating" id="animating">Animating</a></h2>
<p>Although creating points and lines and also drawing can be very useful, the power of JSXgraph lies when we want that 
our construction are not fixed, but can be used to simulate or demonstrate something. 
In this chapter we will learn </p>
<ul>
<li>how to move objects</li>
<li>how to &quot;glue&quot; objects to other objects (e.g points on the lines)</li>
<li>how to create sliders</li>
<li>how to transform objects (scaling, rotating, etc).
{/lang}
{lang=SI}</li>
</ul>
<h2><a class="header" href="#animating-1" id="animating-1">Animating</a></h2>
<p>{/lang}
{lang=CZ}</p>
<h2><a class="header" href="#animating-2" id="animating-2">Animating</a></h2>
<p>{/lang}</p>
<p>{lang=EN}</p>
<h2><a class="header" href="#moving-objects" id="moving-objects">Moving objects</a></h2>
<p>Sometimes we want to move points to explain or present some concept. We can use this to animate the point by moving to 
final point (using method moveTo()) or only visiting some point and returning back to the start.
We will use both methods in next example.
{/lang}
{lang=SI}</p>
<h2><a class="header" href="#moving-objects-1" id="moving-objects-1">Moving objects</a></h2>
<p>{/lang}
{lang=CZ}</p>
<h2><a class="header" href="#moving-objects-2" id="moving-objects-2">Moving objects</a></h2>
<p>{/lang}</p>
<pre><code class="language-JS">&lt;div id=&quot;jxgbox&quot; class=&quot;jxgbox&quot; style=&quot;width:500px; height:200px;&quot;&gt;&lt;/div&gt;
&lt;script&gt;
 var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-4, 4, 4, -4],keepAspectRatio:true, showCopyright:false, showNavigation:false });
 var p = board.create('point',[-1,0],{name:&quot;A&quot;});
 var q = board.create('point',[3,2],{name:&quot;B&quot;});
 var button1 = board.create('button',[2,3,'Start B', function(){q.visit([3,-2],1800,2)}]);
 var button2 = board.create('button',[-3,3,'Move A', function(){p.moveTo([Math.random()*8-4,Math.random()*8-4],500);}]);
&lt;/script&gt;
</code></pre>
<div id="jxgbox" class="jxgbox" style="width:300px; height:300px; margin:auto"></div>
<script>
 var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-4, 4, 4, -4],keepAspectRatio:true, showCopyright:false, showNavigation:false });
 var p = board.create('point',[-1,0],{name:"A"});
 var q = board.create('point',[3,2],{name:"B"});
 var button1 = board.create('button',[2,3,'Start B', function(){q.visit([3,-2],1800,2)}]);
 var button2 = board.create('button',[-3,3,'Move A', function(){p.moveTo([Math.random()*8-4,Math.random()*8-4],500);}]);
</script>
<p>First three lines are usual, but in the next line <code>var button1 = board.create('button',[2,3,'Start B', function(){q.visit([3,-2],1800,2)}]);</code> we use 
two new commands. </p>
<p>Let us focus first on the second command: <code>q.visit([3, -2], 1800, 2)</code>. Until now we always 
used only one method <em>create()</em> which we provided with parameters to create points, etc. on the board. Now we introduce 
a new method for the point which is called <a href="https://jsxgraph.uni-bayreuth.de/docs/symbols/JXG.CoordsElement.html#visit"><em>visit()</em></a>.
Its syntax is <strong>visit(where, time, options)</strong> with three parameters,</p>
<ul>
<li><em>where</em> coordinates of our destination e.g. <code>[3, -2]</code>,</li>
<li><em>time</em> how long should it take e.g. <code>1800</code>,</li>
<li><em>options</em> in our case how many repetitions of our visit e.g <code>2</code>. </li>
</ul>
<p>First command creates a button on a board which click on it triggers some action. The parameters in the list are as follows
<strong>[x-coordinate, y-coordinate, title on the button, action]</strong>. In our case the action was anonymous function with the 
<em>visit</em> method on point <em>q</em>.</p>
<p>The second button is created in next line, but let us now look at the action more closely which is <code>p.moveTo([Math.random()*8-4,Math.random()*8-4],500);</code>.
Here we use on the point <em>q</em> new method <em>moveTo</em> which takes only two parameters</p>
<ul>
<li>destination coordinates as a list of two elements e.g  <code>[Math.random()*8-4,Math.random()*8-4]</code></li>
<li>animation time in miliseconds, e.g <code>500</code>.</li>
</ul>
<p>For the coordinates we use <em>Math.random</em> method, which every time we click on the button creates new random number between 0 and 1 
which we multiply by $8$ and subtract by $4$, result then will be between $-4$ and $4$m which are also limits of our bounding box.
We do the same for both coordinates. As a result our point p (<code>&quot;A&quot;</code>) moves across the board randomly. </p>
<h1><a class="header" href="#langenexamplelanglangsicreating-basic-objectslanglangczusing-basic-objectslang" id="langenexamplelanglangsicreating-basic-objectslanglangczusing-basic-objectslang">{lang=EN}Example{/lang}{lang=SI}Creating basic objects{/lang}{lang=CZ}Using basic objects{/lang}</a></h1>
<p>{lang=EN}</p>
<h2><a class="header" href="#sliders" id="sliders">Sliders</a></h2>
<p>Sliders can be used in various settings, where we want that users try or tinker with the values of some variable. In our example
we will upgrade example with the quadratic function.
{/lang}
{lang=SI}</p>
<h2><a class="header" href="#sliders-1" id="sliders-1">Sliders</a></h2>
<p>{/lang}
{lang=CZ}</p>
<h2><a class="header" href="#sliders-2" id="sliders-2">Sliders</a></h2>
<p>{/lang}</p>
<pre><code class="language-JS">&lt;div id=&quot;jxgbox&quot; class=&quot;jxgbox&quot; style=&quot;width:300px; height:300px; margin:auto&quot;&gt;&lt;/div&gt;
&lt;script&gt;
 var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-8, 8, 8, -8], axis:true,  showCopyright:false, showNavigation:false });
 var a = board.create('slider', [[-7.5, -3], [-4,-3], [-3, 1, 3]], {name:'a', snapWidth: 0.1});
 var c = board.create('slider', [[-7.5, -5], [-4,-5], [-1, 1, 4]], {name:'c',snapWidth: 1});
 var graph2 = board.create('functiongraph', [function(x){return a.Value()*x*x + c.Value();}, -3, 3]);
 var text = board.create('text',[-6,6,function(){return a.Value().toFixed(2)+'\\times x^2'+c.Value()}]);
&lt;/script&gt;
</code></pre>
<div id="jxgbox" class="jxgbox" style="width:300px; height:300px; margin:auto"></div>
<script>
 var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-8, 8, 8, -8], axis:true,  showCopyright:false, showNavigation:false });
 var a = board.create('slider', [[-7.5, -3], [-4,-3], [-3, 1, 3]], {name:'a', snapWidth: 0.1});
 var c = board.create('slider', [[-7.5, -5], [-4,-5], [-1, 1, 4]], {name:'c',snapWidth: 1});
 var graph2 = board.create('functiongraph', [function(x){return a.Value()*x*x + c.Value();}, -3, 3]);
</script>
<p>{lang=EN}
We extended the example with two sliders which now control the quadratic function. But first let us look closer on how we
created first <em>slider</em>: <code>var a = board.create('slider', [[-7.5, -3], [-4,-3], [-3, 1, 3]], {name:'a', snapWidth: 0.1});</code></p>
<p>To create a slider we need to provide following parameters:</p>
<ul>
<li>coordinates of the first point of the slider, e.g. <code>[-7.5, -3]</code></li>
<li>coordinates of the last point of the slider, e.g. <code>[-4,-3]</code></li>
<li>values of the slider as a list <code>[min, start, max]</code>, e.g. <code>[-3, 1, 3]</code>.</li>
</ul>
<p>Here we also used atribute <em>snapWidth</em> which tells JSXGraph how fine the steps of the slider should be. Second slider is generated 
in similar way, except we set the attribute <em>snapWidth</em> to $1$ to generate only integer values.</p>
<p>In last line we now used the values from both sliders and extended our quadratic function with <code>return a.Value()*x*x + c.Value()</code>.
We can see, that to get the value of the slider we used the variable name and method <em>Value()</em> e.g. <code>a.Value()</code>. </p>
<p>Now the quadratic function is not fixed with the values but can be dynamically changed with the user interaction.</p>
<p>{/lang}</p>
<h1><a class="header" href="#langenanimating-with-sliderslanglangsianimating-with-sliderslanglangczanimating-with-sliderslang" id="langenanimating-with-sliderslanglangsianimating-with-sliderslanglangczanimating-with-sliderslang">{lang=EN}Animating with sliders{/lang}{lang=SI}Animating with sliders{/lang}{lang=CZ}Animating with sliders{/lang}</a></h1>
<h1><a class="header" href="#langenexamplelanglangsicreating-basic-objectslanglangczusing-basic-objectslang-1" id="langenexamplelanglangsicreating-basic-objectslanglangczusing-basic-objectslang-1">{lang=EN}Example{/lang}{lang=SI}Creating basic objects{/lang}{lang=CZ}Using basic objects{/lang}</a></h1>
<h1><a class="header" href="#langentransformationslanglangsifunctions-drawinglanglangczfunctions-drawinglang" id="langentransformationslanglangsifunctions-drawinglanglangczfunctions-drawinglang">{lang=EN}Transformations{/lang}{lang=SI}Functions drawing{/lang}{lang=CZ}Functions drawing{/lang}</a></h1>
<h1><a class="header" href="#langenadvanced-topicslanglangsiadvanced-topicslanglangczadvanced-topicslang" id="langenadvanced-topicslanglangsiadvanced-topicslanglangczadvanced-topicslang">{lang=EN}Advanced topics{/lang}{lang=SI}Advanced topics{/lang}{lang=CZ}Advanced topics{/lang}</a></h1>
<h1><a class="header" href="#langenadding-imageslanglangsifunctions-drawinglanglangczfunctions-drawinglang" id="langenadding-imageslanglangsifunctions-drawinglanglangczfunctions-drawinglang">{lang=EN}Adding images{/lang}{lang=SI}Functions drawing{/lang}{lang=CZ}Functions drawing{/lang}</a></h1>
<h1><a class="header" href="#langencapture-the-construction-as-imagelanglangsicapture-the-construction-as-imagelanglangczcapture-the-construction-as-imagelang" id="langencapture-the-construction-as-imagelanglangsicapture-the-construction-as-imagelanglangczcapture-the-construction-as-imagelang">{lang=EN}Capture the construction as image{/lang}{lang=SI}Capture the construction as image{/lang}{lang=CZ}Capture the construction as image{/lang}</a></h1>
<h1><a class="header" href="#langenjsxgraph-optionslanglangsijsxgraph-optionslanglangczjsxgraph-optionslang" id="langenjsxgraph-optionslanglangsijsxgraph-optionslanglangczjsxgraph-optionslang">{lang=EN}JSXGraph options{/lang}{lang=SI}JSXGraph options{/lang}{lang=CZ}JSXGraph options{/lang}</a></h1>
<h1><a class="header" href="#langentriggerslanglangsitriggerslanglangcztriggerslang" id="langentriggerslanglangsitriggerslanglangcztriggerslang">{lang=EN}Triggers{/lang}{lang=SI}Triggers{/lang}{lang=CZ}Triggers{/lang}</a></h1>
<h1><a class="header" href="#langensaving-user-actionslanglangsisaving-user-actionslanglangczsaving-user-actionslang" id="langensaving-user-actionslanglangsisaving-user-actionslanglangczsaving-user-actionslang">{lang=EN}Saving user actions{/lang}{lang=SI}Saving user actions{/lang}{lang=CZ}Saving user actions{/lang}</a></h1>
<h1><a class="header" href="#langenjessie-codelanglangsifunctions-drawinglanglangczfunctions-drawinglang" id="langenjessie-codelanglangsifunctions-drawinglanglangczfunctions-drawinglang">{lang=EN}Jessie Code{/lang}{lang=SI}Functions drawing{/lang}{lang=CZ}Functions drawing{/lang}</a></h1>
<h1><a class="header" href="#langenjsxgraph-and-moodlelanglangsijsxgraph-and-moodlelanglangczjsxgraph-and-moodlelang" id="langenjsxgraph-and-moodlelanglangsijsxgraph-and-moodlelanglangczjsxgraph-and-moodlelang">{lang=EN}JSXGraph and Moodle{/lang}{lang=SI}JSXGraph and Moodle{/lang}{lang=CZ}JSXGraph and Moodle{/lang}</a></h1>
<h1><a class="header" href="#langenjsxgraph-as-a-moodle-filterlanglangsijsxgraph-as-a-moodle-filterlanglangczjsxgraph-as-a-moodle-filterlang" id="langenjsxgraph-as-a-moodle-filterlanglangsijsxgraph-as-a-moodle-filterlanglangczjsxgraph-as-a-moodle-filterlang">{lang=EN}JSXGraph as a Moodle Filter{/lang}{lang=SI}JSXGraph as a Moodle Filter{/lang}{lang=CZ}JSXGraph as a Moodle Filter{/lang}</a></h1>
<h1><a class="header" href="#langenjsxgraph-and-moodle-formulaslanglangsijsxgraph-and-moodle-formulaslanglangczjsxgraph-and-moodle-formulaslang" id="langenjsxgraph-and-moodle-formulaslanglangsijsxgraph-and-moodle-formulaslanglangczjsxgraph-and-moodle-formulaslang">{lang=EN}JSXGraph and Moodle Formulas{/lang}{lang=SI}JSXGraph and Moodle Formulas{/lang}{lang=CZ}JSXGraph and Moodle Formulas{/lang}</a></h1>
<h1><a class="header" href="#langenjsxgraph-and-stacklanglangsijsxgraph-and-stacklanglangczjsxgraph-and-stacklang" id="langenjsxgraph-and-stacklanglangsijsxgraph-and-stacklanglangczjsxgraph-and-stacklang">{lang=EN}JSXGraph and Stack{/lang}{lang=SI}JSXGraph and Stack{/lang}{lang=CZ}JSXGraph and Stack{/lang}</a></h1>
<h1><a class="header" href="#langentemplateslanglangsitemplateslanglangcztemplateslang" id="langentemplateslanglangsitemplateslanglangcztemplateslang">{lang=EN}Templates{/lang}{lang=SI}Templates{/lang}{lang=CZ}Templates{/lang}</a></h1>
<h1><a class="header" href="#langenjsx-guilanglangsijsx-guilanglangczjsx-guilang" id="langenjsx-guilanglangsijsx-guilanglangczjsx-guilang">{lang=EN}JSX Gui{/lang}{lang=SI}JSX Gui{/lang}{lang=CZ}JSX Gui{/lang}</a></h1>
<h1><a class="header" href="#contributors" id="contributors">Contributors</a></h1>
<ul>
<li>Igor Pesek </li>
<li>Blaž Zmazek</li>
<li>Roman Hašek</li>
<li>Alfred Wassermann</li>
<li>Bernat Martinez</li>
<li>other members of <a href="https://itemspro.eu/">ITEMS</a> project</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        
        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3001");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload(true); // force reload from server (not from cache)
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="files/jsxbook.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
        
        

    </body>
</html>
