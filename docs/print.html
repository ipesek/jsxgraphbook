<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title> JSXGraph book</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        <script type="text/javascript" src="files/jquery.js"></script>
        <script type="text/javascript" src="files/jsxgraphcore.js"></script>
        <link rel="stylesheet" href="files/jsxgraph.css">

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
        <script type="text/x-mathjax-config">
          MathJax.Hub.Config({
              "HTML-CSS": {availableFonts: ["TeX"],scale: 90},
               tex2jax: {inlineMath: [["$","$"]],  displayMath: [["$$","$$"]],  processEscapes: true},
                config:["TeX-AMS_HTML.js"]});
        </script>
        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li><a href="1_introduction.html"><strong aria-hidden="true">1.</strong> {lang=EN}Introduction{/lang} {lang=SI}Uvod{/lang} {lang=CZ}Úvod{/lang} {lang=DE}Einführung{/lang}</a></li><li><a href="2_setup.html"><strong aria-hidden="true">2.</strong> {lang=EN}How to setup{/lang}{lang=SI}How to setup{/lang}{lang=CZ}Jak začít{/lang} {lang=DE}Vorbereitung{/lang}</a></li><li><a href="3_basics.html"><strong aria-hidden="true">3.</strong> {lang=EN}Basics{/lang}{lang=SI}Basics{/lang}{lang=CZ}Základy{/lang} {lang=DE}Grundlagen{/lang}</a></li><li><ol class="section"><li><a href="3_1_board.html"><strong aria-hidden="true">3.1.</strong> {lang=EN}Drawing area{/lang}{lang=SI}Drawing area{/lang}{lang=CZ}Nákresna{/lang} {lang=DE}Zeichenbereich{/lang}</a></li><li><a href="3_2_basic_objects.html"><strong aria-hidden="true">3.2.</strong> {lang=EN}Creating points{/lang}{lang=SI}Creating points{/lang}{lang=CZ}Vytváření bodů{/lang} {lang=DE}Punkte erzeugen{/lang}</a></li><li><a href="3_2a_lines.html"><strong aria-hidden="true">3.3.</strong> {lang=EN}Creating lines{/lang}{lang=SI}Creating lines{/lang}{lang=CZ}Kreslení přímek{/lang} {lang=DE}Geraden erzeugen{/lang}</a></li><li><a href="3_2b_objects_drawing.html"><strong aria-hidden="true">3.4.</strong> {lang=EN}Adding attributes to the objects{/lang}{lang=SI}Adding properties to the objects{/lang}{lang=CZ}Nastavení vlastností objektů{/lang} {lang=DE}Attribute zu Objekten hinzufügen{/lang}</a></li><li><a href="3_2c_example.html"><strong aria-hidden="true">3.5.</strong> {lang=EN}Example{/lang}{lang=SI}Example{/lang}{lang=CZ}Příklad{/lang} {lang=DE}Beispiel{/lang}</a></li><li><a href="3_3_circles.html"><strong aria-hidden="true">3.6.</strong> {lang=EN}Circles{/lang}{lang=SI}Circles{/lang}{lang=CZ}Kružnice{/lang} {lang=DE}Kreise{/lang}</a></li><li><a href="3_4_polygons.html"><strong aria-hidden="true">3.7.</strong> {lang=EN}Polygons{/lang}{lang=SI}Polygons{/lang}{lang=CZ}Mnohoúhelníky{/lang} {lang=DE}Polygone{/lang}</a></li><li><a href="3_4a_example.html"><strong aria-hidden="true">3.8.</strong> {lang=EN}Example{/lang}{lang=SI}Example{/lang}{lang=CZ}Příklad{/lang} {lang=DE}Beispiel{/lang}</a></li><li><a href="3_5_intersections.html"><strong aria-hidden="true">3.9.</strong> {lang=EN}Intersections{/lang}{lang=SI}Intersections{/lang}{lang=CZ}Průsečíky{/lang} {lang=DE}Schnittpunkte{/lang}</a></li><li><a href="3_6_angles.html"><strong aria-hidden="true">3.10.</strong> {lang=EN}Angles{/lang}{lang=SI}Angles{/lang}{lang=CZ}Úhly{/lang} {lang=DE}Winkel{/lang}</a></li><li><a href="3_7_curves.html"><strong aria-hidden="true">3.11.</strong> {lang=EN}Curves{/lang}{lang=SI}Curves{/lang}{lang=CZ}Křivky{/lang} {lang=DE}Kurven{/lang}</a></li><li><a href="3_8_functions.html"><strong aria-hidden="true">3.12.</strong> {lang=EN}Drawing functions{/lang}{lang=SI}Drawing functions{/lang}{lang=CZ}Zobrazení grafu funkce{/lang} {lang=DE}Funktionsgraphen{/lang}</a></li></ol></li><li><a href="4_animations.html"><strong aria-hidden="true">4.</strong> {lang=EN}Animating{/lang}{lang=SI}Animating{/lang}{lang=CZ}Animace{/lang} {lang=DE}Animationen{/lang}</a></li><li><ol class="section"><li><a href="4_1_moving.html"><strong aria-hidden="true">4.1.</strong> {lang=EN}Moving objects{/lang}{lang=SI}Moving objects{/lang}{lang=CZ}Pohybování s objekty{/lang} {lang=DE}Objekte bewegen{/lang}</a></li><li><a href="4_1a_example.html"><strong aria-hidden="true">4.2.</strong> {lang=EN}Example{/lang}{lang=SI}Example{/lang}{lang=CZ}Příklad{/lang} {lang=DE}Beispiel{/lang}</a></li><li><a href="4_2_sliders.html"><strong aria-hidden="true">4.3.</strong> {lang=EN}Sliders{/lang}{lang=SI}Sliders{/lang}{lang=CZ}Posuvníky{/lang} {lang=DE}Schieberegler{/lang}</a></li><li><a href="4_3_animation_sliders.html"><strong aria-hidden="true">4.4.</strong> {lang=EN}Animating with sliders{/lang}{lang=SI}Animating with sliders{/lang}{lang=CZ}Animace s posuvníky{/lang} {lang=DE}Animationen mit Schiebereglern{/lang}</a></li><li><a href="4_3a_example.html"><strong aria-hidden="true">4.5.</strong> {lang=EN}Example{/lang}{lang=SI}Example{/lang}{lang=CZ}Příklad{/lang} {lang=DE}Beispiel{/lang}</a></li><li><a href="4_4_transformations.html"><strong aria-hidden="true">4.6.</strong> {lang=EN}Transformations{/lang}{lang=SI}Transformations{/lang}{lang=CZ}Transformace{/lang} {lang=DE}Transformationen{/lang}</a></li></ol></li><li><a href="5_advanced.html"><strong aria-hidden="true">5.</strong> {lang=EN}Advanced topics{/lang}{lang=SI}Advanced topics{/lang}{lang=CZ}Pokročilá témata{/lang} {lang=DE}Fortgeschrittene Themen{/lang}</a></li><li><ol class="section"><li><a href="5_1_adding_images.html"><strong aria-hidden="true">5.1.</strong> {lang=EN}Adding images{/lang}{lang=SI}Adding images{/lang}{lang=CZ}Vkládání obrázků{/lang} {lang=DE}Bilder hinzufügen{/lang}</a></li><li><a href="5_1_screencapture.html"><strong aria-hidden="true">5.2.</strong> {lang=EN}Capture the construction as image{/lang}{lang=SI}Capture the construction as image{/lang}{lang=CZ}Zachycení konstrukce jako obrázku{/lang} {lang=DE}Speichern einer Konstruktion als Bild{/lang}</a></li><li><a href="5_2_jsxoptions.html"><strong aria-hidden="true">5.3.</strong> {lang=EN}JSXGraph options{/lang}{lang=SI}JSXGraph options{/lang}{lang=CZ}Volby JSXGraphu{/lang} {lang=DE}JSXGraph-Optionen{/lang}</a></li><li><a href="5_3_trigers.html"><strong aria-hidden="true">5.4.</strong> {lang=EN}Events{/lang}{lang=SI}Events{/lang}{lang=CZ}Události{/lang} {lang=DE}Ereignisbehandlung{/lang}</a></li><li><a href="5_4_user_actions.html"><strong aria-hidden="true">5.5.</strong> {lang=EN}Saving user actions{/lang}{lang=SI}Saving user actions{/lang}{lang=CZ}Uložení uživatelských akcí{/lang} {lang=DE}Nutzeraktionen abspeichern{/lang}</a></li><li><a href="5_5_jessie_code.html"><strong aria-hidden="true">5.6.</strong> {lang=EN}Jessie Code{/lang}{lang=SI}Jessie Code{/lang}{lang=CZ}Jessie Code{/lang} {lang=DE}JessieCode{/lang}</a></li><li><a href="6_moodle.html"><strong aria-hidden="true">5.7.</strong> {lang=EN}JSXGraph and Moodle{/lang}{lang=SI}JSXGraph and Moodle{/lang}{lang=CZ}JSXGraph a Moodle{/lang} {lang=DE}JSXGraph und Moodle{/lang}</a></li><li><a href="6_1_jsxfilter.html"><strong aria-hidden="true">5.8.</strong> {lang=EN}JSXGraph as a Moodle Filter{/lang}{lang=SI}JSXGraph as a Moodle Filter{/lang}{lang=CZ}JSXGraph jako filtr v Moodlu{/lang} {lang=DE}JSGraph als Moodle-Filter{/lang}</a></li><li><a href="6_2_formulas.html"><strong aria-hidden="true">5.9.</strong> {lang=EN}JSXGraph and Moodle Formulas{/lang}{lang=SI}JSXGraph and Moodle Formulas{/lang}{lang=CZ}JSXGraph a Moodle Formulas{/lang} {lang=DE}JSXGraph und Moodle-Formulas{/lang}</a></li><li><a href="6_3_stack.html"><strong aria-hidden="true">5.10.</strong> {lang=EN}JSXGraph and Stack{/lang}{lang=SI}JSXGraph and Stack{/lang}{lang=CZ}JSXGraph a Stack{/lang} {lang=DE}JSXGraph und STACK{/lang}</a></li></ol></li><li><a href="7_templates.html"><strong aria-hidden="true">6.</strong> {lang=EN}Templates{/lang}{lang=SI}Templates{/lang}{lang=CZ}Šablony{/lang} {lang=DE}Vorlagen{/lang}</a></li><li><a href="8_gui.html"><strong aria-hidden="true">7.</strong> {lang=EN}JSX Gui{/lang}{lang=SI}JSX Gui{/lang}{lang=CZ}JSX GUI{/lang} {lang=DE}JSXGraph-Oberfläche{/lang}</a></li><li class="spacer"></li><li class="affix"><a href="contributors.html">{lang=EN}Contributors{/lang}{lang=SI}Contributors{/lang}{lang=CZ}Přispěvatelé{/lang} {lang=DE}Mitwirkende{/lang}</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>

                            <button id="lang-toggle" class="icon-button" type="button" style="font-weight: bold;color: black" title="Change language" aria-label="Change language" aria-haspopup="true" aria-expanded="false" aria-controls="lang-list">
                                EN
                            </button>
                            <ul id="lang-list" class="theme-popup" aria-label="Languages" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="EN">English</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="CZ">Čeština</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="DE">Deutsch</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="SI">Slovenščina</button></li>
                            </ul>

                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>



                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            

                        </div>

                        <h1 class="menu-title" id="menu-title">{lang=EN}JSXGraph Book{/lang}{lang=SI}Knjiga o JSXGraphu{/lang}{lang=CZ}Příručka JSXGraph{/lang}{lang=DE}JSXGraph-Buch{/lang}</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>

                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p>{lang=EN}</p>
<h2><a class="header" href="#this-is-a-manual-about-the-a-hrefhttpsjsxgraphorgjsxgrapha" id="this-is-a-manual-about-the-a-hrefhttpsjsxgraphorgjsxgrapha">This is a manual about the <a href="https://jsxgraph.org/">JSXGraph</a>.</a></h2>
<h4><a class="header" href="#work-in-progress" id="work-in-progress">(Work in progress)</a></h4>
<p>JSXGraph is a cross-browser JavaScript library for interactive geometry, function plotting, charting, and data visualization in the web browser.</p>
<p>This book covers the basics, how to build simple constructions and also some advanced topics on how to include JSXGraph in Moodle.</p>
<p><strong><em>To build JSXGraph constructions you don't need to be programmer (although it helps), but is rather more like
putting together
elements of the construction.</em></strong></p>
<p>Below is an example of power of JSXGraph.
<em>Hint: Move the dot and observe.</em>
{/lang}</p>
<p>{lang=CZ}</p>
<h2><a class="header" href="#příručka-pro-práci-v-a-hrefhttpsjsxgraphorgjsxgraphua" id="příručka-pro-práci-v-a-hrefhttpsjsxgraphorgjsxgraphua">Příručka pro práci v <a href="https://jsxgraph.org/">JSXGraphu</a>.</a></h2>
<h4><a class="header" href="#na-tomto-díle-se-stále-pracuje" id="na-tomto-díle-se-stále-pracuje">(Na tomto díle se stále pracuje)</a></h4>
<p>JSXGraph je knihovna JavaScriptu pro realizaci dynamické interaktivní geometrie, vykreslování funkcí, grafů a další vizualizace dat přímo ve webovém prohlížeči, nezávisle na jeho typu.</p>
<p>Tato příručka je věnována především úvodu do základních konstrukcí v JSXGraphu, nevyhýbá se však ani pokročilejším tématům, především v souvislosti se začleněním JSXGraphu do Moodle.</p>
<p><strong><em>Chcete-li tvořit dynamické materiály v JSXGraphu, nemusíte být nutně programátorem (i když by Vám to samozřejmě pomohlo), ve většině případů práce připomíná spíše skládání prvků stavebnice.</em></strong></p>
<p>Níže je uvedena ukázka možností JSXGraphu 
(Návod: Pohybujte posuvníkem - bodem na úsečce při dolním okraji okna a sledujte, co se děje).
{/lang}</p>
<p>{lang=SI}
To je priročnik o JSXGraphu.</p>
<p>JSXGraph je knjižnica JavaScript v brskalniku za interaktivno geometrijo, risanje funkcij, grafikone in vizualizacijo podatkov v spletnem brskalniku.</p>
<p>Ta knjiga zajema osnove, kako zgraditi preproste konstrukcije in tudi nekatere napredne teme o tem, kako vključiti JSXGraph v Moodle.</p>
<p>Če želite zgraditi JSXGraph konstrukcije, vam ni treba biti programer (čeprav pomaga), ampak je bolj podoben sestavljanju elementov konstrukcije.</p>
<p>Spodaj je primer moči JSXGraph.
Namig: premaknite piko in opazujte.
{/lang}</p>
<p>{lang=DE}</p>
<h2><a class="header" href="#dies-ist-ein-handbuch-zu-a-hrefhttpsjsxgraphorgjsxgrapha" id="dies-ist-ein-handbuch-zu-a-hrefhttpsjsxgraphorgjsxgrapha">Dies ist ein Handbuch zu <a href="https://jsxgraph.org/">JSXGraph</a>.</a></h2>
<h4><a class="header" href="#in-entstehung" id="in-entstehung">(In Entstehung)</a></h4>
<p>JSXGraph ist eine browser-unabhängige JavaScript.Bibliothek zu interaktiver Geometrie, Funktionsgraphen, Diagrammen und Daten-Visualisierung im Web-Browser.</p>
<p>Dieses Handbuch beschreibt die Grundlagen, wie einfache Konstruktionen erstellt werden können, sowie einige fortgeschrittenere Themen, zum Beispiel
die Einbindung von JSXGraph in Moodle.</p>
<p><strong><em>Um JSXGraph-Konstruktionen erstellen zu können, muss man kein Programmierer sein (obwohl es hilfreich ist); es ist mer ein Zusammenstellen der Konstruktionselemente.</em></strong></p>
<p>Das Beispiel unten zeigt die Mächtigkeit von JSXGraph.
<em>Hinweis: Bewegen Sie den Punkt und beobachten Sie die Auswirkung.</em>
{/lang}</p>
<div id="box16" class="jxgbox" style="width:500px; height:333px;margin-left:auto; margin-right:auto;"></div>
<script type='text/javascript'>
    JXG.Options.board.showNavigation = false;
    var color1 = "crimson";
	var brd16 = JXG.JSXGraph.initBoard('box16', {boundingbox: [-10.4625,7.6,10.4625,-5]});
	brd16.options.point.visible = false;
	brd16.options.point.fixed = false;
	brd16.options.polygon.borders.visible = false;
	var kot16 = brd16.create('slider', [[-9.5,-4],[-0.5,-4],[90,90,-60]], {withlabel:false});	
	var B116 = brd16.create('point', [-1,-4], {name:'B116'});
	var Vues16 = brd16.create('point', [function(){return kot16.Value() > 0 ? -0.9217 : (kot16.Value() < -30 ? -Math.PI/2 : -0.9217+(-Math.PI/2+0.9217)/30*(-kot16.Value()))}, function(){return kot16.Value() > -30 ? -0.55088 : (kot16.Value() < -29 ? -0.55088+(-1+0.55088)/30*(-30-kot16.Value()) : -1)}], {name:'Vues16', color:color1});
	var zoom16 = 1.6;
	var x16 = function(){return -zoom16 * Math.cos(Vues16.X()) * Math.sin(Vues16.Y())};
	var X16 = brd16.create('point', [function(){return B116.X() + zoom16 * Math.sin(Vues16.X())}, function(){return B116.Y()+x16}], {name:'X'});
	var u16 = brd16.create('point', [function(){return zoom16*Math.sin(Vues16.X());},x16], {name:'u16'});
	var k16 = -1;
	var Z16 = brd16.create('point', [function(){return B116.X()}, function(){return B116.Y()+zoom16*Math.cos(Vues16.Y())}], {name:'Z16'});
	var w16 = brd16.create('point', [0,function(){return zoom16*Math.cos(Vues16.Y());}], {name:'w16'});
	var Y_16 = brd16.create('point', [function(){return B116.X()+zoom16*Math.cos(Vues16.X())}, function(){return B116.Y()+zoom16*Math.sin(Vues16.X())*Math.sin(Vues16.Y())}], {name:'Y'});
	var v16 = brd16.create('point', [function(){return zoom16*Math.cos(Vues16.X())},function(){return zoom16*Math.sin(Vues16.X())*Math.sin(Vues16.Y());}], {name:'v16'});
	var O16 = brd16.create('point', [1,2], {name:'O16'});
	var a16 = 1;
	var b16 = 1;
	var d16 = 2; 
	var vzorec16 = brd16.create('slider', [[18,5.5],[18,-2],[1,1,11]], {withlabel:false});
	var K16 = brd16.create('point', [function(){return O16.X() + a16 * u16.X() + b16 * v16.X()},function(){return O16.Y() + a16 * u16.Y() + b16 * v16.Y()}], {name:'K16'});
	var L16 = brd16.create('point', [function(){return O16.X() - a16 * u16.X() + b16 * v16.X()},function(){return O16.Y() - a16 * u16.Y() + b16 * v16.Y()}], {name:'L16'});
	var M16 = brd16.create('point', [function(){return O16.X() - a16 * u16.X() - b16 * v16.X()},function(){return O16.Y() - a16 * u16.Y() - b16 * v16.Y()}], {name:'M16'});
	var N16 = brd16.create('point', [function(){return O16.X() + a16 * u16.X() - b16 * v16.X()},function(){return O16.Y() + a16 * u16.Y() - b16 * v16.Y()}], {name:'N16'});
	brd16.create('polygon', [L16,K16,N16,M16], {fillopacity:0.05});
	brd16.create('segment', [L16,K16], {});
	brd16.create('segment', [K16,N16], {});
	brd16.create('segment', [N16,M16], {});
	brd16.create('segment', [M16,L16], {});
	var P16 = brd16.create('point', [function(){return O16.X() + a16 * u16.X() + b16 * v16.X() + d16 * Math.cos((kot16.Value() < 0 ? 0 : kot16.Value())*Math.PI/180) * u16.X() + d16 * Math.sin((kot16.Value() < 0 ? 0 : kot16.Value())*Math.PI/180) * w16.X()},function(){return O16.Y() + a16 * u16.Y() + b16 * v16.Y() + d16 * Math.cos((kot16.Value() < 0 ? 0 : kot16.Value())*Math.PI/180) * u16.Y() + d16 * Math.sin((kot16.Value() < 0 ? 0 : kot16.Value())*Math.PI/180) * w16.Y()}], {name:'P16'});
	var Q16 = brd16.create('point', [function(){return O16.X() + a16 * u16.X() - b16 * v16.X() + d16 * Math.cos((kot16.Value() < 0 ? 0 : kot16.Value())*Math.PI/180) * u16.X() + d16 * Math.sin((kot16.Value() < 0 ? 0 : kot16.Value())*Math.PI/180) * w16.X()},function(){return O16.Y() + a16 * u16.Y() - b16 * v16.Y() + d16 * Math.cos((kot16.Value() < 0 ? 0 : kot16.Value())*Math.PI/180) * u16.Y() + d16 * Math.sin((kot16.Value() < 0 ? 0 : kot16.Value())*Math.PI/180) * w16.Y()}], {name:'Q16'});
	var R16 = brd16.create('point', [function(){return O16.X() - a16 * u16.X() + b16 * v16.X() - d16 * Math.cos((kot16.Value() < 0 ? 0 : kot16.Value())*Math.PI/180) * u16.X() + d16 * Math.sin((kot16.Value() < 0 ? 0 : kot16.Value())*Math.PI/180) * w16.X()},function(){return O16.Y() - a16 * u16.Y() + b16 * v16.Y() - d16 * Math.cos((kot16.Value() < 0 ? 0 : kot16.Value())*Math.PI/180) * u16.Y() + d16 * Math.sin((kot16.Value() < 0 ? 0 : kot16.Value())*Math.PI/180) * w16.Y()}], {name:'R16'});
	var S16 = brd16.create('point', [function(){return O16.X() - a16 * u16.X() - b16 * v16.X() - d16 * Math.cos((kot16.Value() < 0 ? 0 : kot16.Value())*Math.PI/180) * u16.X() + d16 * Math.sin((kot16.Value() < 0 ? 0 : kot16.Value())*Math.PI/180) * w16.X()},function(){return O16.Y() - a16 * u16.Y() - b16 * v16.Y() - d16 * Math.cos((kot16.Value() < 0 ? 0 : kot16.Value())*Math.PI/180) * u16.Y() + d16 * Math.sin((kot16.Value() < 0 ? 0 : kot16.Value())*Math.PI/180) * w16.Y()}], {name:'S16'});
	brd16.create('polygon', [K16,P16,Q16,N16]);
	brd16.create('segment', [K16,P16], {});
	brd16.create('segment', [P16,Q16], {});
	brd16.create('segment', [Q16,N16], {});
	brd16.create('segment', [N16,K16], {});
	brd16.create('polygon', [L16,M16,S16,R16], {opacity:function(){return vzorec16.Value()==1||vzorec16.Value()==2||vzorec16.Value()==3||vzorec16.Value()==4||vzorec16.Value()==7||vzorec16.Value()==7||vzorec16.Value()==8||vzorec16.Value()==9||vzorec16.Value()==10?0.25:0;}});
	brd16.create('segment', [L16,M16], {});
	brd16.create('segment', [M16,S16], {opacity:function(){return vzorec16.Value()!=5&&vzorec16.Value()!=6&&vzorec16.Value()!=11?1:0}});
	brd16.create('segment', [S16,R16], {opacity:function(){return vzorec16.Value()!=5&&vzorec16.Value()!=6&&vzorec16.Value()!=11?1:0}});
	brd16.create('segment', [R16,L16], {opacity:function(){return vzorec16.Value()!=5&&vzorec16.Value()!=6&&vzorec16.Value()!=11?1:0}});
	var T16 = brd16.create('point', [function(){return O16.X() + a16 * u16.X() + b16 * v16.X() + d16 * Math.cos((kot16.Value() < 0 ? 0 : kot16.Value())*Math.PI/180) * v16.X() + d16 * Math.sin((kot16.Value() < 0 ? 0 : kot16.Value())*Math.PI/180) * w16.X()},function(){return O16.Y() + a16 * u16.Y() + b16 * v16.Y() + d16 * Math.cos((kot16.Value() < 0 ? 0 : kot16.Value())*Math.PI/180) * v16.Y() + d16 * Math.sin((kot16.Value() < 0 ? 0 : kot16.Value())*Math.PI/180) * w16.Y()}], {name:'T16'});
	var U16 = brd16.create('point', [function(){return O16.X() - a16 * u16.X() + b16 * v16.X() + d16 * Math.cos((kot16.Value() < 0 ? 0 : kot16.Value())*Math.PI/180) * v16.X() + d16 * Math.sin((kot16.Value() < 0 ? 0 : kot16.Value())*Math.PI/180) * w16.X()},function(){return O16.Y() - a16 * u16.Y() + b16 * v16.Y() + d16 * Math.cos((kot16.Value() < 0 ? 0 : kot16.Value())*Math.PI/180) * v16.Y() + d16 * Math.sin((kot16.Value() < 0 ? 0 : kot16.Value())*Math.PI/180) * w16.Y()}], {name:'U16'});
	var V16 = brd16.create('point', [function(){return O16.X() + a16 * u16.X() - b16 * v16.X() - d16 * Math.cos((kot16.Value() < 0 ? 0 : kot16.Value())*Math.PI/180) * v16.X() + d16 * Math.sin((kot16.Value() < 0 ? 0 : kot16.Value())*Math.PI/180) * w16.X()},function(){return O16.Y() + a16 * u16.Y() - b16 * v16.Y() - d16 * Math.cos((kot16.Value() < 0 ? 0 : kot16.Value())*Math.PI/180) * v16.Y() + d16 * Math.sin((kot16.Value() < 0 ? 0 : kot16.Value())*Math.PI/180) * w16.Y()}], {name:'V16'});
	var W16 = brd16.create('point', [function(){return O16.X() - a16 * u16.X() - b16 * v16.X() - d16 * Math.cos((kot16.Value() < 0 ? 0 : kot16.Value())*Math.PI/180) * v16.X() + d16 * Math.sin((kot16.Value() < 0 ? 0 : kot16.Value())*Math.PI/180) * w16.X()},function(){return O16.Y() - a16 * u16.Y() - b16 * v16.Y() - d16 * Math.cos((kot16.Value() < 0 ? 0 : kot16.Value())*Math.PI/180) * v16.Y() + d16 * Math.sin((kot16.Value() < 0 ? 0 : kot16.Value())*Math.PI/180) * w16.Y()}], {name:'W16'});
	brd16.create('polygon', [N16,V16,W16,M16], {opacity:function(){return vzorec16.Value()==1||vzorec16.Value()==5||vzorec16.Value()==6||vzorec16.Value()==10||vzorec16.Value()==11?0.25:0;}});
	brd16.create('segment', [N16,V16], {opacity:function(){return vzorec16.Value()==1||vzorec16.Value()==5||vzorec16.Value()==6||vzorec16.Value()==10||vzorec16.Value()==11?1:0}});
	brd16.create('segment', [V16,W16], {opacity:function(){return vzorec16.Value()==1||vzorec16.Value()==5||vzorec16.Value()==6||vzorec16.Value()==10||vzorec16.Value()==11?1:0}});
	brd16.create('segment', [W16,M16], {opacity:function(){return vzorec16.Value()==1||vzorec16.Value()==5||vzorec16.Value()==6||vzorec16.Value()==10||vzorec16.Value()==11?1:0}});
	brd16.create('segment', [M16,N16], {});
	brd16.create('polygon', [K16,T16,U16,L16], {opacity:function(){return vzorec16.Value()<7?0.25:0;}});
	brd16.create('segment', [K16,T16], {opacity:function(){return vzorec16.Value()<7?1:0}});
	brd16.create('segment', [T16,U16], {opacity:function(){return vzorec16.Value()<7?1:0}});
	brd16.create('segment', [U16,L16], {opacity:function(){return vzorec16.Value()!=7&&vzorec16.Value()!=8&&vzorec16.Value()!=9&&vzorec16.Value()!=10&&vzorec16.Value()!=11?1:0}});
	brd16.create('segment', [L16,K16], {opacity:function(){return vzorec16.Value()==5?1:0}});
	var A16 = brd16.create('point', [function(){return O16.X() + a16 * u16.X() + b16 * v16.X() + d16 * Math.cos((kot16.Value() < 0 ? 0 : kot16.Value())*Math.PI/180) * u16.X() + d16 * Math.sin((kot16.Value() < 0 ? 0 : kot16.Value())*Math.PI/180) * w16.X() + 2 * a16 * Math.cos(2 * (kot16.Value() < 0 ? 0 : kot16.Value())*Math.PI/180) * u16.X() + b16 * Math.sin(2 * (kot16.Value() < 0 ? 0 : kot16.Value())*Math.PI/180) * w16.X()},function(){return O16.Y() + a16 * u16.Y() + b16 * v16.Y() + d16 * Math.cos((kot16.Value() < 0 ? 0 : kot16.Value())*Math.PI/180) * u16.Y() + d16 * Math.sin((kot16.Value() < 0 ? 0 : kot16.Value())*Math.PI/180) * w16.Y() + 2 * a16 * Math.cos(2 * (kot16.Value() < 0 ? 0 : kot16.Value())*Math.PI/180) * u16.Y() + b16 * Math.sin(2 * (kot16.Value() < 0 ? 0 : kot16.Value())*Math.PI/180) * w16.Y()}], {name:'A16'});
	var B16 = brd16.create('point', [function(){return O16.X() + a16 * u16.X() - b16 * v16.X() + d16 * Math.cos((kot16.Value() < 0 ? 0 : kot16.Value())*Math.PI/180) * u16.X() + d16 * Math.sin((kot16.Value() < 0 ? 0 : kot16.Value())*Math.PI/180) * w16.X() + 2 * a16 * Math.cos(2 * (kot16.Value() < 0 ? 0 : kot16.Value())*Math.PI/180) * u16.X() + b16 * Math.sin(2 * (kot16.Value() < 0 ? 0 : kot16.Value())*Math.PI/180) * w16.X()},function(){return O16.Y() + a16 * u16.Y() - b16 * v16.Y() + d16 * Math.cos((kot16.Value() < 0 ? 0 : kot16.Value())*Math.PI/180) * u16.Y() + d16 * Math.sin((kot16.Value() < 0 ? 0 : kot16.Value())*Math.PI/180) * w16.Y() + 2 * a16 * Math.cos(2 * (kot16.Value() < 0 ? 0 : kot16.Value())*Math.PI/180) * u16.Y() + b16 * Math.sin(2 * (kot16.Value() < 0 ? 0 : kot16.Value())*Math.PI/180) * w16.Y()}], {name:'B16'});
	brd16.create('polygon', [B16,Q16,P16,A16], {opacity:function(){return vzorec16.Value()<9&&vzorec16.Value()!=7?0.25:0;}});
	brd16.create('segment', [B16,Q16], {opacity:function(){return vzorec16.Value()!=7&&vzorec16.Value()!=9&&vzorec16.Value()!=10&&vzorec16.Value()!=11?1:0}});
	brd16.create('segment', [Q16,P16], {});
	brd16.create('segment', [P16,A16], {opacity:function(){return vzorec16.Value()!=7&&vzorec16.Value()!=9&&vzorec16.Value()!=10&&vzorec16.Value()!=11?1:0}});
	brd16.create('segment', [A16,B16], {opacity:function(){return vzorec16.Value()!=7&&vzorec16.Value()!=9&&vzorec16.Value()!=10&&vzorec16.Value()!=11?1:0}});
	brd16.options.text.anchory = 'top';
	brd16.options.text.fontsize = 16;
	var ploscina16 = brd16.create('slider', [[0.5,-4],[9.5,-4],[0,0,8]], {withlabel:false});
		ploscina16.setDisplayRendNode(false);
		ploscina16.highline.setDisplayRendNode(false);
		ploscina16.baseline.setDisplayRendNode(false);
	brd16.create('text', [function(){return V16.X() + 1.3},function(){return V16.Y()-0.3}, function(){return 'a'}], {opacity:function(){return ploscina16.Value() > 0 ? 1 : 0}});
	brd16.create('text', [function(){return W16.X() + 0.3},function(){return W16.Y()+1.375}, function(){return 'a'}], {opacity:function(){return ploscina16.Value() > 0 ? 1 : 0}});
	brd16.create('text', [function(){return V16.X() + 1.2},function(){return V16.Y() + 1.75}, function(){return 'a^2'}], {opacity:function(){return ploscina16.Value() > 1 ? 1 : 0}});
	brd16.create('text', [function(){return N16.X() + 1.2},function(){return N16.Y() + 1.75}, function(){return 'a^2'}], {opacity:function(){return ploscina16.Value() > 2 ? 1 : 0}});
	brd16.create('text', [function(){return M16.X() + 1.2},function(){return M16.Y() + 1.75}, function(){return 'a^2'}], {opacity:function(){return ploscina16.Value() > 3 ? 1 : 0}});
	brd16.create('text', [function(){return Q16.X() + 1.2},function(){return Q16.Y() + 1.75}, function(){return 'a^2'}], {opacity:function(){return ploscina16.Value() > 4 ? 1 : 0}});
	brd16.create('text', [function(){return B16.X() + 1.2},function(){return B16.Y() + 1.75}, function(){return 'a^2'}], {opacity:function(){return ploscina16.Value() > 5 ? 1 : 0}});
	brd16.create('text', [function(){return K16.X() + 1.2},function(){return K16.Y() + 1.75}, function(){return 'a^2'}], {opacity:function(){return ploscina16.Value() > 6 ? 1 : 0}});
	brd16.create('text', [function(){return L16.X() + 1.2},function(){return L16.Y() + 1.75}, function(){return 'P=?'}], {opacity:function(){return ploscina16.Value() > 7 ? 1 : 0}});
	kot16.on('drag', function(){
		if(kot16.Value() > -60){
			ploscina16.setDisplayRendNode(false);
			ploscina16.highline.setDisplayRendNode(false);
			ploscina16.baseline.setDisplayRendNode(false);
			ploscina16.moveTo([-9.5,-4]);
		} else {
			ploscina16.showElement();
			ploscina16.highline.showElement();
			ploscina16.baseline.showElement();
			ploscina16.moveTo([-9.75,-4]);
		}
	});
</script>
<p><a href="https://itemspro.eu"><img src="files/images/items_logo_blue.png" alt="ITEMS" /></a>
<a href="https://ec.europa.eu/programmes/erasmus-plus/"><img src="files/images/eu_flag_co_funded_pos_rgb_left_small.jpg" alt="Cofunded by the Erasmus+ programme of the European union" /></a></p>
<p>{lang=EN}</p>
<h2><a class="header" href="#how-to-setup" id="how-to-setup">How to setup</a></h2>
<p>When we prepare JSX construction it is most convenient to prepare it locally. For that we have to create some file (eg.
<code>example.htm</code>), copy paste template provided below and we can start constructing. After we save the program, we can open it in our
favorite browser (Firefox, Chrome, etc).
We can repeat following: edit the file, save it and refresh it (<em>(F5)</em> in a browser) until we're satisfied with result.</p>
<p>Basic template for building and testing is below
{/lang}
{lang=CZ}</p>
<h2><a class="header" href="#jak-začít" id="jak-začít">Jak začít</a></h2>
<p>Když chceme vytvořit novou konstrukci v JSXGraphu, nejlepší je připravit si ji lokálně, ve svém počítači. 
Není nutné ji nahrávat na nějaký server, stačí, když ji uložíme formou HTML souboru do svého počítače a následně otevřeme v našem oblíbeném prohlížeči.</p>
<p>Níže je uveden vzor obsahu HTML souboru webové stránky pro tvorbu a testování JSX appletu. 
Stačí jednoduše vytvořit soubor, řekněme s názvem <em>priklad.html</em>, a zkopírovat do něj obsah níže uvedeného okna. Jediné, co potom budeme při tvorbě vlastního appletu
měnit, je pasáž mezi tagy <em>&lt;script&gt;, &lt;/script&gt;</em>.</p>
<p>Dokud nejsme spokojeni s podobou appletu, opakujeme následující akce: editace souboru, jeho uložení a prohlédnutí prohlížečem (zobrazení stránky v prohlížeči aktualizujeme stisknutím <em>(F5)</em>).
{/lang}
{lang=SI}
When we prepare JSX construction it is most convenient to prepare it locally. We don't need to upload it to some server, 
we just need to save it and refresh the page <em>(F5)</em> in browser. 
Very simple template for building and testing is below
{/lang}
{lang=DE}</p>
<h2><a class="header" href="#vorbereitung" id="vorbereitung">Vorbereitung</a></h2>
<p>Eine JSXGraph-Konstrunktion kann am bequemsten lokal mit einem Text-Editor auf einem Computer erstellt werden.
Dazu legen wir eine leere HTML-Datei an (z.B. <code>example.htm</code>) und kopieren die untenstehende Vorlage in die Datei.
Danach können wir mit dem Konstruieren beginnen.
Nachdem wir die Datei gespeichert haben, können wir sie
in einem Web-Browser unserer Wahl (Firefox, Chrome, etc) öffnen.</p>
<p>Dieser Prozess kann beliebig wiederholt werden: Datei bearbeiten, speichern und im Browser aktualisieren (<em>(F5)</em> im Web-Browser), bis wir mit
dem Resultat zufrieden sind.</p>
<p>Hier ist eine Vorlage für eine einfache HTML-Datei mit JSXGraph:
{/lang}</p>
<pre><code class="language-HTML">&lt;!DOCTYPE HTML&gt;
&lt;html lang=&quot;en&quot;&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot;&gt;
        &lt;title&gt;JSXGraph template&lt;/title&gt;
        &lt;meta content=&quot;text/html; charset=utf-8&quot; http-equiv=&quot;Content-Type&quot;&gt;
        &lt;script type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot; src=&quot;https://cdnjs.cloudflare.com/ajax/libs/jsxgraph/0.99.7
/jsxgraphcore.js&quot;&gt;&lt;/script&gt;
        &lt;script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js' async&gt;&lt;/script&gt;
        &lt;script type=&quot;text/x-mathjax-config&quot;&gt;
          MathJax.Hub.Config({
              &quot;HTML-CSS&quot;: {availableFonts: [&quot;TeX&quot;],scale: 90},
               tex2jax: {inlineMath: [[&quot;$&quot;,&quot;$&quot;]],  displayMath: [[&quot;$$&quot;,&quot;$$&quot;]],  processEscapes: true},
                config:[&quot;TeX-AMS_HTML.js&quot;]});
        &lt;/script&gt;   
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/jsxgraph/0.99.7/jsxgraph.css
&quot; /&gt;
    &lt;/head&gt;
  &lt;body&gt;

     &lt;div id=&quot;jxgbox&quot; class=&quot;jxgbox&quot; style=&quot;width:500px; height:200px;&quot;&gt;&lt;/div&gt;

     &lt;script&gt;
        var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-5, 2, 5, -2]});
     &lt;/script&gt;

  &lt;/body&gt;
&lt;/html&gt;

</code></pre>
<p>{lang=EN}
<em>These scripts are all downloaded from the internet, therefore we need an constant internet connection.</em>
{/lang}
{lang=CZ}
<em>Všechny použité skripty jsou nahrávány z internetu, proto je třeba mít trvalé internetové připojení.</em>
{/lang}
{lang=SI}
<em>These scripts are all downloaded from the internet, therefore we need an constant internet connection.</em>
{/lang}
{lang=DE}
<em>Diese Programme werden alle vom Internet heruntergeladen, deshalb benötigen wir eine Internetverbindung.</em>
{/lang}</p>
<p>{lang=EN}</p>
<h2><a class="header" href="#basics" id="basics">Basics</a></h2>
<p>JSXGraph construction is composed from:</p>
<ul>
<li>drawing board</li>
<li>objects (points, lines, etc.)</li>
<li>relations between objects (optional, if we want some dynamics in the construction)</li>
<li>events (optional, if we want some additional actions to be triggered)</li>
</ul>
<p>In this section we will cover how to create drawing board, objects and use them to construct some simple examples.</p>
<p>{/lang}</p>
<p>{lang=CZ}</p>
<h2><a class="header" href="#základy" id="základy">Základy</a></h2>
<p>Konstrukce v JSXGraphu má tyto základní prvky:</p>
<ul>
<li>nákresna</li>
<li>objekty (body, přímky atd.)</li>
<li>vztahy mezi objekty (volitelné, chceme-li mít v konstrukci nějakou dynamiku)</li>
<li>události (volitelné, pokud chceme, aby byly spuštěny nějaké doplňkové akce)</li>
</ul>
<p>V této části příručky se budeme věnovat vytvoření nákresny a zobrazení základních objektů, jejichž užití si budeme ilustrovat
prostřednictvím jednoduchých příkladů.</p>
<p>{/lang}</p>
<p>{lang=SI}</p>
<h2><a class="header" href="#basics-1" id="basics-1">Basics</a></h2>
<p>JSXGraph construction is composed from:</p>
<ul>
<li>drawing board</li>
<li>objects (points, lines, etc.)</li>
<li>relations between objects (optional, if we want some dynamics in the construction)</li>
<li>events (optional, if we want some additional actions to be triggered)</li>
</ul>
<p>In this section we will cover how to create drawing board, objects and use them to construct some simple examples.</p>
<p>{/lang}</p>
<p>{lang=DE}</p>
<h2><a class="header" href="#grundlagen" id="grundlagen">Grundlagen</a></h2>
<p>Jede JSXGraph-Konstruktion setzt sich zusammen aus:</p>
<ul>
<li>Zeichenfläche</li>
<li>Objekten (Punkten, Geraden, etc.)</li>
<li>Beziehungen zwischen Objekten (optional, falls wir Dynamik in der Konstruktion benötigen)</li>
<li>Ereignissen (events) (optional, falls zusätzliche Aktionen ausgelöst werden sollen)</li>
</ul>
<p>In thiesem Kapitel werden wir kennenlernen, wie dieZeichenfläche angelegt wird und wie sie für einfache
Beispiele genutzt werden kann.</p>
<p>{/lang}</p>
<p>{lang=EN}</p>
<h2><a class="header" href="#drawing-area" id="drawing-area">Drawing area</a></h2>
<p>JSXGraph needs canvas as a place to put constructions on. Because we have HTML and Javascript we need an element in
HTML which we will tell Javascript to use as canvas. First we create a place in HTML where we will our construction be.
For this we use <code>div</code> element with some properties.</p>
<pre><code class="language-HTML">&lt;div id=&quot;jxgbox&quot; class=&quot;jxgbox&quot; style=&quot;width:500px; height:200px;&quot;&gt;&lt;/div&gt;
</code></pre>
<p>If we look at the line closely we see few properties. For us it is important <code>id=&quot;jxgbox&quot;</code> which we use to connect with JSXGraph.
Next is <code>class=&quot;jxgbox&quot;</code> where we can specify how our board will look like. This is more advanced topic and will be discussed later.
Last property is `style=&quot;width:500px; height:200px;&quot; where we define size of our drawing board.<br />
<em>Important: here we do not define our coordinate system, but only the size of our canvas</em></p>
<p>When we have defined our canvas, we have to connect them with JSXGraph. This is done with following line, which should be put inside
of a <code>&lt;script&gt;&lt;/script&gt;</code> tag.</p>
<pre><code class="language-JS">var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-5, 2, 5, -2]});
</code></pre>
<p>We can see we called function <code>initBoard</code>, which constructs our drawing board . This function needs at least one argument,
which is the <em>id</em> of the element <code>div</code> we defined in our example <code>jxgbox</code>. <code>boundingbox: [-5, 2, 5, -2]</code> tells
JSXGraph coordinate system of our construction.</p>
<p>Observing both lines we see, that we have two measures for size. With <code>div</code> we created canvas with the size in pixels.
Then we declared also coordinate system with board where we defined our coordinate system, which we will use to place
objects on the board.
{/lang}</p>
<p>{lang=SI}
JSXGraph needs canvas as a place to put constructions on. Because we have HTML and Javascript we need an element in 
HTML which we will tell Javascript to use as canvas. This is done like this</p>
<pre><code class="language-HTML">&lt;div id=&quot;jxgbox&quot; class=&quot;jxgbox&quot; style=&quot;width:500px; height:200px;&quot;&gt;&lt;/div&gt;
</code></pre>
<p>If look at the line closely we see few properties. For us it is important <code>id=&quot;jxgbox&quot;</code> which we use to connect with JSXGraph.
Next is <code>class=&quot;jxgbox&quot;</code> where we can specify how our board will look like. This is more advanced topic and will be discussed later.
Last property is `style=&quot;width:500px; height:200px;&quot; where we define size of our drawing board.<br />
<em>Important: here we do not define our coordinate system, but only the size of our canvas</em></p>
<p>When we have defined our canvas, we have to connect them with JSXGraph. This is done with following line, which should be put inside</p>
<pre><code class="language-JS">var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-5, 2, 5, -2]});
</code></pre>
<p>We can see we called function <code>initBoard</code>, which constructs our drawing board . This function need at least one argument,
which is the name of id we defined earlier for div in our example <code>jxgbox</code>. <code>boundingbox: [-5, 2, 5, -2]</code> tells
JSXGraph coordinate system of our construction.</p>
<p>Code of whole example is then following:{/lang}</p>
<p>{lang=CZ}</p>
<h2><a class="header" href="#nákresna" id="nákresna">Nákresna</a></h2>
<p>JSXGraph potřebuje nějakou zobrazovací plochu, nákresnu, na kterou může vykreslovat konstrukce. Jelikož využíváme HTML a Javascript, potřebujeme vytvořit prvek v HTML, který bude Javascript používat jako své plátno. Nejprve vybereme v HTML místo, kde bude naše konstrukce umístěna. K tomu využijeme blokový prvek <code>&lt;div&gt;</code>, kterému nastavíme potřebné atributy.</p>
<pre><code class="language-HTML">&lt;div id=&quot;jxgbox&quot; class=&quot;jxgbox&quot; style=&quot;width:500px; height:200px;&quot;&gt;&lt;/div&gt;
</code></pre>
<p>Pokud se na řádek s kódem pozorně zaměříme, odhalíme několik nadefinovaných vlastností. Pro nás nejdůležitější je <code>id=&quot;jxgbox&quot;</code>, který slouží k identifikaci nákresny a její propojení s JSXGraph. Následuje <code>class=&quot;jxgbox&quot;</code>, což je přiřazení třídy, které slouží k nadefinování vzhledu naší nákresny. To je však pokročilejší téma, kterému se budeme věnovat později. Poslední vlastností je <code>style=&quot;width:500px; height:200px;&quot;</code>. Ta slouží k určení velikosti naší nákresny na webové stránce. </p>
<p><em>Důležité: Zde nenastavujeme podobu a polohu naší soustavy souřadnic, ale pouze velikost zobrazované nákresny.</em></p>
<p>Jakmile jsme si nadefinovali naší nákresnu, musíme ji propojit s JSXGraph. Toho dosáhneme následujícím řádkem, který však musíme umístit do prvku <code>&lt;script&gt;</code>, abychom jednoznačně určili, že se již jedná o samotný skript.</p>
<pre><code class="language-JS">var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-5, 2, 5, -2]});
</code></pre>
<p>Vidíme, že jsme využili funkci <code>initBoard</code>, která po svém zavolání vytvoří naší nákresnu. Tato funkce pro správné fungování potřebuje alespoň jeden argument. V našem případě jsme jako argument použili <em>id</em> námi definovaného prvku <code>&lt;div&gt;</code> tj. <code>jxgbox</code>. Atribut <code>boundingbox: [-5, 2, 5, -2]</code> poté JSXGraph sděluje, jakou část systému souřadnic chceme pro svou konstrukci zobrazovat.</p>
<p>Pokud mezi sebou porovnáme oba řádky kódu, zjistíme, že pro nastavení velikostí využíváme dvě různé míry. Pomocí <code>&lt;div&gt;</code> jsme určili velikost nákresny v pixelech. Poté jsme na nákresně definovali systém souřadnic, který bude sloužit k umisťování objektů do nákresny.
{/lang}</p>
<p>{lang=DE}</p>
<h2><a class="header" href="#zeichenbereich" id="zeichenbereich">Zeichenbereich</a></h2>
<p>JSXGraph benötigt eine Zeichenfläche, auf der die Konstruktion angelegt werden kann.
Da die Konstruktion in einem Web-Browser mit Hilfe der Programmiersprache JavaScript angezeigt werden soll,
müssen wir zuerst ein HTML-Element anlegen, das JSXGraph als Zeichenfläche verwenden kann.
Dies geschieht, indem wir folgendes <code>div</code>-Element mit einigen Eigenschaften anlegen:</p>
<pre><code class="language-HTML">&lt;div id=&quot;jxgbox&quot; class=&quot;jxgbox&quot; style=&quot;width:500px; height:200px;&quot;&gt;&lt;/div&gt;
</code></pre>
<p>Wenn wir diese Zeile genauer betrachten, sehen wir ein paar Besonderheiten.
Besonders wichtig ist für unsere Zwecke das Attribut <code>id=&quot;jxgbox&quot;</code>, das wir nützen um das HTML mit JSXGraph zu verbinden.
Als nächstes folgt <code>class=&quot;jxgbox&quot;</code>, womit wir festlegen, wie die Zeichenfläche aussieht.
Das ist bereits ein Thema für Fortgeschrittenere und wird später diksutiert werden.
Das letzte Attribut ist <code>style=&quot;width:500px; height:200px;&quot;</code>, das die Größe der Zeichenfläche festlegt.<br />
<em>Wichtig: damit legen wir nicht unser Koordinatensystem fest, sondern lediglich die Größe unserer Zeichenfläche.</em></p>
<p>Wenn wir nun so unsere Zeichenfläche in HTML festgelegt haben, können wir sie mit JSXGraph verbinden.
Dies machen wir mit der folgenden Zeile, die innerhalb eines <code>&lt;script&gt;&lt;/script&gt;</code>-Befehls stehen muß:</p>
<pre><code class="language-JS">var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-5, 2, 5, -2]});
</code></pre>
<p>In dieser Zeile wird die Funktion die Funktion <code>initBoard</code> aufgerufen, die ein JSXGraph-Zeichenfläche angelegt.
Diese Funktion erwartet mindestens ein Argument, nämlich die <em>id</em> des
HTML-Elements <code>div</code>, die in unserem Beispiel den Wert <code>jxgbox</code> hat.
Mit dem zweiten Argument <code>{boundingbox: [-5, 2, 5, -2]}</code> wird in JSXGraph das Koordinatensystem unserer Kornstruktion festgelegt.</p>
<p>Betrachtet wir beide Zeilen, so erkennen wir zwei Größeneinheiten.
Mit <code>div</code> wurde eine Zeichenfläche angelegt, deren Größe in Pixel angegeben ist.
Mit <code>initBoard</code> haben wir zudem ein Koordinatensystem in unserer Zeichenfläche angelegt, das wir nutzen werden um
Objekte auf der Zeichnfläche zu positionieren.
{/lang}</p>
<p>{lang=EN}</p>
<h2><a class="header" href="#creating-points" id="creating-points">Creating points</a></h2>
<p>Points are one of the most basic objects in JSXGraph. We always create objects on the JSXGraph board, therefore we must use same
board variable for the construction of all objects that will be on board.
{/lang}</p>
<p>{lang=SI}</p>
<h2><a class="header" href="#risanje-točk" id="risanje-točk">Risanje točk</a></h2>
<p>{/lang}</p>
<p>{lang=CZ}</p>
<h2><a class="header" href="#vytváření-bodů" id="vytváření-bodů">Vytváření bodů</a></h2>
<p>Body jsou základními a nejjednoduššími objekty v JSXGraph. V tomto příkladu zakreslíme do nákresny dva body. 
{/lang}</p>
<p>{lang=DE}</p>
<h2><a class="header" href="#punkte-erzeugen" id="punkte-erzeugen">Punkte erzeugen</a></h2>
<p>Punkte gehören zu den grundlegensten Objekten in JSXGraph.
Wir legen alle Objekte auf die Zeichenfläche (genannt &quot;board&quot;), deshalb verwenden wir für alle Objekte, die auf der dieser Zeichenfläche
entstehen sollen, dieselbe Variable <code>board</code>.
{/lang}</p>
<pre><code class="language-JS">&lt;div id=&quot;jxgbox&quot; class=&quot;jxgbox&quot; style=&quot;width:500px; height:200px;&quot;&gt;&lt;/div&gt;
&lt;script&gt;
 var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-5, 2, 5, -2]});
 board.create('point',[-2,1]);
 var q = board.create('point',[3,0]);
&lt;/script&gt;
</code></pre>
<div id="jxgbox" class="jxgbox" style="width:500px; height:200px;"></div>
<script>
 var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-5, 2, 5, -2]});
 board.create('point',[-3,1]);
 var q = board.create('point',[3,0]);
</script>
<p>{lang=EN}
Let us now observe <code>board.create('point',[-2,1]);</code>. Here we use variable <code>board</code> and call a method <em>create</em> which takes
two arguments. First argument is the type of the object and second the coordinates where this object should be. If we
define coordinates outside of the bounding box, the object will exist but won't be visible because it is outside visible
area of our drawing board.</p>
<p>Next line <code>var q = board.create('point',[3,0]);</code> is very similar to the previous line, with only one diference. We start
the line with <code>var q = </code> which we use to store this object in variable <em>q</em>. This is good and necessary practice, because
in the constructions we often reference different object and define their relationships, which will be more apparent in following pages.</p>
<p>{/lang}
{lang=CZ}
Zaměřme se nyní na <code>board.create('point',[-2,1]);</code>. Zde využíváme proměnnou <em>board</em> a metodu <em>create</em>, která vyžaduje dva argumenty. Prvním argumentem určujeme, jaký typ objekt se má v nákresně vytvořit, což je v našem případě bod, <em>point</em>. Druhý argument určuje souřadnice, na kterých bude bod v nákresně sestrojen. Pokud použijeme souřadnice, které leží mimo námi nadefinovaný systém souřadnic, tak se bod stejně sestrojí. Vytvořený bod ale nebude na naší nákresně viditelný, neboť bude sestrojen mimo zobrazovanou plochu. Pohybem po nákresně pomocí zoomu a šipek v jejím pravém dolním rohu je však možné sestrojený bod objevit.</p>
<p>Další řádek <code>var q = board.create('point',[3,0]);</code> je velice podobný předchozí konstrukci pouze s jedním rozdílem. Naší konstrukci začínáme <code>var q = </code>. Toto přiřazení slouží obecně k ukládání objektů do proměnných. V naší ukázce sestrojený bod ukládáme do proměnné <em>q</em>.</p>
<p>Ukládání objektů do proměnných je dobrou a často nezbytnou praxí. V konstrukcích se budeme často odkazovat na existující objekty a definovat mezi nimi vztahy a to právě pomocí proměnných. Toto bude patrnější na následujících stránkách.
{/lang}
{lang=DE}
Sehen wir uns den Befehl <code>board.create('point',[-2,1]);</code> genauer an:
Wir verwenden die Variable <code>board</code> und rufen eine Method <em>create</em> auf, die zwei Argumente hat.</p>
<p>Das erste Argument ist der Type des Objekts, das wir anlegen wollen, und das zweite Argument, legt fest wo das Objekt sein soll.
Wenn wir Koordinaten außerhalb der Zeichenfläche angeben, wird das Ojekt zwar existieren, aber nicht sichtbar sein.</p>
<p>Die nächste Programmzeile <code>var q = board.create('point',[3,0]);</code> ist der vorhergehenden sehr ähnlich, mit einem wesentlichen Unterschied.
Wir starten die Zeile mit <code>var q = </code>. Damit speichern wir dieses Objekt in der Variablen <em>q</em>.
Das ist bewährte und notwendige Praxis, denn in unseren Konstruktionen werden wir oft auf existierende Objekte
zurückgreifen und ihre gegenseitigen Abhängigkeiten festlegen.
Dies wird auf den folgenden Seiten klarer werden.
{/lang}</p>
<p>{lang=EN}</p>
<h2><a class="header" href="#creating-lines" id="creating-lines">Creating lines</a></h2>
<p>Lines are the next type of the objects that we will learn. Line is defined by two points through which line is drawn.
Here is an example of a board with two lines.
{/lang}
{lang=SI}
Creating basic objects
{/lang}
{lang=CZ}</p>
<h2><a class="header" href="#kreslení-přímek" id="kreslení-přímek">Kreslení přímek</a></h2>
<p>Dalším objektem, s jehož konstrukcí se seznámíme, je přímka.
Ta je v JSXGraphu definována dvěma body, kterými prochází. </p>
<p>Níže je uveden příklad kódu, kterým jsou v nákresně narýsovány dvě přímky. 
První z nich je zadána přímo souřadnicemi určujících bodů, druhá je potom definována pomocí proměnných, které jsou 
jejím určujícím bodům přiřazeny.</p>
<p>{/lang}</p>
<p>{lang=DE}</p>
<h2><a class="header" href="#geraden-erzeugen" id="geraden-erzeugen">Geraden erzeugen</a></h2>
<p>Geraden sind der nächste Objekttype, den wir kennenlernen.
Eine Gerade wird durch zwei Punkte festgelegt.
Hier ist ein Beispiel einer Zeichenfläche mit zwei Geraden.
{/lang}</p>
<pre><code class="language-JS">&lt;div id=&quot;jxgbox&quot; class=&quot;jxgbox&quot; style=&quot;width:500px; height:200px;&quot;&gt;&lt;/div&gt;
&lt;script&gt;
 var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-5, 2, 5, -2]});
 var line1 = board.create(&quot;line&quot;,[[-3,1],[3,-1]]);

 var p = board.create('point',[-2,-1]);
 var q = board.create('point',[3,1]);
 var line2 = board.create(&quot;line&quot;,[p,q]);
&lt;/script&gt;
</code></pre>
<p>{lang=EN}
Result:
{/lang}</p>
<p>{lang=CZ}
Výsledek:
{/lang}</p>
<p>{lang=DE}
Resultat:
{/lang}</p>
<div id="jxgbox" class="jxgbox" style="width:500px; height:200px;"></div>
<script>
 var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-5, 2, 5, -2]});
 var line1 = board.create("line",[[-3,1],[3,-1]]);
 var p = board.create('point',[-2,-1]);
 var q = board.create('point',[3,1]);
 var line2 = board.create("line",[p,q]);
</script>
<p>{lang=EN}
Line of code <code>var line1 = board.create(&quot;line&quot;,[[-3,1],[3,-1]]);</code> creates $line1$ through two points <code>[-3,1]</code> and <code>[3,-1]</code>.
For each point again we had to define $x$ and $y$ coordinate. Because for the line we need to provide a list of two points,
we enclose both points in square brackets, therefore the list of two points is <code>[[-3,1],[3,-1]]</code>.</p>
<p>For the second $line2$ we first defined two points $p$ and $q$ and used them as `[p,q] when defining the $line2$. Here we already
see why ìt is useful to store objects in variables, because now we could define third line, that could also go through point $p$ or $q$
and we don't need to worry if coordinates are correct.</p>
<p><em>Note: In Javascript lists are written in square brackets <strong>[ ]</strong>.</em>
{/lang}</p>
<p>{lang=CZ}
Řádek s kódem <code>var line1 = board.create(&quot;line&quot;,[[-3,1],[3,-1]]);</code> vytváří přímku $line1$, která prochází 
body <code>[-3,1]</code> a <code>[3,-1]</code>. 
Každý bod je definován uspořádanou dvojicí (seznamem) souřadnic $x$ a $y$. Uspořádaný seznam je uzavřen do hranatých
závorek [...]. Protože přímka je určena dvěma body, zapisujeme do její definice seznam těchto bodů<code>[[-3,1],[3,-1]]</code>.</p>
<p>V případě druhé přímky $line2$ jsme nejprve definovali dva body $p$ a $q$ a v definici přímky použili 
jejich proměnné <code>[p,q]</code>. Již na tomto jednoduchém příkladě vidíme, jak je užitečné
ukládat objekty do proměnných. Potom můžeme například klidně definovat třetí přímku, procházející 
některým z bodů $p$, $q$ a nemusíme se strachovat, zda jeho souřadnice opisujeme dobře.</p>
<p><em>Poznámka: V Javascriptu je seznam uváděn v hranatých závorkách <strong>[ ]</strong>.</em> 
{/lang}</p>
<p>{lang=DE}
Durch die Programmzeile <code>var line1 = board.create(&quot;line&quot;,[[-3,1],[3,-1]]);</code> wird die Gerade $line1$ durch die zwei Punkte <code>[-3,1]</code> and <code>[3,-1]</code> erzeugt.
Für jeden der beiden Punkte haben wir $x$- und $y$-Koordinate in der Form <code>[x, y]</code> angegeben.
Da wir für die Gerade eine Liste mit zwei Punkten benötigen, sind beide Koordinatenpaare wiederum in eckige Klammern eingeschlossen, d.h.
die Liste der beiden Punkte wird mit <code>[[-3,1],[3,-1]]</code> angegeben.</p>
<p>Für die zweite Gerade $line2$ legen wir zuerst zwei Punkte $p$ und $q$ an und verwenden sie mittels <code>[p,q]</code> um die Gerade $line2$ festzulegen.
Hier sehen wir bereits, warum es nützlich ist, Objekte in Variablen abzuspeichern. Wir könnten nun zum Beispiel eine dritte Gerade anlegen,
die ebenfalls furch $p$ und $q$ verläuft, ohne uns sorgen zu müssen, ob die Koordinaten korrekt sind.</p>
<p><em>Beachte: In Javascript werden Listen mittel eckiger Klammern <strong>[ ]</strong> angegeben.</em>
{/lang}</p>
<p>{lang=EN}</p>
<h2><a class="header" href="#adding-attributes-to-the-objects" id="adding-attributes-to-the-objects">Adding attributes to the objects</a></h2>
<p>Objects in JSXGraph have attributes, which describes them. Some of them are common (like color, name, etc.) and some are
more specific. Points have properties for e.g. shape, where line has other attribute e.g. if (attribute straightLast) and
how line ends at the second point (more <a href="https://jsxgraph.org/docs/symbols/Line.html">here</a>).
We can always look at the <a href="https://jsxgraph.org/docs/index.html">JSXGraph API documentation</a>, which describes
all the objects and their attributes.</p>
<p>Let us look now at the example.
{/lang}</p>
<p>{lang=SI}</p>
<h2><a class="header" href="#adding-attributes-to-the-objects-1" id="adding-attributes-to-the-objects-1">Adding attributes to the objects</a></h2>
<p>Objects in JSXGraph have attributes, which describes them. Some of them are common (like color, name, etc.) and some are 
more specific. Points have properties for e.g. shape, where line has other attribute e.g. if (attribute straightLast) and 
how line ends at the second point (more <a href="https://jsxgraph.org/docs/symbols/Line.html">here</a>). 
We can always look at the <a href="https://jsxgraph.org/docs/index.html">JSXGraph API documentation</a>, which describes 
all the objects and their attributes. </p>
<p>Let us look now at the example. 
{/lang}</p>
<p>{lang=CZ}</p>
<h2><a class="header" href="#nastavení-vlastností-objektů" id="nastavení-vlastností-objektů">Nastavení vlastností objektů</a></h2>
<p>Objekty v JSXGraphu mají atributy, které je charakterizují. Některé z nich jsou společné všem 
(jako barva, jméno apod.), některé jsou typické pro objekty konkrétního druhu. 
Body mají například různé tvary, u přímky pak lze např. stanovit, zda bude končit v druhém ze svých určujících bodů
(atribut <em>straightLast</em>) a jak v něm bude končit (více <a href="https://jsxgraph.org/docs/symbols/Line.html">zde</a>). </p>
<p>Popisy všech atributů objektů JSXGraphu jsou uvedeny v dokumentaci <a href="https://jsxgraph.org/docs/index.html">JSXGraph Reference</a>. </p>
<p>Podívejme se na následující příklad: 
{/lang}</p>
<p>{lang=DE}</p>
<h2><a class="header" href="#attribute-zu-objekten-hinzufügen" id="attribute-zu-objekten-hinzufügen">Attribute zu Objekten hinzufügen</a></h2>
<p>JSXGraph-Objekte besitzen Attribute, durch die sie beschrieben werden.
Einige dieser Attribute stehen in allen Objekte zur Verfügung (z.B. <code>color</code>, <code>name</code>, etc.), andere Attribute gibt es nur
bei speziellen Objekten.
Zum Beispiel besitzen Punkte das Attribut <code>shape</code>, Geraden dagegen besitzen zum Beispiel Attribute, die festlegen, ob die Gerade über die definierenden Punkte hinuasgezeichnet wird oder nicht (Attribute <code>straightForst</code>und <code>straightLast</code>).
Siehe hierzu auch <a href="https://jsxgraph.org/docs/symbols/Line.html">here</a>.</p>
<p>In der umfangreichen <a href="https://jsxgraph.org/docs/index.html">JSXGraph API Dokumentation</a> werden
alle Objekte und ihre Attribute detailliert beschrieben.</p>
<p>Betrachten wir folgendes Beispiel.
{/lang}</p>
<pre><code class="language-JS">&lt;div id=&quot;jxgbox&quot; class=&quot;jxgbox&quot; style=&quot;width:500px; height:200px;&quot;&gt;&lt;/div&gt;
&lt;script&gt;
 var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-5, 2, 5, -2]});

 var p = board.create('point',[-2,-1],{name:&quot;first&quot;, size:5, color:&quot;FF0000&quot;});
 var q = board.create('point',[3,1],{name:&quot;last&quot;,fixed:true, face:&quot;[]&quot;});

 var line2 = board.create(&quot;line&quot;,[p,q],{straightLast:false, dash:&quot;4&quot; });
&lt;/script&gt;
</code></pre>
<p>{lang=EN}
Result:
{/lang}</p>
<p>{lang=SI}
Result:
{/lang}</p>
<p>{lang=CZ}
Výsledek:
{/lang}</p>
<p>{lang=DE}
Resultat:
{/lang}</p>
<div id="jxgbox" class="jxgbox" style="width:500px; height:200px;"></div>
<script>
 var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-5, 2, 5, -2]});
 var p = board.create('point',[-2,-1],{name:"first", size:5, color:"FF0000"});
 var q = board.create('point',[3,1],{name:"last",fixed:true, face:"[]"});
 var line2 = board.create("line",[p,q],{straightLast:false, dash:"4" });
</script>
<p>{lang=EN}
In this example we added some attributes to the both points and to the line.
In all three examples we defined attributes as a list written between <code>{ }</code>. For each attribute we must write its name
and a value. As we mentioned earlier, objects can have specific attributes and also more general borrowed (inherited)
from other objects.</p>
<p>In <code>var p = board.create('point',[-2,-1],{name:&quot;first&quot;, size:5, color:&quot;FF0000&quot;});</code> first attribute is <em>name</em> which is borrowed
from <a href="https://jsxgraph.org/docs/symbols/JXG.GeometryElement.html#name">GeometryElement</a>, attribute <em>color</em> is also
borrowed, where attribute <a href="https://jsxgraph.org/docs/symbols/Point.html#size"><em>size</em></a> is not borrowed but belongs to object Point.
We can read from the documentation: <em>Size of a point, either in pixel or user coordinates. Means radius resp. half the
width of a point (depending on the face).</em></p>
<p>Second point has some interesting attributes <code>var q = board.create('point',[3,1],{name:&quot;last&quot;,fixed:true, face:&quot;[]&quot;});</code>
First is the attribute <em>fixed</em> which defines whether objects can be moved (dragged) on the board. <em>Default</em> value for this
attribute is false, which means we can move all objects on the board if they are not explicitly fixed. Now we first mentioned
<em>default value</em>, which is used when do not explicitly set another value for some attribute. In the documentation for each
attribute default value is also presented. The second new attribute is <a href="https://jsxgraph.org/docs/symbols/Point.html#face"><em>face</em></a>
where we used one of the possible shapes of a point.</p>
<p>When we defined <code>var line2 = board.create(&quot;line&quot;,[p,q],{straightLast:false, dash:&quot;4&quot; });</code>, we used two attributes,
first defining how line will end at second point (<em>straightLast</em>) and second defining how the line will be drawn (<em>dash</em>).
Again, <em>dash</em>  can have different values, <a href="https://jsxgraph.org/docs/symbols/JXG.GeometryElement.html#dash">documentation for dash attribute</a>
tells us which are possible values.</p>
<p>All objects have attributes, also Board object has <a href="https://jsxgraph.org/docs/symbols/JXG.Board.html">them</a>.
One of the attributes is <em>boundingbox</em>, which we used from first example, but didn't talk about it until now.
E.g. if you don't like the navigation (bottom right), then you can add attribute <em>showNavigation</em> and set it to false. Try it!</p>
<p><em><em>We can see that we can use attributes to fine tune on how our construction will behave and look.</em></em></p>
<p><strong>Documentation is a great resource for discovering attributes and also has some
examples of their usage.</strong>
{/lang}</p>
<p>{lang=SI}
In this example we added some attributes to the both points and to the line. 
In all three examples we defined attributes as a list written between <code>{ }</code>. For each attribute we must write its name
and a value. As we mentioned earlier, objects can have specific attributes and also more general borrowed (inherited) 
from other objects.</p>
<p>In <code>var p = board.create('point',[-2,-1],{name:&quot;first&quot;, size:5, color:&quot;FF0000&quot;});</code> first attribute is <em>name</em> which is borrowed 
from <a href="https://jsxgraph.org/docs/symbols/JXG.GeometryElement.html#name">GeometryElement</a>, attribute <em>color</em> is also 
borrowed, where attribute <a href="https://jsxgraph.org/docs/symbols/Point.html#size"><em>size</em></a> is not borrowed but belongs to object Point.
We can read from the documentation: <em>Size of a point, either in pixel or user coordinates. Means radius resp. half the 
width of a point (depending on the face).</em></p>
<p>Second point has some interesting attributes <code>var q = board.create('point',[3,1],{name:&quot;last&quot;,fixed:true, face:&quot;[]&quot;});</code>
First is the attribute <em>fixed</em> which defines whether objects can be moved (dragged) on the board. <em>Default</em> value for this
attribute is false, which means we can move all objects on the board if they are not explicitly fixed. Now we first mentioned
<em>default value</em>, which is used when do not explicitly set another value for some attribute. In the documentation for each 
attribute default value is also presented. The second new attribute is <a href="https://jsxgraph.org/docs/symbols/Point.html#face"><em>face</em></a>
where we used one of the possible shapes of a point. </p>
<p>When we defined <code>var line2 = board.create(&quot;line&quot;,[p,q],{straightLast:false, dash:&quot;4&quot; });</code>, we used two attributes,
first defining how line will end at second point (<em>straightLast</em>) and second defining how the line will be drawn (<em>dash</em>).
Again, <em>dash</em>  can have different values, <a href="https://jsxgraph.org/docs/symbols/JXG.GeometryElement.html#dash">documentation for dash attribute</a> 
tells us which are possible values.</p>
<p>All objects have attributes, also Board object has <a href="https://jsxgraph.org/docs/symbols/JXG.Board.html">them</a>. 
One of the attributes is <em>boundingbox</em>, which we used from first example, but didn't talk about it until now. 
E.g. if you don't like the navigation (bottom right), then you can add attribute <em>showNavigation</em> and set it to false. Try it!</p>
<p><em><em>We can see that we can use attributes to fine tune on how our construction will behave and look.</em></em></p>
<p><strong>Documentation is a great resource for discovering attributes and also has some
examples of their usage.</strong>
{/lang}</p>
<p>{lang=CZ}
V tomto příkladu jsme přidali některé atributy jak k bodům, tak i k přímce.
Ve všech třech případech jsme definovali vlastnosti objektů pomocí seznamu atributů uvedených v závorkách <code>{ }</code>.
Pro každý atribut musíme napsat jeho jméno a hodnotu. Jak již bylo uvedeno dříve, objekty mohou mít jak specifické atributy,
tak i atributy obecné, sdílené s více objekty. </p>
<p>V kódu <code>var p = board.create('point',[-2,-1],{name:&quot;first&quot;, size:5, color:&quot;FF0000&quot;});</code> 
je prvním atributem jméno objektu <em>name</em>, které je společné třídě <a href="https://jsxgraph.org/docs/symbols/JXG.GeometryElement.html#name">GeometryElement</a>, 
atribut barvy <em>color</em> je také společný, zatímco atribut velikosti <a href="https://jsxgraph.org/docs/symbols/Point.html#size"><em>size</em></a> 
není obecný, ale je typický pro objekt <em>Point</em> (bod).
V dokumentaci se dočteme: <em>Velikost bodu, buď v pixelech nebo v jednotkách určených uživatelem. Znamená poloměr nebo polovinu
šířky bodu (v závislosti na jeho vzhledu).</em></p>
<p>Kód <code>var q = board.create('point',[3,1],{name:&quot;last&quot;,fixed:true, face:&quot;[]&quot;});</code> definující druhý bod 
obsahuje další zajímavé atributy. První z nich je atribut <em>fixed</em>, který určuje, zda může být objekt přemisťován (tažen) 
po nákresně. <em>Nastavená</em> (<em>Default</em>) hodnota pro tento atribut je <em>false</em>, což znamená, že pokud objekty nejsou explicitně fixovány,
můžeme s nimi hýbat po nákresně. <em>Nastavená hodnota</em> (<em>default value</em>) je použita vždy, když není pro daný atribut explicitně zadána jiná hodnota. 
V dokumentaci jsou uvedeny nastavené hodnoty pro všechny atributy. Druhým novým atributem v uvedeném kódu je
<a href="https://jsxgraph.org/docs/symbols/Point.html#face"><em>face</em></a>, kterým nastavíme jeden z možných tvarů bodu. </p>
<p>V kódu <code>var line2 = board.create(&quot;line&quot;,[p,q],{straightLast:false, dash:&quot;4&quot; });</code> definice přímky byly použity dva
atributy, první z nich <em>straightLast</em> určuje, že přímka skončí ve druhém z určujících bodů, druhý <em>dash</em> potom určuje, jak bude čára nakreslena.
Parametr <em>dash</em> může nabývat různých hodnot, jejich přehled viz <a href="https://jsxgraph.org/docs/symbols/JXG.GeometryElement.html#dash">dokumentace pro atribut &quot;dash&quot;</a>.</p>
<p>Tak jako všechny objekty i nákresna (<em>Board</em>) má své <a href="https://jsxgraph.org/docs/symbols/JXG.Board.html">atributy</a>. 
Jedním z nich je <em>boundingbox</em>, který používáme již od první ukázky kódu nákresny, ale ještě jsme ho nekomentovali. 
Dalším atributem nákresny je <em>showNavigation</em>, který nám dovoluje skrýt navigační tlačítka v pravém dolním rohu nákresny,
pokud mu nastavíme hodnotu <em>false</em>. Vyzkoušejte to!</p>
<p><em><em>Vidíme, že pomocí nastavení hodnot atributů můžeme vyladit chování i vzhled naší konstrukce.</em></em></p>
<p><strong>Dokumentace je velkým zdrojem pro poznání všech atributů, které můžeme použít. Obsahuje také konkrétní příklady jejich použití.</strong>
{/lang}</p>
<p>{lang=DE}
In diesem Beispiel wurden einige Attribute zu den beiden Punkten und der Geraden hinzugefügt.
In allen drei Beispielen legen wir die Attribute durch eine Liste, die durch
geschweifte Klammern <code>{ }</code> eingeschlossen ist, fest.
Für jedes Attribut wird der Name und ein Wert angegeben. Wie bereits erwähnt, haben Objekte sowohl spezifische
Attribute als auch allgemeinere Objekte, die von anderen Objekten vererbt sind.</p>
<p>In <code>var p = board.create('point',[-2,-1],{name:&quot;first&quot;, size:5, color:&quot;FF0000&quot;});</code> ist das erste Attribut <em>name</em>,
das vom Element <a href="https://jsxgraph.org/docs/symbols/JXG.GeometryElement.html#name">GeometryElement</a>
abgeleitet ist.
Das Attribut <em>color</em> ist ebenfalls von diesem Element abgeleitet und daher in nahezu allen Elementen verfügbar.
Hingegen das Attribut <a href="https://jsxgraph.org/docs/symbols/Point.html#size"><em>size</em></a> ist ausschließlich im Objekt
Punkt verfügbar.</p>
<p>Aus der Dokumentation: <em>Size of a point, either in pixel or user coordinates. Means radius resp. half the
width of a point (depending on the face).</em></p>
<p>Dem zweiten Punkt im obigen Beispiel werden die interessanten Attribute
<code>var q = board.create('point',[3,1],{name:&quot;last&quot;,fixed:true, face:&quot;[]&quot;});</code> zugewiesen.
Das Attribut <em>fixed</em> legt fest ob das Objekt vom Betrachter bewegt (gezogen) werden kann. Der <em>Standardwert</em> für dieses Attribut ist <code>false</code>, was heißt, dass we alle Objekte über die Zeichenfläche ziehen können, für die dies nicht explizit
mit <code>fixed:true</code> unterbunden ist.</p>
<p>Wir habe gerade erstmals den <em>Standardwert</em> (<em>default value</em>) eines Attributs erwähnt. Dieser wird verwendet,
wenn nicht explizit ein anderer Wert gesetzt wird. In der Dokumentation wird für jedes Attribut der
zugehörige <em>default value</em> aufgelistet.</p>
<p>Das zweite neue Attribut ist <a href="https://jsxgraph.org/docs/symbols/Point.html#face"><em>face</em></a>
mit dem wir eine der möglichen Punktformen gewählt hatten.</p>
<p>Bei der Angabe <code>var line2 = board.create(&quot;line&quot;,[p,q],{straightLast:false, dash:&quot;4&quot; });</code> setzen wir zwei Attribute.
Mit dem ersten Attribut wird bestimmt, dass die &quot;Gerade&quot; am zweiten Punkt endet (<em>straightLast</em>).
Das zweite Attribut legt fest, wie die Gerade gezeichnet wird (<em>dash</em>).</p>
<p>Wie zuvor kann <em>dash</em>  verschiedene Werte annehmen, in der <a href="https://jsxgraph.org/docs/symbols/JXG.GeometryElement.html#dash">Dokumentation für das dash-Attribut</a> sind die möglichen Werte aufgelistet.</p>
<p>Alle Objekte haben Attribute, auch das board-Objekt hat
<a href="https://jsxgraph.org/docs/symbols/JXG.Board.html">Attribute</a>.
Eines dieser Attribute ist <em>boundingbox</em>, das bereits im ersten Beispiel verwendet wurde, aber über das noch nichts weiter gesagt wurde.</p>
<p>Wenn zum Beispiel die Navigations-Icons unten rechts ausgeblendet werden sollen, so kann
das Attribut <em>showNavigation</em> auf `false? gesetzt werden. Versuchen wir es!</p>
<p><em><em>Wir sehen, dass wir mit Attributen Feineinstellungen zum Verhalten und Aussehen unserer Konstruktion vornehmen können.</em></em></p>
<p><strong>Die Dokumentation ist eine hervorragende Quelle um Attribute zu entdecken. Zudem enthält sie viele Beispiele
wie Attribute verwendet werden.</strong>
{/lang}</p>
<p>{lang=EN}</p>
<h2><a class="header" href="#example" id="example">Example</a></h2>
<p><strong>Harmonic conjugate points.</strong> Given three collinear points <em>A</em>, <em>B</em> and <em>C</em>; <em>C</em> being outside the line segment <em>AB</em>.
Determine the point <em>D</em> of the segment <em>AB</em> so that the ratio of its distances to <em>A</em> and <em>B</em>, respectively, is equal to the
ratio of distances of the point <em>C</em> to points <em>A</em> and <em>B</em>, respectively, i.e. <em>|AD|/|BD|=|AC|/|BC|</em>.</p>
<p>This point <em>D</em> is called the <em>harmonic conjugate of C with respect to A and B</em> and points <em>A</em>, <em>B</em>, <em>C</em> and <em>D</em> together
form the so called <em>harmonic quadruple</em>.
{/lang}</p>
<p>{lang=CZ}</p>
<h2><a class="header" href="#příklad" id="příklad">Příklad</a></h2>
<p><strong>Harmonická čtveřice bodů.</strong> Jsou dány tři kolineární body <em>A</em>, <em>B</em> a <em>C</em>; <em>C</em> leží vně úsečky <em>AB</em>.
Určete bod <em>D</em> úsečky <em>AB</em> takový, že poměr jeho vzdáleností od bodů <em>A</em> a <em>B</em>, v daném pořadí, je roven poměru
vzdáleností bodu <em>C</em> od bodů <em>A</em> a <em>B</em>, tj. <em>|AD|/|BD|=|AC|/|BC|</em>.</p>
<p>Bod <em>D</em> potom nazýváme <em>harmonicky sdružený s bodem C vzhledem k bodům A a B</em>, takové body <em>A</em>, <em>B</em>, <em>C</em> a <em>D</em> potom společně
vytváří tzv. <em>harmonickou čtveřici</em>.
{/lang}</p>
<p>{lang=SI}</p>
<h2><a class="header" href="#example-1" id="example-1">Example</a></h2>
<p><strong>Harmonic conjugate points.</strong> Given three collinear points <em>A</em>, <em>B</em> and <em>C</em>; <em>C</em> being outside the line segment <em>AB</em>.
Determine the point <em>D</em> of the segment <em>AB</em> so that the ratio of its distances to <em>A</em> and <em>B</em>, respectively, is equal to the
ratio of distances of the point <em>C</em> to points <em>A</em> and <em>B</em>, respectively, i.e. <em>|AD|/|BD|=|AC|/|BC|</em>.</p>
<p>This point <em>D</em> is called the <em>harmonic conjugate of C with respect to A and B</em> and points <em>A</em>, <em>B</em>, <em>C</em> and <em>D</em> together
form the so called <em>harmonic quadruple</em>.
{/lang}</p>
<p>{lang=DE}</p>
<h2><a class="header" href="#beispiel" id="beispiel">Beispiel</a></h2>
<p><strong>Harmonische Teilung.</strong> Gegeben sind drei kollineare Punkte <em>A</em>, <em>B</em> und <em>C</em> (d.h. sie liegen auf einer Geraden),
wobei <em>C</em> ausserhalb der Strecke <em>AB</em> liege.
Bestimme einen Punkt <em>D</em> auf der Strecke <em>AB</em> so, dass das Verhältnis seiner Abstände zu den Punkten <em>A</em> und <em>B</em>
jeweils gleich dem Verhältnis der Abstände des Punktes <em>C</em> zu den Punkten <em>A</em> bzw. <em>B</em> ist, das heißt
<em>|AD|/|BD|=|AC|/|BC|</em>.</p>
<p>Diese Konstellation wird <a href="https://de.wikipedia.org/wiki/Harmonische_Teilung">harmonische Teilung</a> genannt.
{/lang}</p>
<p>{lang=EN}
<em>Result:</em>
To solve the task, we construct the so called <a href="https://en.wikipedia.org/wiki/Complete_quadrangle">complete quadrangle</a>,
as shown below.
{/lang}</p>
<p>{lang=CZ}
<em>Výsledek:</em>
K řešení úlohy využijeme konstrukci tzv. <a href="https://en.wikipedia.org/wiki/Complete_quadrangle">úplného čtyřrohu</a>,
jak vidíme níže.
{/lang}</p>
<p>{lang=SI}
<em>Result:</em>
To solve the task, we construct the so called <a href="https://en.wikipedia.org/wiki/Complete_quadrangle">complete quadrangle</a>,
as shown below.
{/lang}</p>
<p>{lang=DE}
<em>Resultat:</em>
Zur Lösung der Aufgabe konstruieren wir das sogenannte <a href="https://de.wikipedia.org/wiki/Fano-Axiom#:%7E:text=Ein%20vollst%C3%A4ndiges%20Viereck%20in%20einer,liegen%20auf%20einer%20gemeinsamen%20Gerade.">vollständige Viereck</a>,
wie unten zu sehen ist.
{/lang}</p>
<div id="jxgbox" class="jxgbox" style="width:500px; height:400px;"></div>
<script>
 var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-5, 5, 5, -3]});
 var A = board.create('point',[-4,-2]);
 var B = board.create('point',[0,-2]);
 var p = board.create('line',[A,B],{name: 'p',withLabel: true, color: 'green'});
 var C = board.create('glider', [4, 0, p]);
 var E = board.create('point', [1,4], {name: 'E',size:2, color: 'blue'});
 var q = board.create('line',[A,E],{name: 'q',withLabel: true, color: 'green'});
 var r = board.create('line',[B,E],{name: 'r',withLabel: true, color: 'green'});
 var F = board.create('glider', [0,0,q], {name: 'F',size:2, color: 'blue'});
 var s = board.create('line',[C,F],{name: 's',withLabel: true, color: 'green'});
 var G = board.create('intersection', [s, r,0], {name: 'G',size:2, color: 'blue'});
 var t = board.create('line',[A,G],{color: 'grey', dash:"2"});
 var u = board.create('line',[B,F],{color: 'grey', dash:"2"});
 var H = board.create('intersection', [t, u], {name: 'H',size:2, color: 'blue'});
 var v = board.create('line', [E,H],{color: 'grey', dash:"2"});
 var D = board.create('intersection', [p, v, 0]);
</script>
<p>{lang=EN}
<em>Programming:</em></p>
<p>First, we define the bounding box and create two points <em>A</em> and <em>B</em> with the line <em>p</em> passing through them:
{/lang}</p>
<p>{lang=CZ}
<em>Programování:</em></p>
<p>Nejprve definujeme parametry nákresny, tj. rozměry okna a rozsah souřadnic, a v ní sestrojíme body <em>A</em> a <em>B</em>
spolu s přímkou <em>p</em>, která jimi prochází:
{/lang}</p>
<p>{lang=SI}
<em>Programming:</em></p>
<p>First, we define the bounding box and create two points <em>A</em> and <em>B</em> with the line <em>p</em> passing through them:
{/lang}</p>
<p>{lang=DE}
<em>Programmierung:</em></p>
<p>Zuerst legen wir die <em>bounding box</em> fest und erzeigen zwei Punkte <em>A</em> und <em>B</em> sowie die Gerade <em>p</em> durch die beiden
Punkte:
{/lang}</p>
<pre><code class="language-JS">&lt;div id=&quot;jxgbox&quot; class=&quot;jxgbox&quot; style=&quot;width:500px; height:400px;&quot;&gt;&lt;/div&gt;
&lt;script&gt;
 var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-5, 5, 5, -3]});
 var A = board.create('point',[-4,-2]);
 var B = board.create('point',[0,-2]);
 var p = board.create('line',[A,B],{name: 'p',withLabel: true, color: 'green'});
&lt;/script&gt;
</code></pre>
<p>{lang=EN}
Then, we put the point <em>C</em> on <em>p</em> so that it can move along it:
{/lang}</p>
<p>{lang=CZ}
Potom na přímku <em>p</em> umístíme bod <em>C</em> tak, aby byl po ní volně pohyblivý:
{/lang}</p>
<p>{lang=SI}
Then, we put the point <em>C</em> on <em>p</em> so that it can move along it:
{/lang}</p>
<p>{lang=DE}
Dann legen wir den Punkt <em>C</em> auf die Gerade <em>p</em>, so dass wir ihn entlang der Geraden ziehen können.
$C$ wird <em>glider</em> genannt.
{/lang}</p>
<pre><code class="language-JS">&lt;div id=&quot;jxgbox&quot; class=&quot;jxgbox&quot; style=&quot;width:500px; height:400px;&quot;&gt;&lt;/div&gt;
&lt;script&gt;
 var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-5, 5, 5, -3]});
 var A = board.create('point',[-4,-2]);
 var B = board.create('point',[0,-2]);
 var p = board.create('line',[A,B],{name: 'p',withLabel: true, color: 'green'});
 var C = board.create('glider', [4, 0, p]);
&lt;/script&gt;
</code></pre>
<p>{lang=EN}
Now, we put the fourth point <em>E</em> above the line <em>p</em> and connect it by the straight lines <em>q</em> and <em>r</em> to points
<em>A</em> and <em>B</em>, respectively:
{/lang}</p>
<p>{lang=CZ}
Nyní umístíme čtvrtý bod <em>E</em> nad přímku <em>p</em> a přímkami <em>q</em> a <em>r</em> ho spojíme v daném pořadí postupně s body
<em>A</em> a <em>B</em>:
{/lang}</p>
<p>{lang=SI}
Now, we put the fourth point <em>E</em> above the line <em>p</em> and connect it by the straight lines <em>q</em> and <em>r</em> to points
<em>A</em> and <em>B</em>, respectively:
{/lang}</p>
<p>{lang=DE}
Nun erzeugen wir einen vierten Punkt <em>E</em> oberhalb der Geraden <em>p</em> an und konstruieren zwei Geraden <em>q</em> und <em>r</em>
durch <em>A</em> bzw. <em>B</em>:
{/lang}</p>
<pre><code class="language-JS">&lt;div id=&quot;jxgbox&quot; class=&quot;jxgbox&quot; style=&quot;width:500px; height:400px;&quot;&gt;&lt;/div&gt;
&lt;script&gt;
 var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-5, 5, 5, -3]});
 var A = board.create('point',[-4,-2]);
 var B = board.create('point',[0,-2]);
 var p = board.create('line',[A,B],{name: 'p',withLabel: true, color: 'green'});
 var C = board.create('glider', [4, 0, p]);
 var E = board.create('point', [1,4], {name: 'E',size:2, color: 'blue'});
 var q = board.create('line',[A,E],{name: 'q',withLabel: true, color: 'green'});
 var r = board.create('line',[B,E],{name: 'r',withLabel: true, color: 'green'});
&lt;/script&gt;
</code></pre>
<p>{lang=EN}
After this, we put the point <em>F</em> on <em>q</em>, somewhere between <em>A</em> and <em>E</em>, draw a line <em>s</em> passing through
points <em>C</em> and <em>F</em> and determine its intersection <em>G</em> with the line <em>r</em>:
{/lang}</p>
<p>{lang=CZ}
Poté umístíme na přímku <em>q</em> bod <em>F</em>, někam mezi body <em>A</em> a <em>E</em>, sestrojíme přímku <em>s</em> procházející body <em>C</em> a <em>F</em>
a určíme její průsečík <em>G</em> s přímkou <em>r</em>:
{/lang}</p>
<p>{lang=SI}
After this, we put the point <em>F</em> on <em>q</em>, somewhere between <em>A</em> and <em>E</em>, draw a line <em>s</em> passing through
points <em>C</em> and <em>F</em> and determine its intersection <em>G</em> with the line <em>r</em>:
{/lang}</p>
<p>{lang=DE}
Danach legen wir einen Punkt <em>F</em> auf die Gerade <em>q</em> (d.h. einen <em>glider</em>) irgendwo zwischen <em>A</em> und <em>E</em>,
ziehen eine Gerade <em>s</em> durch <em>C</em> und <em>F</em> und bestimmen ihren den Schnittpunkt <em>G</em> mit der Geraden <em>r</em>:
{/lang}</p>
<pre><code class="language-JS">&lt;div id=&quot;jxgbox&quot; class=&quot;jxgbox&quot; style=&quot;width:500px; height:400px;&quot;&gt;&lt;/div&gt;
&lt;script&gt;
 var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-5, 5, 5, -3]});
 var A = board.create('point',[-4,-2]);
 var B = board.create('point',[0,-2]);
 var p = board.create('line',[A,B],{name: 'p',withLabel: true, color: 'green'});
 var C = board.create('glider', [4, 0, p]);
 var E = board.create('point', [1,4], {name: 'E',size:2, color: 'blue'});
 var q = board.create('line',[A,E],{name: 'q',withLabel: true, color: 'green'});
 var r = board.create('line',[B,E],{name: 'r',withLabel: true, color: 'green'});
 var F = board.create('glider', [0,0,q], {name: 'F',size:2, color: 'blue'});
 var s = board.create('line',[C,F],{name: 's',withLabel: true, color: 'green'});
 var G = board.create('intersection', [s, r,0], {name: 'G',size:2, color: 'blue'});
&lt;/script&gt;
</code></pre>
<p>{lang=EN}
Finally, we draw lines <em>t=AG</em> and <em>u=BF</em>, denote <em>H</em> their point of intersection, construct
the line <em>v</em> passing points <em>H</em> and <em>E</em> and determine the desired point <em>D</em> as the intersection of lines <em>v</em> and <em>p</em>:
{/lang}</p>
<p>{lang=CZ}
Nakonec sestrojíme přímky <em>t=AG</em> a <em>u=BF</em>, určíme a označíme <em>H</em> jejich průsečík, sestrojíme přímku <em>v</em>
procházející body <em>H</em> a <em>E</em> a určíme hledaný bod <em>D</em> jako průsečík přímek <em>v</em> a <em>p</em>:
{/lang}</p>
<p>{lang=SI}
Finally, we draw lines <em>t=AG</em> and <em>u=BF</em>, denote <em>H</em> their point of intersection, construct
the line <em>v</em> passing points <em>H</em> and <em>E</em> and determine the desired point <em>D</em> as the intersection of lines <em>v</em> and <em>p</em>:
{/lang}</p>
<p>{lang=DE}
Schließlich, erzeugen wir die Geraden <em>t=AG</em> und <em>u=BF</em>, bezeichnen mit <em>H</em> ihren Schnittpunkt, konstruieren
die Gerade <em>v</em> durch die Punkte <em>H</em> und <em>E</em> und bestimmen den gewünschten Punkt <em>D</em> als den Schnittpunkt
der Geraden <em>v</em> und <em>p</em>:
{/lang}</p>
<pre><code class="language-JS">&lt;div id=&quot;jxgbox&quot; class=&quot;jxgbox&quot; style=&quot;width:500px; height:400px;&quot;&gt;&lt;/div&gt;
&lt;script&gt;
 var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-5, 5, 5, -3]});
 var A = board.create('point',[-4,-2]);
 var B = board.create('point',[0,-2]);
 var p = board.create('line',[A,B],{name: 'p',withLabel: true, color: 'green'});
 var C = board.create('glider', [4, 0, p]);
 var E = board.create('point', [1,4], {name: 'E',size:2, color: 'blue'});
 var q = board.create('line',[A,E],{name: 'q',withLabel: true, color: 'green'});
 var r = board.create('line',[B,E],{name: 'r',withLabel: true, color: 'green'});
 var F = board.create('glider', [0,0,q], {name: 'F',size:2, color: 'blue'});
 var s = board.create('line',[C,F],{name: 's',withLabel: true, color: 'green'});
 var G = board.create('intersection', [s, r,0], {name: 'G',size:2, color: 'blue'});
 var t = board.create('line',[A,G],{color: 'grey', dash:&quot;2&quot;});
 var u = board.create('line',[B,F],{color: 'grey', dash:&quot;2&quot;});
 var H = board.create('intersection', [t, u], {name: 'H',size:2, color: 'blue'});
 var v = board.create('line', [E,H],{color: 'grey', dash:&quot;2&quot;});
 var D = board.create('intersection', [p, v, 0]);
&lt;/script&gt;
</code></pre>
<p>{lang=EN}</p>
<h2><a class="header" href="#circles" id="circles">Circles</a></h2>
<p>In JSXGraph we don't have only points and lines. In this section we will learn about circles. They can be constructed
with different <a href="https://jsxgraph.org/docs/symbols/JXG.Circle.html#method">methods</a>, here we will present how to
create with two points and a point and a radius.
Let us now look at the example.
{/lang}</p>
<p>{lang=SI}##Circles{/lang}</p>
<p>{lang=CZ}</p>
<h2><a class="header" href="#kružnice" id="kružnice">Kružnice</a></h2>
<p>V JSXGraphu nemáme k dispozici jenom body a přímky. Jsou zde definovány ještě další objekty, se kterými se postupně seznámíme.
Tato kapitola pojednává o kružnicích. Ty mohou být sestrojeny různými <a href="https://jsxgraph.org/docs/symbols/JXG.Circle.html#method">metodami</a>.
Zaměříme se na dvě z nich, konstrukci kružnice dané dvěma body a konstrukci kružnice dané bodem a poloměrem.
Podívejme se na následující příklad:
{/lang}</p>
<p>{lang=DE}</p>
<h2><a class="header" href="#kreise" id="kreise">Kreise</a></h2>
<p>In JSXGraph haben wir nicht nur Punkte und Geraden zur Verfügung. In diesem Kapitel lernen wir Kreise kennen.
Sie können auf mehrere verschiedene <a href="https://jsxgraph.org/docs/symbols/JXG.Circle.html#method">Weisen</a> konstruiert werden.
Hier zeigen wir die Konstruktionen durch zwei Punkte und durch einen Punkt und einen Radius.
Betrachten wir ein Beispiel.
{/lang}</p>
<pre><code class="language-JS">&lt;div id=&quot;jxgbox&quot; class=&quot;jxgbox&quot; style=&quot;width:500px; height:200px;&quot;&gt;&lt;/div&gt;
&lt;script&gt;
 var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-5, 2, 5, -2],
     keepAspectRatio:true});

 var p = board.create('point',[-1,-1],{name:&quot;A&quot;});
 var q = board.create('point',[0,0],{name:&quot;B&quot;});

 var circle1 = board.create(&quot;circle&quot;,[p,q],{strokeColor:&quot;red&quot;, strokeWidth:4});
 var circle2 = board.create(&quot;circle&quot;,[&quot;B&quot;,1.8],{method:&quot;pointRadius&quot;, fillColor:&quot;gray&quot;,
     fillOpacity:0.2});
&lt;/script&gt;
</code></pre>
<div id="jxgbox" class="jxgbox" style="width:500px; height:200px;"></div>
<script>
 var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-5, 2, 5, -2],keepAspectRatio:true});
 var p = board.create('point',[-1,-1],{name:"A"});
 var q = board.create('point',[0,0],{name:"B"});
 var circle1 = board.create("circle",[p,q],{strokeColor:"red", strokeWidth:4});
 var circle2 = board.create("circle",["B",1.8],{method:"pointRadius", fillColor:"gray", fillOpacity:0.2});
</script>
<p>{lang=EN}
First what we notice is, that when we initialized the board with a new argument <code>keepAspectRatio:true</code> which we use
to tell JSXGraph that we want that html object and drawing board keep the aspect ratio between $x$ and $y$ axis. Setting this to
true is necessary if circles should look like circles and not like ellipses.</p>
<p>After creating both points we create two circles. <em>Circle1</em> is created with <code>var circle1 = board.create(&quot;circle&quot;,[p,q],{strokecolor:&quot;red&quot;, strokeWidth:4});</code>.
We can see, that here we created circle with two points which is default method for creating the circles. We used
two additional attributes which we used to set the color and width of the stroke. Color here was not defined with
RGB system, but with the <a href="https://en.wikipedia.org/wiki/Web_colors">color name</a>.</p>
<p><em>Circle2</em> is more interesting <code>var circle2 = board.create(&quot;circle&quot;,[&quot;B&quot;,1.5],{method:&quot;pointRadius&quot;, fillcolor:&quot;gray&quot;, fillopacity:0.2});</code>
since we created it with the point and radius method. We explicitly set this as a attribute.
Also instead of using variable name for the point, we used name of the point <code>&quot;B&quot;</code>, which can be very useful when having
many objects in the construction (and generating objects dynamically). We also used two attributes for filling the area of circle,
namely <em>fillColor</em> which defines the color of the fill and <em>fillOpacity</em> sets the opacity of the area (ranging from $0$ to $1$, where $1$ means solid color with no opacity).
{/lang}</p>
<p>{lang=SI}
First what we notice is, that when we initialized the board with a new argument <code>keepAspectRatio:true</code> which we use
to tell JSXGraph that we want that html object and drawing board keep the aspect ratio between $x$ and $y$ axis. Setting this to
true is necessary if circles should look like circles and not like ellipses.</p>
<p>After creating both points we create two circles. <em>Circle1</em> is created with <code>var circle1 = board.create(&quot;circle&quot;,[p,q],{strokecolor:&quot;red&quot;, strokeWidth:4});</code>.
We can see, that here we created circle with two points which is default method for creating the circles. We used
two additional attributes which we used to set the color and width of the stroke. Color here was not defined with
RGB system, but with the <a href="https://en.wikipedia.org/wiki/Web_colors">color name</a>.</p>
<p><em>Circle2</em> is more interesting <code>var circle2 = board.create(&quot;circle&quot;,[&quot;B&quot;,1.5],{method:&quot;pointRadius&quot;, fillcolor:&quot;gray&quot;, fillopacity:0.2});</code>
since we created it with the point and radius method. We explicitly set this as a attribute.
Also instead of using variable name for the point, we used name of the point <code>&quot;B&quot;</code>, which can be very useful when having
many objects in the construction (and generating objects dynamically). We also used two attributes for filling the area of circle,
namely <em>fillColor</em> which defines the color of the fill and <em>fillOpacity</em> sets the opacity of the area (ranging from $0$ to $1$, where $1$ means solid color with no opacity).
{/lang}</p>
<p>{lang=CZ}
Především je třeba zmínit, že jsme v příkazu pro inicializaci nákresny použili nový atribut <code>keepAspectRatio:true</code>, kterým
dáváme JSXGraphu pokyn, aby byl zachován poměr stran nákresny odpovídající rozsahům hodnot na osách $x$ a $y$.
Nastavení hodnoty <em>true</em> je nezbytné pro to, aby kružnice vypadaly v nákresně skutečně jako kružnice a ne jako elipsy.</p>
<p>Nyní k vlastní konstrukci kružnice. Kružnice <em>Circle1</em> je definována kódem <code>var circle1 = board.create(&quot;circle&quot;,[p,q],{strokecolor:&quot;red&quot;, strokeWidth:4});</code>,
kde <em>p</em>, <em>q</em> jsou dva body, které jí určují, <em>p</em> je střed kružnice a <em>q</em> je bod, kterým kružnice prochází. V definici jsou užity dva
atributy pro barvu a tloušťku čáry. Barva přitom není definována systémem RGB, ale jménem <a href="https://en.wikipedia.org/wiki/Web_colors">barvy</a>.</p>
<p>Kružnice <em>Circle2</em> je zajímavější, protože je dána středem a poloměrem. Definujeme ji kódem
<code>var circle2 = board.create(&quot;circle&quot;,[&quot;B&quot;,1.5],{method:&quot;pointRadius&quot;, fillcolor:&quot;gray&quot;, fillopacity:0.2});</code>
Tato metoda konstrukce kružnice musí být zadána explicitně formou atributu, na rozdíl od té předchozí, která je v JSXGraphu implicitní.
Také stojí za povšimnutí, že jsme v tomto kódu nepoužili jméno proměnné <em>q</em>, do které je bod uložen, ale přímo jméno &quot;B&quot; tohoto bodu.
Což může být velmi užitečné, když máme v konstrukci více objektů a když jsou objekty generovány dynamicky.</p>
<p>Použili jsme dva atributy pro vyplnění vnitřku kružnice (vytvoření kruhu), konkrétně <em>fillColor</em>, který definuje barvu
výplně a <em>fillOpacity</em>, kterým nastavíme neprůhlednost této plochy (kruhu)
(nabývá hodnot od $0$ do $1$, kde $1$ znamená jednobarevnou výplň bez průhlednosti).
{/lang}</p>
<p>{lang=DE}
Zuerst sehen wir, dass bei der Initialisierung der Zeichenfläche das neue Attribut <code>keepAspectRatio:true</code>
verwendet wurde um JSXGraph mitzuteilen, dass wir das Verhältnis zwischen $x$- und $y$-Achse im HTML-Objekt gleich haben wollen.
Dies ist notwendig, damit Kreise wie Kreise aussehen und nicht wie Ellipsen, falls das Verhältnis von Breite zu Höhe des HTML-Objektes
nicht dem verhältnis von Breite zu Höhe der <em>bounding box</em> entspricht.</p>
<p>Nach dem Anlegen zweier Punkte konstruieren wir zwei Kreise.
<em>Circle1</em> wird erzeugt durch <code>var circle1 = board.create(&quot;circle&quot;,[p,q],{strokecolor:&quot;red&quot;, strokeWidth:4});</code>.
Wir sehen, dass hier ein Kreis durch Angabe zweier Punkte erzeugt wird, was die Standardmethode zur Kreiserzeugung ist.
Dabei verwenden wir zwei weitere Attribute um die Farbe und Breite der Kreislinie zu setzen.
Die Farbe wird in diesem Fall nicht im RGB-System angegeben sondern durch einen <a href="https://en.wikipedia.org/wiki/Web_colors">Farbnamen</a>.</p>
<p><em>Circle2</em> ist noch interessanter: <code>var circle2 = board.create(&quot;circle&quot;,[&quot;B&quot;,1.5],{method:&quot;pointRadius&quot;, fillcolor:&quot;gray&quot;, fillopacity:0.2});</code>.
Dieser Kreise wird mit der Punkt-Radius-Methode erzeugt. Wir geben diese Methode explizit als Attribut an.
Das ist zwar nicht unbedingt nötig, aber sicher ist sicher.
Zudem - anstatt für den Mittelpunkt einen Variablennamen oder ein Koordinatenpaar anzugeben - verwenden wir den Namen des Punktes <code>&quot;B&quot;</code>,
was sehr nützlich sein kann, falls die Konstruktion sehr viele Objekte enthält (und Objekte dynamisch erzeugt werden).
Ausserdem verwenden wir zwei Attribute um die Kreisfläche zu färben: <em>fillColor</em> legt die Füllfarbe fest und <em>fillOpacity</em>
setzt die Durchsichtigkeit (Opacity) der Kreisfläche und nimmt Wert zwischen
$0$ und $1$ an, wobei $1$ undurchsichtig bedeutet.
{/lang}</p>
<p>{lang=EN}</p>
<h2><a class="header" href="#polygons" id="polygons">Polygons</a></h2>
<p>Polygons are very useful objects which can be used to construct a closed area with arbitrary many points (minimum is three).
Polygons can be convex or concave, depending on the input points. We can again define different <a href="https://jsxgraph.org/docs/symbols/Polygon.html">attributes</a>
to the object.</p>
<p>Example:
{/lang}</p>
<p>{lang=SI}</p>
<h2><a class="header" href="#polygons-1" id="polygons-1">Polygons</a></h2>
<p>{/lang}</p>
<p>{lang=CZ}</p>
<h2><a class="header" href="#mnohoúhelníky" id="mnohoúhelníky">Mnohoúhelníky</a></h2>
<p>Mnohoúhelníky jsou v geometrii velmi frekventované objekty. Můžeme je chápat jako části roviny ohraničené uzavřenou
lomenou čarou s libovolným počtem vrcholů (minimum jsou tři). Mnohoúhelník může být <em>konvexní</em> nebo <em>konkávní</em> (říkáme též <em>nekonvexní</em>),
v závislosti na rozložení určujících bodů (vrcholů). Stejně jako jiným objektům i mnohoúhelníkům můžeme přiřadit různé
<a href="https://jsxgraph.org/docs/symbols/Polygon.html">atributy</a>.</p>
<p>Příklad:
{/lang}</p>
<p>{lang=DE}</p>
<h2><a class="header" href="#polgyone" id="polgyone">Polgyone</a></h2>
<p>Polygone (Vielecke) sind sehr hilfreiche Objekte, die verwendet werden können um eine abgeschlossene
Fläche mit beliebig vielen Punkten (aber minimal drei) anzulegen.
Polygone können konvex sein, müssen es aber nicht sein. Dies ist abhängig von den definierenden Punkten.
Auch hier können wir mit verschiedenen <a href="https://jsxgraph.org/docs/symbols/Polygon.html">Attributen</a>
das Aussehen und Verhalten ändern.</p>
<p>Beispiel:
{/lang}</p>
<pre><code class="language-JS">&lt;div id=&quot;jxgbox&quot; class=&quot;jxgbox&quot; style=&quot;width:500px; height:200px;&quot;&gt;&lt;/div&gt;
&lt;script&gt;
 var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-5, 2, 5, -2],
     keepAspectRatio:true, showCopyright:false, showNavigation:false });

 var p = board.create('point',[-2,0],{name:&quot;A&quot;});
 var q = board.create('point',[-1,-1],{name:&quot;B&quot;});
 var r = board.create('point',[1,-0.5],{name:&quot;C&quot;});
 var s = board.create('point',[1,1],{name:&quot;D&quot;});
 var t = board.create('point',[-1,1.5],{name:&quot;E&quot;});

 var poly1 = board.create('polygon',[p,q,r,s,t],{name:&quot;Polygon 1&quot;,withLabel:true});

 var points = [[2,-1],[4,1],[1,1],[-1,-1]];
 var poly2 = board.create('polygon',points,{name:&quot;Polygon 2&quot;,withLabel:true,
     hasInnerPoints:true, withLines:false, vertices:{visible:false}});
&lt;/script&gt;
</code></pre>
<div id="jxgbox" class="jxgbox" style="width:500px; height:200px;"></div>
<script>
 var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-5, 2, 5, -2],keepAspectRatio:true, showCopyright:false, showNavigation:false });
 var p = board.create('point',[-2,0],{name:"A"});
 var q = board.create('point',[-1,-1],{name:"B"});
 var r = board.create('point',[1,-0.5],{name:"C"});
 var s = board.create('point',[1,1],{name:"D"});
 var t = board.create('point',[-1,1.5],{name:"E"});
 var poly1 = board.create('polygon',[p,q,r,s,t],{name:"Polygon 1",withLabel:true});
 var points = [[2,-1],[4,1],[1,1],[-1,-1]];
 var poly2 = board.create('polygon',points,{name:"Polygon 2",withLabel:true,hasInnerPoints:true, withLines:false, vertices:{visible:false}});
</script>
<p>{lang=EN}
As we mentioned earlier we need at least three points to make a polygon. In our example we created five points which then used
to create a polygon. We used an attribute <em>withLabel</em> which tells JSXGraph to show the name of the polygon.</p>
<p>For the second polygon we created a list of points, which is another approach to create a polygon. Here we again few new
attributes. Attribute <em>hasInnerPoints</em> enables user to move entire polygon. For example, moving Polygon 1 is not possible,
only its points can be moved. Adding this attribute will enable moving the polygon.
Next attribute, <em>withLines</em> tells JSXgraph whether to draw borders of the polygon or not. The last attribute <em>vertices</em> is
particularly interesting, because it does not have just a value, but a dictionary on the right side of <code>:</code>. The reason behind
is that we can control the vertices with more than one attribute.
{/lang}</p>
<p>{lang=SI}
As we mentioned earlier we need at least three points to make a polygon. In our example we created five points which then used
to create a polygon. We used an attribute <em>withLabel</em> which tells JSXGraph to show the name of the polygon.</p>
<p>For the second polygon we created a list of points, which is another approach to create a polygon. Here we again few new
attributes. Attribute <em>hasInnerPoints</em> enables user to move entire polygon. For example, moving Polygon 1 is not possible,
only its points can be moved. Adding this attribute will enable moving the polygon.
Next attribute, <em>withLines</em> tells JSXgraph whether to draw borders of the polygon or not. The last attribute <em>vertices</em> is
particularly interesting, because it does not have just a value, but a dictionary on the right side of <code>:</code>. The reason behind
is that we can control the vertices with more than one attribute.
{/lang}</p>
<p>{lang=CZ}
Jak je zřejmé z geometrické podstaty mnohoúhelníku, pro jeho vytvoření potřebujeme alespoň tři body.
V uvedeném příkladě jsme vytvořili pět bodů, které jsme pojmenovali <em>A</em>, <em>B</em>, <em>C</em>, <em>D</em>, <em>E</em> a použili jsme je
k určení prvního mnohoúhelníku, pětiúhelníku <em>ABCDE</em>. V jeho definici jsme použili atribut <em>withLabel</em> s hodnotou <em>true</em>, kterým
jsme zajistili zobrazení jména pětiúhelníku <em>Polygon 1</em>.</p>
<p>K určení druhého mnohoúhelníku, tentokrát se jedná o čtyřúhelník, jsme použili předem vytvořenou posloupnost vrcholů, což je
další přístup k definování mnohoúhelníku v JSXGraphu. V definici jsme použili několik dalších nových atributů.</p>
<p>Atribut <em>hasInnerPoints</em> přináší možnost pohybovat v nákresně s celým mnohoúhelníkem. Srovnejme s pětiúhelníkem <em>ABCDE</em> (<em>Polygon 1</em>),
který nemůžeme celý přemístit, můžeme pohybovat pouze s jeho jednotlivými vrcholy.</p>
<p>Další atribut, <em>withLines</em> je zodpovědný za to, zda se bude (implicitní nastavení, při použití atributu <em>withLines</em> hodnota <em>true</em>)
nebo nebude (atribut <em>withLines</em> s hodnotou <em>false</em>) kreslit hranice mnohoúhelníku.</p>
<p>Poslední atribut <em>vertices</em>, který se týká vrcholů mnohoúhelníku, je zajímavý tím, že mu za dvojtečkou <code>:</code> není přiřazena
jedna hodnota, ale seznam dalších atributů s jejich hodnotami. Důvodem je skutečnost, že výskyt vrcholů může být ovládán více atributy.
{/lang}</p>
<p>{lang=DE}
Wie breits erwähnt, benötigen wir mindestens drei Punkte zur Konstruktion eines Polygons.
In unserem Beispiel haben wir zuerst fünf Punkte angelegt, die dann unser Polgon definieren.
Wir haben zusätzlich das Attribut <em>withLabel:true</em> angegeben um den Namen des Polygons anzuzeigen.</p>
<p>Zur Konstruktion des zweite Polygons verwenden wir eine Liste von Koordinatenpaaren, sowie einige neue Attribute.
Das Attribut <em>hasInnerPoints</em> ermöglicht es dem Berachter, das gesamte Poylgon zu verschieben.
Im Gegensatz dazu kann Polygon 1 nicht komplett verschoben werden, lediglich einzele Punkte oder Kanten
können verzogen werden.
Das nächste Attribut <em>withLines</em> teilt JSXgraph mit, ob die Kanten / Ränder des Polygons angezeigt werden sollen oder nicht.
Das letzte Attribut <em>vertices</em> ist besonders interessant, denn es besitzt keinen einfachen Wert, sondern nach dem <code>:</code> folgt
ein eigenes Attribut-Object, das die Eigenschaften der Polygon-Ecken festlegt. Der Grund ist, dass wir für die Ecken
mehr als ein Attribut verändern wollen.
{/lang}</p>
<p>{lang=EN}</p>
<h2><a class="header" href="#example-regular-polygons" id="example-regular-polygons">Example: Regular polygons</a></h2>
<p><strong>A Hexagon-Triangle Hinge.</strong> In the diagram below, <em>Q</em> is the center of a regular hexagon with a vertex <em>B</em> at which it touches
an equilateral triangle with center <em>R</em>. Let <em>P</em> be the midpoint of <em>AG</em>. Show that <em>RPQ</em> is a right angle.</p>
<p>(Source: <em>Konhauser, J. D. E., Velleman, D., Wagon, S. Which Way Did the Bicycle Go? … and Other Intriguing Mathematical Mysteries.
The Mathematical association of America, Dolciani Mathematical Expositions – No. 18. 1996.</em>)
{/lang}</p>
<p>{lang=CZ}</p>
<h2><a class="header" href="#příklad-pravidelné-mnohoúhelníky" id="příklad-pravidelné-mnohoúhelníky">Příklad: Pravidelné mnohoúhelníky</a></h2>
<p><strong>Pravidelný šestiúhelník a rovnostranný trojúhelník se společným vrcholem.</strong> Na obrázku níže je bod <em>Q</em> středem 
pravidelného šestiúhelníku, který svůj vrchol <em>B</em> sdílí s rovnostranným trojúhelníkem, jehož středem je bod <em>R</em>. 
Středem úsečky <em>AG</em> je bod <em>P</em>. Dokažte, že úhel <em>RPQ</em> je pravý.</p>
<p>(Zdroj: <em>Konhauser, J. D. E., Velleman, D., Wagon, S. Which Way Did the Bicycle Go? … and Other Intriguing Mathematical Mysteries. 
The Mathematical association of America, Dolciani Mathematical Expositions – No. 18. 1996.</em>)
{/lang}</p>
<p>{lang=SI}</p>
<h2><a class="header" href="#example-regular-polygons-1" id="example-regular-polygons-1">Example: Regular polygons</a></h2>
<p><strong>A Hexagon-Triangle Hinge.</strong> In the diagram below, <em>Q</em> is the center of a regular hexagon with a vertex <em>B</em> at which it touches
an equilateral triangle with center <em>R</em>. Let <em>P</em> be the midpoint of <em>AG</em>. Show that <em>RPQ</em> is a right angle.</p>
<p>(Source: <em>Konhauser, J. D. E., Velleman, D., Wagon, S. Which Way Did the Bicycle Go? … and Other Intriguing Mathematical Mysteries. 
The Mathematical association of America, Dolciani Mathematical Expositions – No. 18. 1996.</em>)
{/lang}</p>
<p>{lang=DE}</p>
<h2><a class="header" href="#beispiel-reguläre-polygone" id="beispiel-reguläre-polygone">Beispiel: Reguläre Polygone</a></h2>
<p><strong>Ein Sechseck-Dreiecks-Gelenk.</strong>
In der folgenden Konstruktion sei <em>Q</em> der Mittelpunkt eines regulären Sechsecks, das eine Ecke <em>B</em> besitzt, mit der
es ein gleichseitiges Dreieck mit Mittelpunkt <em>R</em> berührt.
Zusätzlich sei <em>P</em> der Mittelpunkt der Strecke <em>AG</em>. Zeige, dass <em>RPQ</em> ein rechter Winkel ist.</p>
<p>(Quelle: <em>Konhauser, J. D. E., Velleman, D., Wagon, S. Which Way Did the Bicycle Go? … and Other Intriguing Mathematical Mysteries.
The Mathematical association of America, Dolciani Mathematical Expositions – No. 18. 1996.</em>)
{/lang}</p>
<div id="jxgbox" class="jxgbox" style="width:400px; height:300px;"></div>
<script>
    var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-4, 3, 4, -3]});
        board.options.label.autoPosition = true;
        board.options.point.size = 1;
	var A = board.create('point', [-1.2, -2], {color: 'orange', size: 4});
	var B = board.create('point', [0.25, -0.5], {color: 'orange', size: 4});
	var hexagon = board.create('regularpolygon', [A,B, 6]);
	var D = hexagon.vertices[3];
    var Q = board.create('circumcenter', [A, B, D], {name: 'Q'});
    var G = board.create('point', [3, -2], {name:'G', color: 'orange', size: 4});
    var rtr = board.create('regularpolygon', [B, G, 3]);
    var H = rtr.vertices[2];
    var R = board.create('circumcenter', [B, G, H], {name: 'R'});
    var tr = board.create('polygon', [A, G, B], {color: 'pink'});
    var P = board.create('midpoint', [A, G], {name: 'P'});
    var q = board.create('line', [P, Q], {name: 'q', withLabel: true});
    var r = board.create('line', [P, R], {name: 'r', withLabel: true});
    var angle = board.create('angle', [R, P, Q], {radius:0.4, color:'red', fillOpacity: 0, name:'&varphi;'});
    var text = board.create('text', [-3, -2.5,
                function () {return '&varphi; = ' + (angle.Value() * 180 / Math.PI).toFixed(2) + '&deg;';}
                    ]);
</script>
{lang=EN}
The solution to the example, i.e. proving the given statement, is left to the reader.
Here we will deal only with the programming of the illustrative dynamic figure.
{/lang}
<p>{lang=CZ}
Řešení příkladu, tj. důkaz uvedeného tvrzení, přenecháváme čtenáři. 
Zde se budeme věnovat pouze programování dynamického obrázku ilustrujícího daný problém. 
{/lang}</p>
<p>{lang=SI}
The solution to the example, i.e. proving the given statement, is left to the reader. 
Here we will deal only with the programming of the illustrative dynamic figure. 
{/lang}</p>
<p>{lang=DE}
Die Lösung der Aufgabe, d.h. den Beweis der Behauptung, sei dem Leser überlassen.
Hier wollen wir uns nur mit der Programmierung der erläuternden dynamischen Zeichnung widmen.
{/lang}</p>
<p>{lang=EN}
<em>Programming:</em></p>
<p>First, we define the Bounding box as follows:
{/lang}</p>
<p>{lang=CZ}
<em>Programování:</em></p>
<p>Nejprve musíme definovat parametry nákresny:
{/lang}</p>
<p>{lang=SI}
<em>Programming:</em></p>
<p>First, we define the Bounding box as follows:
{/lang}</p>
<p>{lang=SI}
<em>Programmierung:</em></p>
<p>Zuerst geben wir die <em>bounding box</em> wie folgt an:
{/lang}</p>
<pre><code class="language-JS">&lt;div id=&quot;jxgbox&quot; class=&quot;jxgbox&quot; style=&quot;width:400px; height:300px;&quot;&gt;&lt;/div&gt;
&lt;script&gt;
var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-4, 3, 4, -3]});
&lt;/script&gt;
</code></pre>
<p>{lang=EN}
There will be eleven points in the diagram, namely vertices of polygons, their centers and a midpoint.
To set their appearance we use two general options, as follows. First, to get the best possible positions
of their labels, with as few overlaps with image lines as possible, we use the <a href="https://jsxgraph.org/docs/symbols/Label.html#autoPosition"><code>autoPosition = true</code></a> option (it works in v1.1+):
{/lang}</p>
<p>{lang=CZ}
Obrázek obsahuje celkem jedenáct bodů spolu s jejich popisky, konkrétně se jedná o vrcholy mnohoúhelníků, jejich středy a střed úsečky <em>AG</em>.
Pro nastavení jejich zobrazení použijeme následující dvě obecné volby. Jednak, pro co nejlepší zobrazení popisků bodů, s minimem překryvů
s čarami obrázku, použijeme volbu <a href="https://jsxgraph.org/docs/symbols/Label.html#autoPosition"><code>autoPosition = true</code></a> (dostupná ve verzi v1.1+):
{/lang}</p>
<p>{lang=SI}
There will be eleven points in the diagram, namely vertices of polygons, their centers and a midpoint. 
To set their appearance we use two general options, as follows. First, to get the best possible positions 
of their labels, with as few overlaps with image lines as possible, we use the <a href="https://jsxgraph.org/docs/symbols/Label.html#autoPosition"><code>autoPosition = true</code></a> option (it works in v1.1+):
{/lang}</p>
<p>{lang=DE}
In der Zeichnung sind elf Punkte enthalten, nämlich die Ecken der Polygone, deren Mittelpunke und ein Strecken-Mittelpunkt.
Um ihr Aussehen festzulegen, setzen wir zwei Attribute für alle Elemente der Konstruktion.
Wir setzen <a href="https://jsxgraph.org/docs/symbols/Label.html#autoPosition"><code>autoPosition = true</code></a> um das Überlappen von Beschriftungen und
Strecken möglichst zu verhindern (ab Version 1.1.0).
{/lang}</p>
<pre><code class="language-JS">&lt;div id=&quot;jxgbox&quot; class=&quot;jxgbox&quot; style=&quot;width:400px; height:300px;&quot;&gt;&lt;/div&gt;
&lt;script&gt;
var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-4, 3, 4, -3]});
			board.options.label.autoPosition = true;
&lt;/script&gt;
</code></pre>
<p>{lang=EN}
Then, we set the basic point size to 1:
{/lang}</p>
<p>{lang=CZ}
Jednak nastavíme základní velikost bodů na 1:
{/lang}</p>
<p>{lang=SI}
Then, we set the basic point size to 1:
{/lang}</p>
<p>{lang=DE}
Ausserdem setzen wir die Standardgröße von Punkte auf den Wert 1:
{/lang}</p>
<pre><code class="language-JS">&lt;div id=&quot;jxgbox&quot; class=&quot;jxgbox&quot; style=&quot;width:400px; height:300px;&quot;&gt;&lt;/div&gt;
&lt;script&gt;
var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-4, 3, 4, -3]});
			board.options.label.autoPosition = true;
			board.options.point.size = 1;
&lt;/script&gt;
</code></pre>
<p>{lang=EN}
<em>Note:</em> In this way we can also set other common attributes of objects in the board,
for example the appearance of points using the command <code>board.options.point.face = '[]';</code> etc.
{/lang}</p>
<p>{lang=CZ}
<em>Poznámka:</em> Tímto způsebem můžeme nastavit další společné atributy objektů v nákresně, 
např. podobu symbolu bodu použitím příkazu <code>board.options.point.face = '[]';</code> atd.
{/lang}</p>
<p>{lang=SI}
<em>Note:</em> In this way we can also set other common attributes of objects in the board, 
for example the appearance of points using the command <code>board.options.point.face = '[]';</code> etc.
{/lang}</p>
<p>{lang=DE}
<em>Hinweis:</em> Auf diese Weise können auch andere Attribute für die gesamte Konstruktion vorbelegt werden, zum Beispiel
das Erscheinungsbild von Punkten mit dem Befehl <code>board.options.point.face = '[]';</code> etc.
{/lang}</p>
<p>{lang=EN}
To obtain the regular hexagon we first construct points <em>A</em> and <em>B</em>, its future two adjacent vertices,
and then color them orange to highlight them as movers:<br />
{/lang}</p>
<p>{lang=CZ}
Pro konstrukci pravidelného šestiúhelníku nejprve sestrojíme body <em>A</em> a <em>B</em>, jeho budoucí sousedící vrcholy, 
a obarvíme je oranžově, pro zdůraznění toho, že se jedná o volné body: 
{/lang}</p>
<p>{lang=SI}
To obtain the regular hexagon we first construct points <em>A</em> and <em>B</em>, its future two adjacent vertices, 
and then color them orange to highlight them as movers: 
{/lang}</p>
<p>{lang=DE}
Um ein reguläres Sechseck anzulegen, konstruieren wir zuerst die Punkte <em>A</em> und <em>B</em> als zwei nebeneinanderliegende Ecken des künftigen Sechsecks und färben diese orange um sie als beweglich / ziehbar zu markieren:
{/lang}</p>
<pre><code class="language-JS">&lt;div id=&quot;jxgbox&quot; class=&quot;jxgbox&quot; style=&quot;width:400px; height:300px;&quot;&gt;&lt;/div&gt;
&lt;script&gt;
var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-4, 3, 4, -3]});
			board.options.label.autoPosition = true;
			board.options.point.size = 1;
var A = board.create('point' , [-1.2,-2], {color:  'orange' , size: 4 });
var B = board.create('point',  [0.25,-0.5], {color:  'orange' , size: 4 });
&lt;/script&gt;
</code></pre>
<p>{lang=EN}
Then, using these points as the input parameters to the <a href="https://jsxgraph.org/docs/symbols/RegularPolygon.html">regularpolygon</a> object,
we create the desired hexagon:<br />
{/lang}</p>
<p>{lang=CZ}
Poté použijeme tyto body jako vstupní parametry objektu <a href="https://jsxgraph.org/docs/symbols/RegularPolygon.html">regularpolygon</a> pro vytvoření 
požadovaného šestiúhelníku:
{/lang}</p>
<p>{lang=SI}
Then, using these points as the input parameters to the <a href="https://jsxgraph.org/docs/symbols/RegularPolygon.html">regularpolygon</a> object, 
we create the desired hexagon:
{/lang}</p>
<p>{lang=DE}
Wir verwenden nun diese Punkte als Eingabeparameter für das <a href="https://jsxgraph.org/docs/symbols/RegularPolygon.html">regularpolygon</a>-Objekt,
um das gewünschte Sechseck anzulegen:<br />
{/lang}</p>
<pre><code class="language-JS">&lt;div id=&quot;jxgbox&quot; class=&quot;jxgbox&quot; style=&quot;width:400px; height:300px;&quot;&gt;&lt;/div&gt;
&lt;script&gt;
var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-4, 3, 4, -3]});
			board.options.label.autoPosition = true;
			board.options.point.size = 1;
var A = board.create('point' , [-1.2,-2], {color:  'orange' , size: 4 });
var B = board.create('point',  [0.25,-0.5], {color:  'orange' , size: 4 });
var hexagon = board.create('regularpolygon', [A,B, 6]);
&lt;/script&gt;
</code></pre>
<p>{lang=EN}
The center of the regular polygon is the center of its circumcircle, therefore we have to identify at least three vertices of the hexagon to determine its center. 
We chose <em>D</em>, the fourth vertex from <em>A</em> (index number is 3 because the software starts to count from 0)<br />
{/lang}</p>
<p>{lang=CZ}
Střed pravidelného šestiúhelníku je zároveň středem jemu opsané kružnice. Pro jeho určení proto potřebujeme
identifikovat alespoň tři vrcholy šestiúhelníku. 
K vrcholům <em>A</em> a <em>B</em> přidáme ještě bod <em>D</em>, v pořadí čtvrtý vrchol od <em>A</em> 
(protože program začíná indexovat od 0, je indexem tohoto vrcholu číslo 3)<br />
{/lang}</p>
<p>{lang=SI}
The center of the regular polygon is the center of its circumcircle, therefore we have to identify at least three vertices of the hexagon to determine its center.
We chose <em>D</em>, the fourth vertex from <em>A</em> (index number is 3 because the software starts to count from 0)<br />
{/lang}</p>
<p>{lang=DE}
Der Mittelpunkt des regulären Polygons ist der Mittelpunkt des Umkreises. Wir müssen daher auf mindestens drei Ecken des Sechsecks
zugreifen um seinen Mittelpunkt bestimmen zu können.
Wir wählen <em>D</em>, die vierte Ecke von <em>A</em> aus (diese Ecke hat den Index 3, weil die Software bei 0 zu zählen beginnt),
{/lang}</p>
<pre><code class="language-JS">&lt;div id=&quot;jxgbox&quot; class=&quot;jxgbox&quot; style=&quot;width:400px; height:300px;&quot;&gt;&lt;/div&gt;
&lt;script&gt;
var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-4, 3, 4, -3]});
			board.options.label.autoPosition = true;
			board.options.point.size = 1;
var A = board.create('point' , [-1.2,-2], {color:  'orange' , size: 4 });
var B = board.create('point',  [0.25,-0.5], {color:  'orange' , size: 4 });
var hexagon = board.create('regularpolygon', [A,B, 6]);
var D = hexagon.vertices[3];
&lt;/script&gt;
</code></pre>
<p>{lang=EN}
to determine the center <em>Q</em> of the regular hexagon as the center of the circumcircle to the triangle <em>ABD</em>:<br />
{/lang}</p>
<p>{lang=CZ}
pro určení středu pravidelného šestiúhelníku <em>Q</em> jako středu kružnice opsané trojúhelníku <em>ABD</em>:<br />
{/lang}</p>
<p>{lang=SI}
to determine the center <em>Q</em> of the regular hexagon as the center of the circumcircle to the triangle <em>ABD</em>:
{/lang}</p>
<p>{lang=DE}
um den Mittelpunkt <em>Q</em> des regulären Sechsecks als Mittelpunkt des Umkreises des Dreiecks <em>ABD</em> zu bestimmen:
{/lang}</p>
<pre><code class="language-JS">&lt;div id=&quot;jxgbox&quot; class=&quot;jxgbox&quot; style=&quot;width:400px; height:300px;&quot;&gt;&lt;/div&gt;
&lt;script&gt;
var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-4, 3, 4, -3]});
			board.options.label.autoPosition = true;
			board.options.point.size = 1;
var A = board.create('point' , [-1.2,-2], {color:  'orange' , size: 4 });
var B = board.create('point',  [0.25,-0.5], {color:  'orange' , size: 4 });
var hexagon = board.create('regularpolygon', [A,B, 6]);
var D = hexagon.vertices[3];
var Q = board.create('circumcenter',  [A, B, D], {name:'Q'});
&lt;/script&gt;
</code></pre>
<p>{lang=EN}
In an analogous way, we then create an equilateral triangle <em>BGH</em> with center <em>N</em>:<br />
{/lang}</p>
<p>{lang=CZ}
Analogicky sestrojíme rovnostranný trojúhelník <em>BGH</em> se středem <em>N</em>:<br />
{/lang}</p>
<p>{lang=SI}
In an analogous way, we then create an equilateral triangle <em>BGH</em> with center <em>N</em>:<br />
{/lang}</p>
<p>{lang=DE}
Genauso können wir das gleichseitige Dreieck <em>BGH</em> mit Mittelpunkt <em>N</em> konstruieren:
{/lang}</p>
<pre><code class="language-JS">&lt;div id=&quot;jxgbox&quot; class=&quot;jxgbox&quot; style=&quot;width:400px; height:300px;&quot;&gt;&lt;/div&gt;
&lt;script&gt;
var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-4, 3, 4, -3]});
			board.options.label.autoPosition = true;
			board.options.point.size = 1;
var A = board.create('point' , [-1.2,-2], {color:  'orange' , size: 4 });
var B = board.create('point',  [0.25,-0.5], {color:  'orange' , size: 4 });
var hexagon = board.create('regularpolygon', [A,B, 6]);
var D = hexagon.vertices[3];
var Q = board.create('circumcenter',  [A, B, D], {name:'Q'});
var G = board.create('point', [3,-2],  {name: 'G', color: 'orange' , size: 4 });
var rtr = board.create('regularpolygon',  [B, G, 3]);
var R = board.create('circumcenter',  [B, G, H], {name: 'R'});
&lt;/script&gt;
</code></pre>
<p>{lang=EN}
Then, we add the triangle <em>AGB</em>, the midpoint <em>P</em> of its side <em>AB</em> and the lines <em>PQ</em> and <em>PR</em>,
which we have to prove are always perpendicular:<br />
{/lang}</p>
<p>{lang=CZ}
Nakonec doplníme trojúhelník <em>AGB</em>, střed jeho strany <em>AB</em> bod <em>P</em> a přímky <em>PQ</em> a <em>PR</em>, 
jejichž kolmost je předmětem důkazu: 
{/lang}</p>
<p>{lang=SI}
Then, we add the triangle <em>AGB</em>, the midpoint <em>P</em> of its side <em>AB</em> and the lines <em>PQ</em> and <em>PR</em>, 
which we have to prove are always perpendicular:<br />
{/lang}</p>
<p>{lang=DE}
Dann legen wir das Dreieck <em>AGB</em>, den Mittelpunkt <em>P</em> seiner Seite <em>AB</em> und die Geraden <em>PQ</em> und <em>PR</em> an,
für die zu beweisen ist, dass sie immer aufeinander senkrecht stehen.
{/lang}</p>
<pre><code class="language-JS">&lt;div id=&quot;jxgbox&quot; class=&quot;jxgbox&quot; style=&quot;width:400px; height:300px;&quot;&gt;&lt;/div&gt;
&lt;script&gt;
var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-4, 3, 4, -3]});
			board.options.label.autoPosition = true;
			board.options.point.size = 1;
var A = board.create('point' , [-1.2,-2], {color:  'orange' , size: 4 });
var B = board.create('point',  [0.25,-0.5], {color:  'orange' , size: 4 });
var hexagon = board.create('regularpolygon', [A,B, 6]);
var D = hexagon.vertices[3];
var Q = board.create('circumcenter',  [A, B, D], {name:'Q'});
var G = board.create('point', [3,-2],  {name: 'G', color: 'orange' , size: 4 });
var rtr = board.create('regularpolygon',  [B, G, 3]);
var R = board.create('circumcenter',  [B, G, H], {name: 'R'});
var tr = board.create('polygon',  [A, G, B], {color: 'pink'});
var P = board.create('midpoint', [A, G], {name: 'P'});
var H = rtr.vertices[2];
var q = board.create('line', [P, Q], {name: 'q', withLabel: true});
var r = board.create('line', [P, R], {name: 'r', withLabel: true});
&lt;/script&gt;
</code></pre>
<p>{lang=EN}
Finally, we can identify the angle <em>RPQ</em>, the rightness of which we have to prove.
JSXGraph recognizes it as a right angle, so it marks it accordingly, as can be seen in figure above:<br />
{/lang}</p>
<p>{lang=CZ}
Nakonec můžeme zobrazit předmětný úhel <em>RPQ</em>. JSXGraph ho identifikuje jako pravý úhel a proto ho příslušným způsobem označí,
jak vidíme na obrázku výše:<br />
{/lang}</p>
<p>{lang=SI}
Finally, we can identify the angle <em>RPQ</em>, the rightness of which we have to prove. 
JSXGraph recognizes it as a right angle, so it marks it accordingly, as can be seen in figure belaboveow:
{/lang}</p>
<p>{lang=DE}
Schließlich zeichnen wir den Winkel <em>RPQ</em>, für den zu zeigen ist, dass es sich immer um einen rechten Winkel handelt.
JSXGraph erkennt ihn als rechten Winkel, deshalb wird er dementsprechend mit einem kleinen Quadrat
kennzeichnet, wie in der obigen Zeichnung zu sehen ist.
{/lang}</p>
<pre><code class="language-JS">&lt;div id=&quot;jxgbox&quot; class=&quot;jxgbox&quot; style=&quot;width:400px; height:300px;&quot;&gt;&lt;/div&gt;
&lt;script&gt;
var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-4, 3, 4, -3]});
			board.options.label.autoPosition = true;
			board.options.point.size = 1;
var A = board.create('point' , [-1.2,-2], {color:  'orange' , size: 4 });
var B = board.create('point',  [0.25,-0.5], {color:  'orange' , size: 4 });
var hexagon = board.create('regularpolygon', [A,B, 6]);
var D = hexagon.vertices[3];
var Q = board.create('circumcenter',  [A, B, D], {name:'Q'});
var G = board.create('point', [3,-2],  {name: 'G', color: 'orange' , size: 4 });
var rtr = board.create('regularpolygon',  [B, G, 3]);
var R = board.create('circumcenter',  [B, G, H], {name: 'R'});
var tr = board.create('polygon',  [A, G, B], {color: 'pink'});
var P = board.create('midpoint', [A, G], {name: 'P'});
var H = rtr.vertices[2];
var q = board.create('line', [P, Q], {name: 'q', withLabel: true});
var r = board.create('line', [P, R], {name: 'r', withLabel: true});
var angle = board.create('angle', [R, P, Q], {radius: 0.4, color: 'red', fillOpacity: 0 , name:'&amp;varphi;' });
&lt;/script&gt;
</code></pre>
<p>{lang=EN}
If this symbolic expression of the right angle is not enough for us, 
we can enter the code to display the size of the respective angle: 
{/lang}</p>
<p>{lang=CZ}
Pokud nám takovéto symbolické vyznačení pravého úhlu nepostačuje, můžeme použít následující kód pro zobrazení
číselné hodnoty jeho velikosti:<br />
{/lang}</p>
<p>{lang=SI}
If this symbolic expression of the right angle is not enough for us,
we can enter the code to display the size of the respective angle:<br />
{/lang}</p>
<p>{lang=DE}
Falls die symbolische Kennzeichnung des rechten Winkels noch nicht deutlich genug ist,
können wir noch den Programmcode eingeben um den Wert des Winkels auszugeben:
{/lang}</p>
<pre><code class="language-JS">&lt;div id=&quot;jxgbox&quot; class=&quot;jxgbox&quot; style=&quot;width:400px; height:300px;&quot;&gt;&lt;/div&gt;
&lt;script&gt;
var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-4, 3, 4, -3]});
			board.options.label.autoPosition = true;
			board.options.point.size = 1;
var A = board.create('point' , [-1.2,-2], {color:  'orange' , size: 4 });
var B = board.create('point',  [0.25,-0.5], {color:  'orange' , size: 4 });
var hexagon = board.create('regularpolygon', [A,B, 6]);
var D = hexagon.vertices[3];
var Q = board.create('circumcenter',  [A, B, D], {name:'Q'});
var G = board.create('point', [3,-2],  {name: 'G', color: 'orange' , size: 4 });
var rtr = board.create('regularpolygon',  [B, G, 3]);
var R = board.create('circumcenter',  [B, G, H], {name: 'R'});
var tr = board.create('polygon',  [A, G, B], {color: 'pink'});
var P = board.create('midpoint', [A, G], {name: 'P'});
var H = rtr.vertices[2];
var q = board.create('line', [P, Q], {name: 'q', withLabel: true});
var r = board.create('line', [P, R], {name: 'r', withLabel: true});
var angle = board.create('angle', [R, P, Q], {radius: 0.4, color: 'red', fillOpacity: 0 , name:'&amp;varphi;' });
			board.create('text', [-3, -3, 
				function () {return '&amp;theta;_1 = ' + (arc2.Value() * 180 /Math.PI).toFixed(1) + '&amp;deg;';}
				]); 
&lt;/script&gt;
</code></pre>
<p>{lang=EN}
The task solution code is now complete.
{/lang}</p>
<p>{lang=CZ}
Kód uvedeného dynamického obrázku je nyní kompletní.
{/lang}</p>
<p>{lang=SI}
The task solution code is now complete.
{/lang}</p>
<p>{lang=DE}
Damit ist die Zeichnung fertiggestellt.
{/lang}</p>
<p>{lang=EN}</p>
<h2><a class="header" href="#intersections" id="intersections">Intersections</a></h2>
<p>Sometimes we want to distinguish some intersections of our objects (lines and circles). Usually we have to compute the
intersections, but JSXGraph has very convenient objects <a href="https://jsxgraph.org/docs/symbols/Intersection.html"><em>Intersection</em></a>
which we can use, to do just that. In order to create an intersection, we need to use two lines, two circles or mix of them.
We cannot use other objects to create this object.
{/lang}</p>
<p>{lang=SI}</p>
<h2><a class="header" href="#intersections-1" id="intersections-1">Intersections</a></h2>
<p>{/lang}</p>
<p>{lang=CZ}</p>
<h2><a class="header" href="#průsečíky" id="průsečíky">Průsečíky</a></h2>
<p>Pro určení průsečíků přímek a kružnic můžeme v JSXGraphu použít přímo objekt
<a href="https://jsxgraph.org/docs/symbols/Intersection.html"><em>Intersection</em></a> (<em>průsečík</em>), nemusíme tyto průsečíky počítat.
Pro jeho zadání potřebujeme dvě  přímky, dvě kružnice nebo jednu přímku a jednu kružnici. Jiné objekty pro určení jejich průsečíku
nelze použít.</p>
<p>{/lang}</p>
<p>{lang=DE}</p>
<h2><a class="header" href="#schnittpunkte" id="schnittpunkte">Schnittpunkte</a></h2>
<p>Hin und wieder wollen wir einige Schnittpunkte unserer Objekte (Geraden und Kreise) auszeichnen.
Normalerweise müssten wir die Schnittpunkte berechnen, aber JSXGraph stellt das sehr komfortable Objekt
<a href="https://jsxgraph.org/docs/symbols/Intersection.html"><em>Intersection</em></a> dafür bereit.
Um einen Schnittpunkt zu erzeugen, benötigen wir zwei Geraden / oder Strecken, zwei Kreise oder eine Mischung der beiden.
Andere Objekte können dafür nicht verwendet werden.
{/lang}</p>
<pre><code class="language-JS">&lt;div id=&quot;jxgbox&quot; class=&quot;jxgbox&quot; style=&quot;width:500px; height:200px;&quot;&gt;&lt;/div&gt;
&lt;script&gt;
 var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-5, 2, 5, -2],keepAspectRatio:true, showCopyright:false, showNavigation:false });
 var p = board.create('point',[-2,0],{name:&quot;A&quot;});
 var q = board.create('point',[-1,-1],{name:&quot;B&quot;, visible:false});
 var r = board.create('point',[0,0],{name:&quot;C&quot;});
 var circle1 = board.create('circle', [p,q]);
 var circle2 = board.create('circle', [r,p]);
 var inter1 = board.create('intersection',[circle1,circle2,0],{name:'I_1'});
 var inter2 = board.create('intersection',[circle1,circle2,1],{name:'I_2'});
 var line = board.create('line',[inter1,inter2]);
&lt;/script&gt;
</code></pre>
<div id="jxgbox" class="jxgbox" style="width:500px; height:200px;"></div>
<script>
 var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-5, 2, 5, -2],keepAspectRatio:true, showCopyright:false, showNavigation:false });
 var p = board.create('point',[-2,0],{name:"A"});
 var q = board.create('point',[-1,-1],{name:"B", visible:false});
 var r = board.create('point',[0,0],{name:"C"});
 var circle1 = board.create('circle', [p,q]);
 var circle2 = board.create('circle', [r,p]);
 var inter1 = board.create('intersection',[circle1,circle2,0],{name:'I_1'});
 var inter2 = board.create('intersection',[circle1,circle2,1],{name:'I_2'});
 var line = board.create('line',[inter1,inter2]);
</script>
<p>{lang=EN}
After we created points and two circles, we created two objects - <em>intersections</em>.</p>
<p>In <code>var inter1 = board.create('intersection',[circle1,circle2,0],{name:'I_1'});</code> we used a third argument <code>0</code> which we use
in the case if there are two intersecting points and we decide which intersection we will use (with $0$ and $1$).
Notice that in <code>{name:'I_2'})</code> we used underscore in the name.
This is <a href="https://www.mathjax.org/">$LATEX$</a> notation and can be used for the labels to typeset beautiful math.</p>
<p>As last we created new line <code>var line = board.create('line',[inter1,inter2]);</code>
with the intersection objects. We can therefore use newly created objects as regular points in our constructions.
{/lang}</p>
<p>{lang=SI}</p>
<p>{/lang}</p>
<p>{lang=CZ}
Po vytvoření bodů a dvou kružnic jsme definovali dva objekty typu průsečík - <em>intersections</em>.</p>
<p>V kódu <code>var inter1 = board.create('intersection',[circle1,circle2,0],{name:'I_1'});</code> jsme použili za výčtem dvou kružnic třetí
argument, zde konkrétně s hodnotou <code>0</code>, který zadáváme v případě, že objekty mají dva průsečíky a my chceme ovlivnit, který
z nich použijeme (uvedením $0$ nebo $1$).
Za povšimnutí stojí, že jsme v atributu <code>{name:'I_2'})</code> použili ve jménu symbol podtržítka pro zápis dolního indexu.
Jedná se o syntaxi typografického systému <a href="https://www.mathjax.org/">$LATEX$</a>, která může být v JSXGraphu použita při zápisu
jmenovek pro dosažení lépe vypadajícího matematického zápisu.</p>
<p>Nakonec jsme definovali novou přímku <code>var line = board.create('line',[inter1,inter2]);</code>
procházející získanými průsečíky. Z toho je vidět, jak můžeme nově získané objekty hned použít jako určující body pro další konstrukci.</p>
<p>{/lang}</p>
<p>{lang=DE}
Nachdem wir zwei Punkte und zwei Kreise angelegt haben, können wir zwei <em>intersection</em>-Objekte erzeugen.</p>
<p>In <code>var inter1 = board.create('intersection',[circle1,circle2,0],{name:'I_1'});</code> haben wir als dritte Argument
<code>0</code> angegeben. Das ist von Bedeutung, wenn durch den Schnitt zweier Objekte zwei Schnittpunkte existieren und wir festlegen wollen,
welchen wir verwenden (durch Angabe der Werte $0$ und $1$).
Beachte, in der Angabe <code>{name:'I_2'})</code> wurde ein Unterstrich verwendet.
Das ist <a href="https://www.mathjax.org/">$LATEX$</a>-Notation und kann bei Bezeichner eingestzt werden um schöne Mathematik-Formelschreibweise zu erzeugen.</p>
<p>{lang=EN}</p>
<h2><a class="header" href="#angles" id="angles">Angles</a></h2>
<p>When we need to emphasise some angle in our construction, we can do this with object <a href="https://jsxgraph.org/docs/symbols/Angle.html"><em>Angle</em></a>.
As an input we need to provide three points $p1, p2, p3$ and the angle is drawn counterclockwise from $p1$ to $p3$ around $p2$.
Other combinations include two lines and two directions (by +/- 1) or line and two coordinates.
{/lang}</p>
<p>{lang=SI}</p>
<h2><a class="header" href="#angles-1" id="angles-1">Angles</a></h2>
<p>{/lang}</p>
<p>{lang=CZ}</p>
<h2><a class="header" href="#Úhly" id="Úhly">Úhly</a></h2>
<p>Pro zvýraznění konkrétních úhlů v konstrukci nabízí JSXGraph objekt <a href="https://jsxgraph.org/docs/symbols/Angle.html"><em>Angle</em></a> (<em>Úhel</em>).
Jako vstupní údaje je třeba zadat tři body $p1, p2, p3$, úhel je pak vykreslen v kladném smyslu (tj. proti směru pohybu hodinových ručiček)
od bodu $p1$ (bod na počátečním rameni) do bodu $p3$ (bod na koncovém rameni), kolem $p2$ (vrchol).</p>
<p>Dalšími možnostmi zadání vstupních údajů pro zobrazení úhlu jsou <em>dvě přímky a dva směry (ve tvaru +/- 1)</em> nebo <em>dvě přímky a dva body</em>
(kolmý průmět každého z těchto bodů na jemu příslušnou přímku, dle pořadí v zápisu, určuje polopřímku, která je ramenem úhlu).
{/lang}</p>
<p>{lang=DE}</p>
<h2><a class="header" href="#winkel" id="winkel">Winkel</a></h2>
<p>Wenn Winkel in unserer Konstruktion gekennzeichnet werden sollen, kann dies mit dem Objekt
<a href="https://jsxgraph.org/docs/symbols/Angle.html"><em>Angle</em></a> bewerkstelligt werden.
Als Eingabe müssen wir drei Punkte $p1, p2, p3$ bereitstellen. Der Winkel wird dann gegen den Uhrzeigersinn
von $p1$ nach $p3$ um $p2 markiert.</p>
<p>Andere Möglichkeiten sind, zwei Geraden und eine Richtung (mit +/-1) oder eine Gerade und zwei Koordinaten zu verwenden.
{/lang}</p>
<pre><code class="language-JS">&lt;div id=&quot;jxgbox&quot; class=&quot;jxgbox&quot; style=&quot;width:500px; height:200px;&quot;&gt;&lt;/div&gt;
&lt;script&gt;
 var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-5, 2, 5, -2],keepAspectRatio:true, showCopyright:false, showNavigation:false });
 var p = board.create('point',[-2,0],{name:&quot;A&quot;});
 var q = board.create('point',[1,1.5],{name:&quot;B&quot;});
 var r = board.create('point',[1,-1],{name:&quot;C&quot;});
 var line1 = board.create('line',[p,q]);
 var line2 = board.create('line',[p,r]);
 var angle1 = board.create('angle',[&quot;C&quot;, &quot;A&quot;, &quot;B&quot;], {radius:2});
 var angle2 = board.create('angle',[line2,line1,-1,-1], {radius:1,color:'green'});
 var angle3 = board.create('angle',[line2,line1,1,1], {radius:1,color:'blue'});
&lt;/script&gt;
</code></pre>
<div id="jxgbox" class="jxgbox" style="width:500px; height:200px;"></div>
<script>
 var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-5, 2, 5, -2],keepAspectRatio:true, showCopyright:false, showNavigation:false });
 var p = board.create('point',[-2,0],{name:"A", fixed:true});
 var q = board.create('point',[1,1.5],{name:"B"});
 var r = board.create('point',[1,-1],{name:"C"});
 var line1 = board.create('line',[p,q]);
 var line2 = board.create('line',[p,r]);
 var angle1 = board.create('angle',["C", "A", "B"], {radius:2});
 var angle2 = board.create('angle',[line2,line1,-1,-1], {radius:1,color:'green'});
 var angle3 = board.create('angle',[line2,line1,1,1], {radius:1,color:'blue'});
</script>
<p>{lang=EN}</p>
<p>In this example we first created three points and then through them created two lines with common/intersection point $A$.</p>
<p>Then we created first angle with <code>var angle = board.create('angle',[r, p, q], {radius:2});</code> using three points. Remember,
when defining angle with three points we have to provide them in counterclockwise order, where the angle is centered by the second point. Additionaly, we set an attribute
<em>radius</em> to $2$, which tells JSXGraph how big the arc of an angle should be.</p>
<p>Then the second angle $\beta$ was created using two lines and two directions (+/- 1) with following line
<code>var angle2 = board.create('angle',[line2,line1,-1,-1], {radius:1,color:'green'});</code>. This line presents another possible
method to input the parameters of an angle. We can combine them differently to get different angles at the intersection point $A$.</p>
<p>Last angle is only a variation of <code>angle2</code> which different directions and as a result we can see that <code>angle1</code> and <code>angle3</code>
describe the same angle but with different input parameters.
{/lang}</p>
<p>{lang=SI}
In this example we first created three points and then through them created two lines with common/intersection point $A$. </p>
<p>Then we created first angle with <code>var angle = board.create('angle',[r, p, q], {radius:2});</code> using three points. Remember, 
when defining angle with three points we have to provide them in counterclockwise order, where the angle is centered by the second point. Additionaly, we set an attribute
<em>radius</em> to $2$, which tells JSXGraph how big the arc of an angle should be. </p>
<p>Then the second angle $\beta$ was created using two lines and two directions (+/- 1) with following line
<code>var angle2 = board.create('angle',[line2,line1,-1,-1], {radius:1,color:'green'});</code>. This line presents another possible 
method to input the parameters of an angle. We can combine them differently to get different angles at the intersection point $A$.</p>
<p>Last angle is only a variation of <code>angle2</code> which different directions and as a result we can see that <code>angle1</code> and <code>angle3</code> 
describe the same angle but with different input parameters.</p>
<p>{/lang}</p>
<p>{lang=CZ}
Nejprve jsme vytvořili tři body <em>A</em>, <em>B</em>, <em>C</em> a jimi určené dvě přímky se společným bodem $A$. </p>
<p>První úhel (programem označený jako $\alpha$) jsme definovali pomocí těchto tří bodů. Zapsali jsme ho kódem  <code>var angle1 = board.create('angle',[&quot;C&quot;, &quot;A&quot;, &quot;B&quot;], {radius:2});</code>
K pořadí uvedení bodů připomeňme, že úhel zadáváme třemi body ve směru proti pohybu hodinových ručiček, 
přitom jako prostřední uvádíme vrchol úhlu. Nakonec jsme uvedli atribut poloměru oblouku úhlu <em>radius</em> s hodnotou $2$,
abychom JSXGraphu sdělili, jak velkým obloukem má úhel vykreslit. </p>
<p>Kódem <code>var angle2 = board.create('angle',[line2,line1,-1,-1], {radius:1,color:'green'});</code> byl vytvořen druhý úhel $\beta$, 
užitím dvou přímek a stanovením směrů (+/- 1) jeho ramen, která na těchto přímkách leží. 
Jedná se o další možnost zadání úhlu. Různými kombinacemi hodnot (+/- 1) směrů můžeme vyjádřit všechny možné 
úhly s vrcholem v $A$.</p>
<p>Poslední úhel $\gamma$ je pouhou variací předchozího úhlu $\beta$ (též <code>angle2</code>) získanou právě změnou směrů ramen. Vidíme tak,
že proměnné <code>angle1</code> a <code>angle3</code> popisují stejný úhel, avšak s použitím různých vstupních údajů.</p>
<p>{/lang}</p>
<p>{lang=DE}
In diesem Beispiel werden zuerst drei Punkte angelegt, sowie zwei Geraden durch diese Punkte mit gemeinsamen Punkt $A$.</p>
<p>Der erste Winkel wird mittels
<code>var angle = board.create('angle',[r, p, q], {radius:2});</code> unter Verwendung der drei Punkte gezeichnet.
Wir erinnern uns, bei der Definition des Winkels durch drei Punkte werden diese gegen den Uhrzeigersinn angegeben, wobei der
Winkel um den zweiten Punkt verläuft.
Zusätzlich setzen wir das Attribut <em>radius</em> auf $2$, was JSXGraph anweist, wie groß der Kreisbogen eines Winkels sein soll.</p>
<p>Der zweite Winkel $\beta$ wird durch Angabe zweier Geraden und zweier Richtungen (+/- 1) angelegt:
<code>var angle2 = board.create('angle',[line2,line1,-1,-1], {radius:1,color:'green'});</code>.
Durch die Kombinationen der Richtungen können wir die vier verschiedenen Winkel der beiden Geraden kennzeichnen.</p>
<p>Der dritte Winkel ist eine Variation von <code>angle2</code> mit anderen Richtungen mit dem Resultat, dass <code>angle1</code> und <code>angle3</code>
den gleichen Winkel kennzeichnen, aber unterschiedliche Eingabeparameter verwenden.
{/lang}</p>
<p>{lang=EN}</p>
<h2><a class="header" href="#curves" id="curves">Curves</a></h2>
<p><a href="https://jsxgraph.org/docs/symbols/Curve.html">Curves</a> in JSXGraph does not mean just curves from functions
or polynomials, but also parametric curves, polar curves or data plots. In our example we will show how to use data
for data plotting, for other uses please check API documentation.
{/lang}</p>
<p>{lang=SI}</p>
<h2><a class="header" href="#curves-1" id="curves-1">Curves</a></h2>
<p>{/lang}</p>
<p>{lang=CZ}</p>
<h2><a class="header" href="#křivky" id="křivky">Křivky</a></h2>
<p>Objekt <em>křivka</em> (<a href="https://jsxgraph.org/docs/symbols/Curve.html">Curve</a>) v JSXGraphu nezahrnuje jenom
grafy funkcí nebo polynomů, ale také parametrické křivky, křivky definované v polárních souřadnicích nebo různé grafické
reprezentace dat. Následujícím příkladem ilustrujeme užití objektu <em>Curve</em> ke grafické reprezentaci dat. Další možnosti
tohoto objektu viz <a href="https://jsxgraph.org/docs/symbols/Curve.html">JSXGraph Reference</a>.
{/lang}</p>
<p>{lang=DE}</p>
<h2><a class="header" href="#kurven" id="kurven">Kurven</a></h2>
<p><a href="https://jsxgraph.org/docs/symbols/Curve.html">Kurven</a> in JSXGraph umfassen nicht nur Graphen von Funktionstermen
oder Polynomen, sondern auch parametrische Kurven, Polarkurven oder Datenplots.
In unserem Beispiel zeigen wir wie Datenplots erzeugt werden können, für die anderen Kurventypen verweisen wir auf die
API-Dokumentation.
{/lang}</p>
<pre><code class="language-JS">&lt;div id=&quot;jxgbox&quot; class=&quot;jxgbox&quot; style=&quot;width:500px; height:200px;&quot;&gt;&lt;/div&gt;
&lt;script&gt;
 var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-1, 10, 11, -2], axis:true, showCopyright:false, showNavigation:false });
 var x = [1,2,3,4,5,6,7,8,9,10];
 var y = [8.4,1,0.1,9,3.3,3.3,4.5,8,9,4];
 var curve = board.create('curve',[x,y],{curveType:'plot'});
&lt;/script&gt;
</code></pre>
<div id="jxgbox" class="jxgbox" style="width:500px; height:200px;"></div>
<script>
 var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-1, 10, 11, -2], axis:true, showCopyright:false, showNavigation:false });
 var x = [1,2,3,4,5,6,7,8,9,10];
 var y = [8.4,1,0.1,9,3.3,3.3,4.5,8,9,4];
 var curve = board.create('curve',[x,y],{curveType:'plot'});
</script>
<p>{lang=EN}
In this example we had to change the bounding box of the board in order to accommodate the data. Otherwise not all points
will be visible.</p>
<p>To draw a data plot we need first two lists of data. In our case we used two lists <code>x</code> and <code>y</code> and filled them with numbers.
But is not the only way how to obtain the data (e.g. see this <a href="https://jsxgraph.org/wiki/index.php/Data_plot">example</a>).
As last we had to set the type of curve using attribute <a href="https://jsxgraph.org/docs/symbols/Curve.html#curveType"><em>curveType</em></a>.
{/lang}</p>
<p>{lang=SI}
In this example we had to change the bounding box of the board in order to accommodate the data. Otherwise not all points
will be visible.</p>
<p>To draw a data plot we need first two lists of data. In our case we used two lists <code>x</code> and <code>y</code> and filled them with numbers.
But is not the only way how to obtain the data (e.g. see this <a href="https://jsxgraph.org/wiki/index.php/Data_plot">example</a>).
As last we had to set the type of curve using attribute <a href="https://jsxgraph.org/docs/symbols/Curve.html#curveType"><em>curveType</em></a>.
{/lang}</p>
<p>{lang=CZ}
V tomto příkladu jsme především upravili nastavení nákresny, aby více odpovídala potřebám zobrazení daných dat. Kromě změny
rozsahu souřadnic, aby byly vidět všechny body, jsme mimo jiné atributem <em>axis</em> s hodnotou <em>true</em> zajistili zobrazení souřadnicových os.</p>
<p>Pro grafické zobrazení dat potřebujeme dva datové seznamy. V uvedeném příkladě jsou použity seznamy <code>x</code> a <code>y</code>, vyplněné čísly.
To ale není jediný způsob zadání dat (viz např. tento <a href="https://jsxgraph.org/wiki/index.php/Data_plot">příklad</a>).</p>
<p>Způsob zobrazení křivky je nastaven pomocí atributu <a href="https://jsxgraph.org/docs/symbols/Curve.html#curveType"><em>curveType</em></a>.
{/lang}</p>
<p>{lang=DE}
In diesem Beispiel mussten wir die bounding box anpassen, damit alle Daten sichtbar sind.</p>
<p>Um einen Datenplot zu erstellen benötigen wir zwei Listen für die $x$- und $y$-Koordinaten der
Datenpunkte. In unserem Fall verwenden wir zwei Listen
<code>x</code> and <code>y</code> und füllen diese mit Zahlen.
Das ist aber nicht die einzige Möglichkeit, Daten zu übergeben, siehe dieses
<a href="https://jsxgraph.org/wiki/index.php/Data_plot">Beispiel</a>.
Zuletzt geben wir noch den Kurventyp mit dem Attribut <a href="https://jsxgraph.org/docs/symbols/Curve.html#curveType"><em>curveType</em></a> an.
{/lang}</p>
<p>{lang=EN}</p>
<h2><a class="header" href="#drawing-mathematical-functions" id="drawing-mathematical-functions">Drawing mathematical functions</a></h2>
<p>In the constructions we often need to draw mathematical functions, e.g. sine or cosine, polynomials or other known functions.
JSXGraph provides convenient method to draw such functions. Lets look at the example.
{/lang}</p>
<p>{lang=SI}</p>
<h2><a class="header" href="#functions-drawing" id="functions-drawing">Functions drawing</a></h2>
<p>{/lang}</p>
<p>{lang=CZ}</p>
<h2><a class="header" href="#zobrazení-grafu-funkce" id="zobrazení-grafu-funkce">Zobrazení grafu funkce</a></h2>
<p>JSXGraph poskytuje pohodlný způsob zobrazování grafů funkcí, např. sinu, kosinu, algebraických funkcí, ale i dalších známých funkcí.</p>
<p>{/lang}</p>
<p>{lang=DE}</p>
<h2><a class="header" href="#funktionsgraphen" id="funktionsgraphen">Funktionsgraphen</a></h2>
<p>In vielen Konstruktionen benötigen wir Graphen von mathematische Funktionen, wie z.B. sin, cos, Polynome oder andere bekannte Funktionen.
JSXgrph stellt eine komfortable Möglichkeit bereit, derartige Funktionen zu zeichnen.
Wollen wir uns ein Beispiel ansehen.
{/lang}</p>
<pre><code class="language-JS">&lt;div id=&quot;jxgbox&quot; class=&quot;jxgbox&quot; style=&quot;width:300px; height:300px; margin:auto&quot;&gt;&lt;/div&gt;
&lt;script&gt;
 var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-4, 4, 4, -4], axis:true,  showCopyright:false, showNavigation:false });
 var graph1 = board.create('functiongraph', [function(x){return Math.sin(x);}, -Math.PI, Math.PI],{name:'sin(x)', withLabel:true});
 var graph2 = board.create('functiongraph', [function(x){return x*x-2;}, -3, 3],{name:'x^2 - 2', withLabel:true, strokeColor:'red'});
&lt;/script&gt;
</code></pre>
<div id="jxgbox" class="jxgbox" style="width:300px; height:300px; margin:auto"></div>
<script>
 var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-4, 4, 4, -4], axis:true,  showCopyright:false, showNavigation:false });
 var graph1 = board.create('functiongraph', [function(x){return Math.sin(x);},-Math.PI,Math.PI],{name:'sin(x)', withLabel:true});
 var graph2 = board.create('functiongraph', [function(x){return x*x-2;},-3,3],{name:'x^2 - 2', withLabel:true, strokeColor:'red'});
</script>
<p>{lang=EN}
In this example we first changed properties of <code>div</code> and set the width and heigth to form a square area, because we wanted
nicer looking construction (other possibility would be to use attribute <em>keepAspectRatio</em> in <code>initBoard()</code>). Then we created
two functions.</p>
<p>To draw a $\sin (x)$ function we used <em>functiongraph</em> as a type
<code>var graph1 = board.create('functiongraph', </code>.<br />
But what follows is something new.
Let us look closely to <code>[function(x){return Math.sin(x);},-Math.PI,Math.PI]</code>. With type <em>functiongraph</em> we told JSXGraph that
we will be drawing a function on some interval, therefore we need to provide the function we want to draw.
<code>function(x){return Math.sin(x);}</code> does just that. Here we use anonymous function <code>function(x)</code> where we provide parameter <code>x</code>,
that is used by JSXgraph to provide <code>x</code> values from the interval we have set with second and third element of the list. In our
case this is <code>-Math.PI, Math.PI</code>. Now we have to define a function that will return a value ($y-coordinate$) for the given $x$.
This was done by <code>{return Math.sin(x);}</code>. We have to use reserved word <code>return</code> which is followed by a function, in our case
<code>Math.sin(x)</code>. We end this with <code>;}</code> which must use to end the statement and the function.</p>
<p>In the second <em>graph2</em> we have drawn a quadratic function <code>{return x*x-2;}</code> on the interval <code>-3, 3</code>. We also used some attributes
which we already explained on previous pages.</p>
<p>Note: For the <em>sine</em> function we used
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math">Javascript Math</a> object.</p>
<p>Alternatively, we could input the function term as string in the form
<code>['sin(x)',-Math.PI,Math.PI]</code>. Then, the JSXGraph internal language <em>JessieCode</em> is used (see the JessieCode chapter)
which &quot;understands&quot; the usual math notation.
Another example would be <code>['x^3',-5,5]</code> as a variant to [function(x){return x<em>x</em>x;},-5,5]`.
{/lang}</p>
<p>{lang=SI}
In this example we first changed properties of <code>div</code> and set the width and heigth to form a square area, because we wanted
nicer looking construction (other possibility would be to use attribute <em>keepAspectRatio</em> in <code>initBoard()</code>). Then we created
two functions. </p>
<p>To draw a $\sin (x)$ function we used <em>functiongraph</em> as a type 
<code>var graph1 = board.create('functiongraph', </code>.<br />
But what follows is something new.
Let us look closely to <code>[function(x){return Math.sin(x);},-Math.PI,Math.PI]</code>. With type <em>functiongraph</em> we told JSXGraph that
we will be drawing a function on some interval, therefore we need to provide the function we want to draw. 
<code>function(x){return Math.sin(x);}</code> does just that. Here we use anonymous function <code>function(x)</code> where we provide parameter <code>x</code>,
that is used by JSXgraph to provide <code>x</code> values from the interval we have set with second and third element of the list. In our 
case this is <code>-Math.PI, Math.PI</code>. Now we have to define a function that will return a value ($y$-coordinate) for the given $x$.
This was done by <code>{return Math.sin(x);}</code>. We have to use reserved word <code>return</code> which is followed by a function, in our case
<code>Math.sin(x)</code>. We end this with <code>;}</code> which must use to end the statement and the function.</p>
<p>In the second <em>graph2</em> we have drawn a quadratic function <code>{return x*x-2;}</code> on the interval <code>-3, 3</code>. We also used some attributes
which we already explained on previous pages.</p>
<p>Note: For the <em>sine</em> function we used
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math">Javascript Math</a> object.</p>
<p>Alternatively, we could input the function term as string in the form
<code>['sin(x)',-Math.PI,Math.PI]</code>. Then, the JSXGraph internal language <em>JessieCode</em> is used (see the JessieCode chapter)
which &quot;understands&quot; the usual math notation.
Another example would be <code>['x^3',-5,5]</code> as a variant to [function(x){return x<em>x</em>x;},-5,5]`.
{/lang}</p>
<p>{lang=CZ}</p>
<p>V tomto příkladě jsme nejprve změnili vlastnosti bloku <code>div</code>, konkrétně jsme nastavili šířku (<em>width</em>) a výšku (<em>heigth</em>)
nákresny tak, aby měla čtvercový tvar (další možností by bylo použití atributu <em>keepAspectRatio</em> ve funkci <code>initBoard()</code>,
viz kapitola <em>3.6 Kružnice</em>). Potom jsme zadali zobrazení grafů dvou funkcí. </p>
<p>Pro zobrazení grafu funkce $\sin (x)$ jsme použili objekt typu <em>functiongraph</em> známým způsobem <code>var graph1 = board.create('functiongraph', ...</code>, 
ale to, co následuje, je něco nového. </p>
<p>Pojďme se detailně zaměřit na část kódu <code>[function(x){return Math.sin(x);},-Math.PI,Math.PI]</code>.
Uvedením typu <em>functiongraph</em> jsme JSXGraph informovali o tom, že budeme zobrazovat graf funkce na nějakém intervalu.
Nejprve parametrem <code>function(x){return Math.sin(x);}</code> zadáme výraz $\sin (x)$ definující hodnotu funkce pro dané $x$.
Užitím anonymní funkce <code>function(x)</code> zavedeme parametr <code>x</code>, kterému JSXGraph přiřazuje hodnoty ($x-souřadnice$) z intervalu, jehož 
meze jsou dány druhým a třetím prvkem seznamu parametrů, tj. hodnotami <code>-Math.PI, Math.PI</code>. 
Argumentem <code>{return Math.sin(x);}</code> je pro JSXGraph definována funkce, která pro dané $x$ vrátí příslušnou 
funkční hodnotu ($y$-souřadnici). Museli jsme použít klíčové slovo <code>return</code> následované příslušnou funkcí,
v našem případě <code>Math.sin(x)</code>. Zadání funkce zakončíme znakem <code>;</code> a ukončíme závorku <code>}</code>.</p>
<p>Druhý graf <em>graph2</em> přísluší kvadratické funkci <code>{return x*x-2;}</code> na intervalu <code>-3, 3</code>. Samozřejmě, k nastavení vzhledu 
grafů používáme i atributy, které byly představeny v předchozích kapitolách.</p>
<p>Poznámka: Pro funkci <em>sinus</em> byla použita knihovna <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math">Javascript Math</a>. 
{/lang}</p>
<p>{lang=DE}
In diesem Beispiel wurde zuerst die Größe des <code>div</code>-Elementes durch Setzen der Höhe und Breite so verändert, dass es quadratisch ist.
Denn wir wollten, dass die Funktionsgraphen in der richtigen Proportion gangezeigt werden (eine andere Möglichkeit wäre,
keepAspectRatio_ in <code>initBoard()</code> zu verwenden). Dann werden zwei Funktionen gezeichnet.</p>
<p>Um $\sin (x)$ zu zeichnen, verwenden wir <em>functiongraph</em> als Objekt
<code>var graph1 = board.create('functiongraph', </code>.<br />
Was danach folgt, ist neu.
Betrachten wir den Ausdruck <code>[function(x){return Math.sin(x);},-Math.PI,Math.PI]</code> genauer.
Mit dem Typ <em>functiongraph</em> haben wir JSXGraph mitgeteilt,
dass wir eine Funktion in einem gewissen Intervall zeichnen wollen.
Deshalb müssen wir nun die Funktion angeben, die gezeichnet werden soll. Dies geschieht durch
<code>function(x){return Math.sin(x);}</code>.</p>
<p>Hier nützen wir das JavaScript-Konzept <em>anonyme Funktion</em> durch Angabe von <code>function(x)</code> mit einem Parameter <code>x</code>.
Dieser wird von JSXGraph verwendet, um <code>x</code>-Werte aus dem Intervall zu übergeben, das wir mit dem zweiten und dritten
Element der Liste spezifizieren.
In unsererm Fall sind die Intervallgrenzen daher <code>-Math.PI, Math.PI</code>.
Nun haben wir noch die JavaScript-Funktion zu definieren, die jeweils zu einem
gegebenem $x$ einen Wert (die $y$-Koordinate) zurückgibt.
Dies geschieht durch <code>{return Math.sin(x);}</code>. Wir verwenden den reservierten Ausdruck <code>return</code> gefolgt durch eine Funktion, in unserem Fall
<code>Math.sin(x)</code>. Der Ausdruck wird durch <code>;}</code> beendet.</p>
<p>Im zweiten Funktionsgraph <em>graph2</em> zeichnen wir die quadratische Funktion <code>{return x*x-2;}</code> im Intervall <code>-3, 3</code>. Zudem
verwenden wir Attribute, die wir aber bereits aus den vorhergehenden Kapiteln kennen.</p>
<p>Beachte: Für die <em>Sinus</em>-Funktion verwenden wir das JavaScript <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math">Math</a>-Objekt.</p>
<p>Eine Alternative ist, den Funktionsterm als String in der Form
<code>['sin(x)',-Math.PI,Math.PI]</code> anzugeben. Dann wird die JSXGraph-eigene Sprache <em>JessieCode</em> verwendet (siehe das Kapitel zu JessieCode),
die die übliche Mathematik-Schreibweise &quot;versteht&quot;. Ein anderes Beispiel wäre <code>['x^3',-5,5]</code> als Alternative zu
<code>[function(x){return x*x*x;},-5,5]</code>.
{/lang}</p>
<p>{lang=EN}</p>
<h2><a class="header" href="#animating" id="animating">Animating</a></h2>
<p>Although creating points and lines and also drawing can be very useful, the power of JSXgraph lies when we want that 
our construction are not fixed, but can be used to simulate or demonstrate something. 
In this chapter we will learn </p>
<ul>
<li>how to move objects</li>
<li>how to &quot;glue&quot; objects to other objects (e.g points on the lines)</li>
<li>how to create sliders</li>
<li>how to transform objects (scaling, rotating, etc).
{/lang}</li>
</ul>
<p>{lang=SI}</p>
<h2><a class="header" href="#animating-1" id="animating-1">Animating</a></h2>
<p>{/lang}</p>
<p>{lang=CZ}</p>
<h2><a class="header" href="#animace" id="animace">Animace</a></h2>
<p>I když kreslení bodů, přímek a dalších objektů, spolu s jejich spojováním do dynamických konstrukcí, je užitečné, skutečná síla
JSXGraphu se projeví v dynamických konstrukcích, v nichž simulujeme nebo demonstrujeme nějaký jev.<br />
V této kapitole se naučíme </p>
<ul>
<li>jak pohybovat s objekty,</li>
<li>jak je přichytávat (&quot;glue&quot;) k jiným objektům (např. body k přímkám),</li>
<li>jak vytvářet posuvníky, </li>
<li>jak objekty transformovat (změna velikosti, posunutí, otočení atd.).
{/lang}</li>
</ul>
<p>{lang=EN}</p>
<h2><a class="header" href="#moving-objects" id="moving-objects">Moving objects</a></h2>
<p>Sometimes we want to move points to explain or present some concept. We can use this to animate the point by moving to 
final point (using method moveTo()) or only visiting some point and returning back to the start.
We will use both methods in next example.
{/lang}</p>
<p>{lang=SI}</p>
<h2><a class="header" href="#moving-objects-1" id="moving-objects-1">Moving objects</a></h2>
<p>{/lang}</p>
<p>{lang=CZ}</p>
<h2><a class="header" href="#pohybování-s-objekty" id="pohybování-s-objekty">Pohybování s objekty</a></h2>
<p>Pro ilustraci nebo vysvětlení některých jevů potřebujeme mít někdy možnost cíleně pohybovat s vybranými body obrázku. 
Můžeme například bod jednoduše přemístit do daného cílového místa (použitím metody <em>moveTo()</em>), nebo ho někam pošleme, aby se 
potom vrátil zpět do výchozího místa.
V následujícím příkladu použijeme oba tyto režimy pohybu.
{/lang}</p>
<pre><code class="language-JS">&lt;div id=&quot;jxgbox&quot; class=&quot;jxgbox&quot; style=&quot;width:500px; height:200px;&quot;&gt;&lt;/div&gt;
&lt;script&gt;
 var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-4, 4, 4, -4],keepAspectRatio:true, showCopyright:false, showNavigation:false });
 var p = board.create('point',[-1,0],{name:&quot;A&quot;});
 var q = board.create('point',[3,2],{name:&quot;B&quot;});
 var button1 = board.create('button',[2,3,'Start B', function(){q.visit([3,-2],1800,2)}]);
 var button2 = board.create('button',[-3,3,'Move A', function(){p.moveTo([Math.random()*8-4,Math.random()*8-4],500);}]);
&lt;/script&gt;
</code></pre>
<div id="jxgbox" class="jxgbox" style="width:300px; height:300px; margin:auto"></div>
<script>
 var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-4, 4, 4, -4],keepAspectRatio:true, showCopyright:false, showNavigation:false });
 var p = board.create('point',[-1,0],{name:"A"});
 var q = board.create('point',[3,2],{name:"B"});
 var button1 = board.create('button',[2,3,'Start B', function(){q.visit([3,-2],1800,2)}]);
 var button2 = board.create('button',[-3,3,'Move A', function(){p.moveTo([Math.random()*8-4,Math.random()*8-4],500);}]);
</script>
<p>{lang=EN}
First three lines are usual, but in the next line <code>var button1 = board.create('button',[2,3,'Start B', function(){q.visit([3,-2],1800,2)}]);</code> we use 
two new commands. </p>
<p>Let us focus first on the second command: <code>q.visit([3, -2], 1800, 2)</code>. Until now we always 
used only one method <em>create()</em> which we provided with parameters to create points, etc. on the board. Now we introduce 
a new method for the point which is called <a href="https://jsxgraph.org/docs/symbols/JXG.CoordsElement.html#visit"><em>visit()</em></a>.
Its syntax is <strong>visit(where, time, options)</strong> with three parameters,</p>
<ul>
<li><em>where</em> coordinates of our destination e.g. <code>[3, -2]</code>,</li>
<li><em>time</em> how long should it take e.g. <code>1800</code>,</li>
<li><em>options</em> in our case how many repetitions of our visit e.g <code>2</code>. </li>
</ul>
<p>First command creates a button on a board which click on it triggers some action. The parameters in the list are as follows
<strong>[x-coordinate, y-coordinate, title on the button, action]</strong>. In our case the action was anonymous function with the 
<em>visit</em> method on point <em>q</em>.</p>
<p>The second button is created in next line, but let us now look at the action more closely which is <code>p.moveTo([Math.random()*8-4,Math.random()*8-4],500);</code>.
Here we use on the point <em>q</em> new method <em>moveTo</em> which takes only two parameters</p>
<ul>
<li>destination coordinates as a list of two elements e.g  <code>[Math.random()*8-4,Math.random()*8-4]</code></li>
<li>animation time in miliseconds, e.g <code>500</code>.</li>
</ul>
<p>For the coordinates we use <em>Math.random</em> method, which every time we click on the button creates new random number between 0 and 1 
which we multiply by $8$ and subtract by $4$, result then will be between $-4$ and $4$m which are also limits of our bounding box.
We do the same for both coordinates. As a result our point p (<code>&quot;A&quot;</code>) moves across the board randomly. 
{/lang}</p>
<p>{lang=CZ}
Význam prvích tří řádků (za značkou &lt;script&gt;) už známe, další řádek <code>var button1 = board.create('button',[2,3,'Start B', function(){q.visit([3,-2],1800,2)}]);</code> ale přináší 
dva nové příkazy. </p>
<p>Pojďme se nejprve zaměřit na příkaz: <code>q.visit([3, -2], 1800, 2)</code>. Dosud jsme používali jenom metodu <em>create()</em>,
kterou jsme doplnili náležitými parametry pro zobrazení bodů apod. na nákresnu. Nyní představujeme novou metodu
pro nakládání s bodem, která se nazývá <a href="https://jsxgraph.org/docs/symbols/JXG.CoordsElement.html#visit"><em>visit()</em></a>.
Její syntaxe je <strong>visit(místo, doba trvání, volby)</strong> s těmito třemi parametry:</p>
<ul>
<li><em>místo</em> (<em>where</em>) souřadnice cíle pohybu, např. <code>[3, -2]</code>,</li>
<li><em>doba trvání</em> (<em>time</em>) jak dlouho, v milisekundách, to bude trvat, např. <code>1800</code>,</li>
<li><em>volby</em> (<em>options</em>), v našem případě se jedná o počet opakování, např. <code>2</code>. </li>
</ul>
<p>Výše uvedený kód čtvrtého řádku vytvoří v nákresně tlačítko, kliknutím na které se spustí nějaká akce. 
Význam parametrů uvedených v seznamu je následující: 
<strong>[x-souřadnice, y-souřadnice, nápis na tlačítku, akce]</strong>. Akcí je v našem případě anonymní funkce
aplikující metodu <em>visit</em> na bod <em>q</em>.</p>
<p>Druhé tlačítko je vytvořeno na následujícím řádku. Pojďme se ale detailněji zaměřit na příslušnou akci, což je <code>p.moveTo([Math.random()*8-4,Math.random()*8-4],500);</code>.
Zde aplikujeme na bod <em>q</em> novou metodu <em>moveTo</em>, která využívá pouze dva parametry:</p>
<ul>
<li>souřadnice cíle jako seznam o dvou složkách, např. <code>[Math.random()*8-4,Math.random()*8-4]</code></li>
<li>čas animace v <em>ms</em>, např. <code>500</code>.</li>
</ul>
<p>Pro stanovení souřadnic cíle používáme metodu <em>Math.random</em>, která při každém kliknutí na tlačítko
generuje náhodné číslo z intervalu od 0 do 1. Toto číslo se pak v našem konkrétním případě násobí $8$ a od výsledku 
se odečte $4$, aby byla hodnota příslušné souřadnice z rozmezí od $-4$ do $4$, které odpovídá rozsahu nákresny.
Tímto způsobem definujeme obě souřadnice cíle pohybu. Výsledným efektem je náhodný pohyb našeho bodu p (<code>&quot;A&quot;</code>) po nákresně. 
{/lang}</p>
<p>{lang=EN}</p>
<h2><a class="header" href="#example-proof-without-words" id="example-proof-without-words">Example: Proof without words</a></h2>
<p><strong>Area of a parallelogram.</strong> The area of a parallelogram equals its base multiplied by its height. Prove it!</p>
<p>To solve the example we will use a dynamic <a href="https://en.wikipedia.org/wiki/Proof_without_words">proof without words</a>, 
see figure below. By this means we will show that the area of a parallelogram equals the area of a rectangle whose 
base and height are the same as that of the parallelogram. 
{/lang}</p>
<p>{lang=SI}</p>
<h2><a class="header" href="#example-proof-without-words-1" id="example-proof-without-words-1">Example: Proof without words</a></h2>
<p><strong>Area of a parallelogram.</strong> The area of a parallelogram equals its base multiplied by its height. Prove it!</p>
<p>To solve the example we will use a dynamic <a href="https://en.wikipedia.org/wiki/Proof_without_words">proof without words</a>, 
see figure below. By this means we will show that the area of a parallelogram equals the area of a rectangle whose 
base and height are the same as that of the parallelogram. 
{/lang}</p>
<p>{lang=CZ}</p>
<h2><a class="header" href="#příklad-důkaz-beze-slov" id="příklad-důkaz-beze-slov">Příklad: Důkaz beze slov</a></h2>
<p><strong>Obsah rovnoběžníku.</strong> Obsah rovnoběžníku je roven součinu velikostí jeho základny a výšky na tuto základnu. Dokažte!</p>
<p>Úkol vyřešíme předložením dynamického <a href="https://en.wikipedia.org/wiki/Proof_without_words">důkazu beze slov</a>, 
viz obrázek níže. Jeho prostřednictvím prokážeme, že obsah rovnoběžníku je stejný jako obsah obdélníku, jehož 
základna a výška jsou stejné jako u rovnoběžníku.
{/lang}</p>
<div id="jxgbox" class="jxgbox" style="width:400px; height:250px;"></div>
<script>
	var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-1, 4, 7, -1]});
    // The fixed parallelogram ABCD
    var A = board.create('point', [0,0], {name:'A', fixed:true, size:1});
    var B = board.create('point', [4,0], {name:'B', fixed:true, size:1});
    var D = board.create('point', [2,3], {name:'D', fixed:true, size:1});
    var C = board.create('parallelpoint', [A, B, D], {name:'C', size:1});
    var par = board.create('polygon', [A, B, C, D], {color:'blue', fillOpacity: 0});
    // Point Q, the foot of the line passing through D perpendicular to AB
    var Q = board.create('point', [
                    function(){ return D.X(); },
                    function(){ return A.Y();
            }], {name:'Q', visible:false});
	// The trapezoid QBCD
    var tra = board.create('polygon', [Q, B,C,D], {color:'blue', withLines:false, fillOpacity: 0.3});		
    // Right triangle MNP, the moving object
    var M = board.create('point', [0,0], {name:'M', visible:false});
    var N = board.create('point', [function() {return M.X()+2;}, function(){return M.Y();}], {name:'N', visible:false})
    var P = board.create('point', [function() {return M.X()+2;}, function(){return M.Y()+3;}], {name:'P', visible:false})
    var tri = board.create('polygon', [M, N, P], {color:'blue', withLines:false, fillOpacity: 0.3});  
    // Buttons for moving the triangle MNP back and forth
    var button1 = board.create('button', [-0.5,3, 'Forth', function(){ M.moveTo([4,0], 1000); }]);
    var button2 = board.create('button', [-0.5,2.5, 'Back', function(){ M.moveTo([0,0], 1000); }]);
</script>
<p>{lang=EN}
<em>Programming:</em></p>
<p>First, we define dimensions, width and height, of the drawing area setting the corresponding properties of the <code>div</code> element:
{/lang}</p>
<p>{lang=SI}
<em>Programming:</em></p>
<p>First, we define dimensions, width and height, of the drawing area setting the corresponding properties of the <code>div</code> element:
{/lang}</p>
<p>{lang=CZ}
<em>Programování:</em></p>
<p>Nejprve stanovíme rozměry, tj. šířku a výšku, nákresny přiřazením náležitých hodnot odpovídajícím atributům prvku <code>div</code>: 
{/lang}</p>
<pre><code class="language-JS">&lt;div id=&quot;jxgbox&quot; class=&quot;jxgbox&quot; style=&quot;width:400px; height:250px;&quot;&gt;&lt;/div&gt; 
</code></pre>
<p>{lang=EN}
Subsequently, at the beginning of the code bounded by the tags <em>&lt;script&gt;, &lt;/script&gt;</em>, 
we determine the Bounding box as follows:
{/lang}</p>
<p>{lang=SI}
Subsequently, at the beginning of the code bounded by the tags <em>&lt;script&gt;, &lt;/script&gt;</em>, 
we determine the Bounding box as follows:
{/lang}</p>
<p>{lang=CZ}
Následně, na začátku kódu vymezeného tagy <em>&lt;script&gt;, &lt;/script&gt;</em>, 
definujeme rozsahy souřadnicových os zavedených v nákresně:
{/lang}</p>
<pre><code class="language-JS">&lt;div id=&quot;jxgbox&quot; class=&quot;jxgbox&quot; style=&quot;width:400px; height:250px;&quot;&gt;&lt;/div&gt;
&lt;script&gt;
    var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-1, 4, 7, -1]});
&lt;/script&gt;
</code></pre>
<p>{lang=EN}
As an initial sketch, the foundation of the dynamic figure, we draw the fixed parallelogram <em>ABCD</em> 
that is visible only by its boundary, having no filling:
{/lang}</p>
<p>{lang=SI}
As an initial sketch, the foundation of the dynamic figure, we draw the fixed parallelogram <em>ABCD</em> 
that is visible only by its boundary, having no filling:
{/lang}</p>
<p>{lang=CZ}
Jako výchozí motiv, který se stane základem dynamického obrázku, sestrojíme pevný (tj. nepohyblivý) 
rovnoběžník <em>ABCD</em>, bez výplně, zobrazený pouze svými stranami:
{/lang}</p>
<pre><code class="language-JS">&lt;div id=&quot;jxgbox&quot; class=&quot;jxgbox&quot; style=&quot;width:400px; height:250px;&quot;&gt;&lt;/div&gt;
&lt;script&gt;
    var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-1, 4, 7, -1]});
	var A = board.create('point', [0,0], {name:'A', fixed:true, size:1});
    var B = board.create('point', [4,0], {name:'B', fixed:true, size:1});
    var D = board.create('point', [2,3], {name:'D', fixed:true, size:1});
    var C = board.create('parallelpoint', [A, B, D], {name:'C', size:1});
    var par = board.create('polygon', [A, B, C, D], {color:'blue', fillOpacity: 0});
&lt;/script&gt;
</code></pre>
<p>{lang=EN}
Then, we determine point <em>Q</em>, invisible in the figure, the foot of the line passing through <em>D</em> perpendicular to <em>AB</em>, 
and use it to define a trapezoid <em>QBCD</em> with blue filling, an invariable part of the intended dynamic figure:
{/lang}</p>
<p>{lang=SI}
Then, we determine point <em>Q</em>, invisible in the figure, the foot of the line passing through <em>D</em> perpendicular to <em>AB</em>, 
and use it to define a trapezoid <em>QBCD</em> with blue filling, an invariable part of the intended dynamic figure:
{/lang}</p>
<p>{lang=CZ}
Jako patu kolmice z vrcholu <em>D</em> na přímku <em>AB</em> určíme bod <em>Q</em>, který je v dynamickém obrázku skryt. 
Slouží jako čtvrtý vrchol potřebný pro sestrojení modře vybarveného lichoběžníku <em>QBCD</em>,
který je nehybnou částí vytvářeného dynamického vizuálního důkazu:
{/lang}</p>
<pre><code class="language-JS">&lt;div id=&quot;jxgbox&quot; class=&quot;jxgbox&quot; style=&quot;width:400px; height:250px;&quot;&gt;&lt;/div&gt;
&lt;script&gt;
    var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-1, 4, 7, -1]});
	var A = board.create('point', [0,0], {name:'A', fixed:true, size:1});
    var B = board.create('point', [4,0], {name:'B', fixed:true, size:1});
    var D = board.create('point', [2,3], {name:'D', fixed:true, size:1});
    var C = board.create('parallelpoint', [A, B, D], {name:'C', size:1});
    var par = board.create('polygon', [A, B, C, D], {color:'blue', fillOpacity: 0});
	var Q = board.create('point', [
                    function(){ return D.X(); },
                    function(){ return A.Y();
            }], {name:'Q', visible:false});
	var tra = board.create('polygon', [Q, B,C,D], {color:'blue', withLines:false, fillOpacity: 0.3});
&lt;/script&gt;
</code></pre>
<p>{lang=EN}
To complete the parallelogram, we create the right triangle <em>MNP</em>, again filled with blue, 
the moving part of the visual proof without words. To allow its movement the vertices <em>M</em>, <em>N</em>, <em>P</em> will 
be independent on the other objects of the figure:
{/lang}</p>
<p>{lang=SI}
To complete the parallelogram, we create the right triangle <em>MNP</em>, again filled with blue, 
the moving part of the visual proof without words. To allow its movement the vertices <em>M</em>, <em>N</em>, <em>P</em> will 
be independent on the other objects of the figure:
{/lang}</p>
<p>{lang=CZ}
Pro dokončení výplně rovnoběžníku vytvoříme pravoúhlý trojúhelník <em>MNP</em>, opět modře vybarvený, který bude 
pohyblivou částí vizuálního dynamického důkazu beze slov. Aby se mohl hýbat, vytvoříme jeho vrcholy <em>M</em>, <em>N</em>, <em>P</em>
jako body nezávislé na ostatních prvcích obrázku: 
{/lang}</p>
<pre><code class="language-JS">&lt;div id=&quot;jxgbox&quot; class=&quot;jxgbox&quot; style=&quot;width:400px; height:250px;&quot;&gt;&lt;/div&gt;
&lt;script&gt;
    var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-1, 4, 7, -1]});
	var A = board.create('point', [0,0], {name:'A', fixed:true, size:1});
    var B = board.create('point', [4,0], {name:'B', fixed:true, size:1});
    var D = board.create('point', [2,3], {name:'D', fixed:true, size:1});
    var C = board.create('parallelpoint', [A, B, D], {name:'C', size:1});
    var par = board.create('polygon', [A, B, C, D], {color:'blue', fillOpacity: 0});
	var Q = board.create('point', [
                    function(){ return D.X(); },
                    function(){ return A.Y();
            }], {name:'Q', visible:false});
	var tra = board.create('polygon', [Q, B,C,D], {color:'blue', withLines:false, fillOpacity: 0.3});
	var M = board.create('point', [0,0], {name:'M', visible:false});
    var N = board.create('point', [function() {return M.X()+2;}, function(){return M.Y();}], {name:'N', visible:false})
    var P = board.create('point', [function() {return M.X()+2;}, function(){return M.Y()+3;}], {name:'P', visible:false})
    var tri = board.create('polygon', [M, N, P], {color:'blue', withLines:false, fillOpacity: 0.3});
&lt;/script&gt;
</code></pre>
<p>{lang=EN}
Finally, we define two buttons to control the movement of the triangle <em>MNP</em> back and forth:
{/lang}</p>
<p>{lang=SI}
Finally, we define two buttons to control the movement of the triangle <em>MNP</em> back and forth:
{/lang}</p>
<p>{lang=CZ}
Nakonec vytvoříme dvě tlačítka pro ovládání pohybu pravoúhlého trojúhelníku <em>MNP</em> tam a zpět:
{/lang}</p>
<pre><code class="language-JS">&lt;div id=&quot;jxgbox&quot; class=&quot;jxgbox&quot; style=&quot;width:400px; height:250px;&quot;&gt;&lt;/div&gt;
&lt;script&gt;
    var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-1, 4, 7, -1]});
	var A = board.create('point', [0,0], {name:'A', fixed:true, size:1});
    var B = board.create('point', [4,0], {name:'B', fixed:true, size:1});
    var D = board.create('point', [2,3], {name:'D', fixed:true, size:1});
    var C = board.create('parallelpoint', [A, B, D], {name:'C', size:1});
    var par = board.create('polygon', [A, B, C, D], {color:'blue', fillOpacity: 0});
	var Q = board.create('point', [
                    function(){ return D.X(); },
                    function(){ return A.Y();
            }], {name:'Q', visible:false});
	var tra = board.create('polygon', [Q, B,C,D], {color:'blue', withLines:false, fillOpacity: 0.3});
	var M = board.create('point', [0,0], {name:'M', visible:false});
    var N = board.create('point', [function() {return M.X()+2;}, function(){return M.Y();}], {name:'N', visible:false})
    var P = board.create('point', [function() {return M.X()+2;}, function(){return M.Y()+3;}], {name:'P', visible:false})
    var tri = board.create('polygon', [M, N, P], {color:'blue', withLines:false, fillOpacity: 0.3});
	var button1 = board.create('button', [-0.5,3, 'Forth', function(){ M.moveTo([4,0], 1000); }]);
    var button2 = board.create('button', [-0.5,2.5, 'Back', function(){ M.moveTo([0,0], 1000); }]);
&lt;/script&gt;
</code></pre>
<p>{lang=EN}
The task solution code is now complete.
{/lang}</p>
<p>{lang=SI}
The task solution code is now complete.
{/lang}</p>
<p>{lang=CZ}
Kód řešení úlohy je nyní kompletní.
{/lang}</p>
<p>{lang=EN}</p>
<h2><a class="header" href="#sliders" id="sliders">Sliders</a></h2>
<p>Sliders can be used in various settings, where we want that users try or tinker with the values of some variable. In our example
we will upgrade example with the quadratic function.
{/lang}</p>
<p>{lang=SI}</p>
<h2><a class="header" href="#sliders-1" id="sliders-1">Sliders</a></h2>
<p>{/lang}</p>
<p>{lang=CZ}</p>
<h2><a class="header" href="#posuvníky" id="posuvníky">Posuvníky</a></h2>
<p>Posuvník (<em>slider</em>) můžeme použít v různých situacích, ve kterých chceme, aby měl uživatel možnost bezprostředně měnit 
hodnotu nějaké proměnné. Pro ukázku použití posuvníků jsme zvolili náležitou úpravu dříve uvedeného příkladu s kvadratickou funkcí.
{/lang}</p>
<pre><code class="language-JS">&lt;div id=&quot;jxgbox&quot; class=&quot;jxgbox&quot; style=&quot;width:300px; height:300px; margin:auto&quot;&gt;&lt;/div&gt;
&lt;script&gt;
 var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-8, 8, 8, -8], axis:true,  showCopyright:false, showNavigation:false });
 var a = board.create('slider', [[-7.5, -3], [-4,-3], [-3, 1, 3]], {name:'a', snapWidth: 0.1});
 var c = board.create('slider', [[-7.5, -5], [-4,-5], [-1, 1, 4]], {name:'c',snapWidth: 1});
 var graph2 = board.create('functiongraph', [function(x){return a.Value()*x*x + c.Value();}, -3, 3]);
 var text = board.create('text',[-6,6,function(){return a.Value().toFixed(2)+'\\times x^2'+c.Value()}]);
&lt;/script&gt;
</code></pre>
<div id="jxgbox" class="jxgbox" style="width:300px; height:300px; margin:auto"></div>
<script>
 var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-8, 8, 8, -8], axis:true,  showCopyright:false, showNavigation:false });
 var a = board.create('slider', [[-7.5, -3], [-4,-3], [-3, 1, 3]], {name:'a', snapWidth: 0.1});
 var c = board.create('slider', [[-7.5, -5], [-4,-5], [-1, 1, 4]], {name:'c',snapWidth: 1});
 var graph2 = board.create('functiongraph', [function(x){return a.Value()*x*x + c.Value();}, -3, 3]);
</script>
<p>{lang=EN}
We extended the example with two sliders which now control the quadratic function. But first let us look closer on how we
created first <em>slider</em>: <code>var a = board.create('slider', [[-7.5, -3], [-4,-3], [-3, 1, 3]], {name:'a', snapWidth: 0.1});</code></p>
<p>To create a slider we need to provide following parameters:</p>
<ul>
<li>coordinates of the first point of the slider, e.g. <code>[-7.5, -3]</code></li>
<li>coordinates of the last point of the slider, e.g. <code>[-4,-3]</code></li>
<li>values of the slider as a list <code>[min, start, max]</code>, e.g. <code>[-3, 1, 3]</code>.</li>
</ul>
<p>Here we also used atribute <em>snapWidth</em> which tells JSXGraph how fine the steps of the slider should be. Second slider is generated 
in similar way, except we set the attribute <em>snapWidth</em> to $1$ to generate only integer values.</p>
<p>In last line we now used the values from both sliders and extended our quadratic function with <code>return a.Value()*x*x + c.Value()</code>.
We can see, that to get the value of the slider we used the variable name and method <em>Value()</em> e.g. <code>a.Value()</code>. </p>
<p>Now the quadratic function is not fixed with the values but can be dynamically changed with the user interaction.</p>
<p>{/lang}</p>
<p>{lang=CZ}
Obrázek jsme doplnili dvěma posuvníky, kterými ovládáme koeficienty $a$, $c$ dané kvadratické funkce.
Pojďme se podrobně podívat na to, jak jsme vytvořili první <em>posuvník</em> (<em>slider</em>): <code>var a = board.create('slider', [[-7.5, -3], [-4,-3], [-3, 1, 3]], {name:'a', snapWidth: 0.1});</code></p>
<p>Pro vytvoření posuvníku potřebujeme definovat následující parametry:</p>
<ul>
<li>souřadnice počátečního bodu posuvníku, např. <code>[-7.5, -3]</code>,</li>
<li>souřadnice koncového bodu posuvníku, např. <code>[-4,-3]</code>,</li>
<li>určující hodnoty posuvníku formou seznamu <code>[min, start, max]</code>, např. <code>[-3, 1, 3]</code>.</li>
</ul>
<p>V příkladu jsme dále použili atribut <em>snapWidth</em>, který stanoví, jak jemný má být krok posuvníku. Druhý posuvník je vytvořen
podobným způsobem, kromě toho, že jsme atributu <em>snapWidth</em> přiřadili hodnotu $1$, aby nabýval pouze celočíselných hodnot.</p>
<p>V posledním řádku kódu jsme použili hodnoty obou posuvníků v definici naší kvadratické funkce 
<code>return a.Value()*x*x + c.Value()</code>.
Vidíme zde, že pro získání okamžité hodnoty posuvníku použijeme spojení jména proměnné a metody <em>Value()</em> takto <code>a.Value()</code>. </p>
<p>Předpis kvadratické funkce tak už není neměnný, díky posuvníkům může být jeho podoba uživatelem dynamicky měněna.
{/lang}</p>
<h1><a class="header" href="#langenanimating-with-sliderslanglangsianimating-with-sliderslanglangczanimating-with-sliderslang" id="langenanimating-with-sliderslanglangsianimating-with-sliderslanglangczanimating-with-sliderslang">{lang=EN}Animating with sliders{/lang}{lang=SI}Animating with sliders{/lang}{lang=CZ}Animating with sliders{/lang}</a></h1>
<p>{lang=EN}</p>
<h2><a class="header" href="#example-animation-with-slider" id="example-animation-with-slider">Example: Animation with slider</a></h2>
<p><strong>Cycloids.</strong> Rolling a circle along a straight line a point firmly connected to its rim draws a curve 
called a <a href="https://mathworld.wolfram.com/Cycloid.html">cycloid</a>. If the point is closer to the center a 
curve drawn by it is called a <em>curtate cycloid</em>. If the point is further from the center than the rim, 
the resulting curve is called a <em>prolate cycloid</em>, see figure below. Create a dynamic geometry model of the 
given situation, movement of the circle controlled by the slider.
{/lang}</p>
<p>{lang=SI}</p>
<h2><a class="header" href="#example-animation-with-slider-1" id="example-animation-with-slider-1">Example: Animation with slider</a></h2>
<p><strong>Cycloids.</strong> Rolling a circle along a straight line a point firmly connected to its rim draws a curve 
called a <a href="https://mathworld.wolfram.com/Cycloid.html">cycloid</a>. If the point is closer to the center a 
curve drawn by it is called a <em>curtate cycloid</em>. If the point is further from the center than the rim, 
the resulting curve is called a <em>prolate cycloid</em>, see figure below. Create a dynamic geometry model of the 
given situation, movement of the circle controlled by the slider.
{/lang}</p>
<p>{lang=CZ}</p>
<h2><a class="header" href="#příklad-animace-užitím-posuvníku" id="příklad-animace-užitím-posuvníku">Příklad: Animace užitím posuvníku</a></h2>
<p><strong>Cykloidy.</strong> Při odvalování kruhu podél přímky vykresluje bod pevně spojený s jeho okrajem křivku
zvanou <a href="https://mathworld.wolfram.com/Cycloid.html">cykloida</a>. Pokud je uvažovaný bod blíže ke středu kruhu, než je jeho okraj,
jeho trajektorií je křivka zvaná <em>zkrácená cykloida</em> (<em>curtate cycloid</em>). Pokud je předmětný bod 
dále od středu, než je okraj kruhu, jeho trajektorií je <em>prodloužená cykloida</em> (<em>prolate cycloid</em>). Vytvořte dynamický geometrický model popsaných situací u kterého je pohyb kružnice
ovládán posuvníkem, viz níže uvedený obrázek.
{/lang}</p>
<div id="jxgbox" class="jxgbox" style="width:800px; height:300px;"></div>
     <script>
        var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-2, 5, 14, -1], axis:false, showClearTraces: true});
        // A straight line as  a path for the circle
        var M = board.create('point',[-1,0],{name:'M', face:'o', size:1, visible:false});
        var N = board.create('point',[7,0],{name:'N', face:'o', size:1, visible:false});
        var l1 = board.create('line', [M,N], {color:'black'});
        // Sliders to control the values of r (radius of the circle) and l (the amount of translation of the circle center)
        var r = board.create('slider', [[-1, -0.5], [1,-0.5], [0, 1, 3]], {name:'r', snapWidth: 0.1});
        var l = board.create('slider', [[5, -0.5], [10,-0.5], [-2.00, 0, 18.00]], {name:'l', snapWidth: 0.01});
        // Circle c with center C
        var C = board.create('point', [function(){return l.Value();},function(){return r.Value();}], {color:'blue', size:1, name:'C'});
        var c = board.create('circle', [C,function(){return r.Value();}], {color:'orange', fillOpacity: 0.1});
        // Three fixed points with different distances from the center to get curtate, normal and prolate cycloid, respectively
        var A0 = board.create('point', [function(){return C.X();}, function(){return 1.5*r.Value();}], {visible:false});
        var B0 = board.create('point', [function(){return C.X();}, function(){return 2*r.Value();}], {visible:false});
        var D0 = board.create('point', [function(){return C.X();}, function(){return 2.5*r.Value();}], {visible:false});
        // moving points as images of the respective fixed points
        var A = board.create('point',
                [function(){return ((A0.X()-C.X())*Math.cos(l.Value()/r.Value())+(A0.Y()-C.Y())*Math.sin(l.Value()/r.Value()))+C.X();},
                 function(){return (-(A0.X()-C.X())*Math.sin(l.Value()/r.Value())+(A0.Y()-C.Y())*Math.cos(l.Value()/r.Value()))+C.Y();}],
                {size:1, color:'red', trace:true});
        var B = board.create('point',
                [function(){return ((B0.X()-C.X())*Math.cos(l.Value()/r.Value())+(B0.Y()-C.Y())*Math.sin(l.Value()/r.Value()))+C.X();},
                 function(){return (-(B0.X()-C.X())*Math.sin(l.Value()/r.Value())+(B0.Y()-C.Y())*Math.cos(l.Value()/r.Value()))+C.Y();}],
                {size:1, color:'green', trace:true});
        var D = board.create('point',
                [function(){return ((D0.X()-C.X())*Math.cos(l.Value()/r.Value())+(D0.Y()-C.Y())*Math.sin(l.Value()/r.Value()))+C.X();},
                 function(){return (-(D0.X()-C.X())*Math.sin(l.Value()/r.Value())+(D0.Y()-C.Y())*Math.cos(l.Value()/r.Value()))+C.Y();}],
                {size:1, color:'blue', trace:true});
        </script>
<p>{lang=EN}
<em>Programming:</em></p>
<p>First, we define dimensions, width and height, of the drawing area setting the corresponding properties of the <code>div</code> element:
{/lang}</p>
<p>{lang=SI}
<em>Programming:</em></p>
<p>First, we define dimensions, width and height, of the drawing area setting the corresponding properties of the <code>div</code> element:
{/lang}</p>
<p>{lang=CZ}
<em>Programování:</em></p>
<p>Nejprve stanovíme rozměry, tj. šířku a výšku, nákresny přiřazením náležitých hodnot odpovídajícím atributům prvku <code>div</code>: 
{/lang}</p>
<pre><code class="language-JS">&lt;div id=&quot;jxgbox&quot; class=&quot;jxgbox&quot; style=&quot;width:900px; height:300px;&quot;&gt;&lt;/div&gt;
</code></pre>
<p>{lang=EN}
Subsequently, at the beginning of the code bounded by the tags <em>&lt;script&gt;, &lt;/script&gt;</em>, 
we determine the Bounding box as follows:
{/lang}</p>
<p>{lang=SI}
Subsequently, at the beginning of the code bounded by the tags <em>&lt;script&gt;, &lt;/script&gt;</em>, 
we determine the Bounding box as follows:
{/lang}</p>
<p>{lang=CZ}
Následně, na začátku kódu vymezeného tagy <em>&lt;script&gt;, &lt;/script&gt;</em>, 
definujeme rozsahy souřadnicových os zavedených v nákresně:
{/lang}</p>
<pre><code class="language-JS">&lt;div id=&quot;jxgbox&quot; class=&quot;jxgbox&quot; style=&quot;width:400px; height:250px;&quot;&gt;&lt;/div&gt;
&lt;script&gt;
    var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-2, 5, 16, -1], axis:false, showClearTraces: true});
&lt;/script&gt;
</code></pre>
<p>{lang=EN}
Note the attribute <code>showClearTraces</code> used above. Setting its value to <code>true</code> displays the button for deleting 
the traces of points, see the circled times at the bottom of the bounding box.</p>
<p>As the first of construction, we draw a straight line <em>MN</em>, a path for the circle:
{/lang}</p>
<p>{lang=SI}
Note the attribute <code>showClearTraces</code> used above. Setting its value to <code>true</code> displays the button for deleting 
the traces of points, see the circled times at the bottom of the bounding box.</p>
<p>As the first of construction, we draw a straight line <em>MN</em>, a path for the circle:
{/lang}</p>
<p>{lang=CZ}
Všimněme si atributu <code>showClearTraces</code>, který je použit ve výše uvedeném příkazu pro iniciaci nákresny. 
Nastavení jeho hodnoty na <code>true</code> vede k zobrazení užitečného tlačítka pro mazání stop bodů, viz
symbol kruhu s křížkem uvnitř při dolním okraji nákresny ve výše uvedeném dynamickém obrázku.</p>
<p>Konstrukci řešení začneme sestrojením přímky <em>MN</em>, cesty pro odvalování kruhu:
{/lang}</p>
<pre><code class="language-JS">&lt;div id=&quot;jxgbox&quot; class=&quot;jxgbox&quot; style=&quot;width:400px; height:250px;&quot;&gt;&lt;/div&gt;
&lt;script&gt;
    var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-2, 5, 16, -1], axis:false, showClearTraces: true});
	var M = board.create('point',[-1,0],{name:'M', face:'o', size:1, visible:false});
    var N = board.create('point',[7,0],{name:'N', face:'o', size:1, visible:false});
    var l1 = board.create('line', [M,N], {color:'black'});
&lt;/script&gt;
</code></pre>
<p>{lang=EN}
Before drawing the circle, we create two sliders to control the values of <em>r</em>, radius of the circle, and <em>l</em>, 
the amount of translation of the circle center, respectively:
{/lang}</p>
<p>{lang=SI}
Before drawing the circle, we create two sliders to control the values of <em>r</em>, radius of the circle, and <em>l</em>, 
the amount of translation of the circle center, respectively:
{/lang}</p>
<p>{lang=CZ}
Před sestrojením vlastního kruhu vytvoříme dva posuvníky pro ovládání hodnot
parametrů <em>r</em>, poloměru kruhu, a <em>l</em>, velikosti posunutí středu kruhu při jeho pohybu:
{/lang}</p>
<pre><code class="language-JS">&lt;div id=&quot;jxgbox&quot; class=&quot;jxgbox&quot; style=&quot;width:400px; height:250px;&quot;&gt;&lt;/div&gt;
&lt;script&gt;
    var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-2, 5, 16, -1], axis:false, showClearTraces: true});
	var M = board.create('point',[-1,0],{name:'M', face:'o', size:1, visible:false});
    var N = board.create('point',[7,0],{name:'N', face:'o', size:1, visible:false});
    var l1 = board.create('line', [M,N], {color:'black'});
	var r = board.create('slider', [[-1, -0.5], [1,-0.5], [0, 1, 3]], {name:'r', snapWidth: 0.1});
    var l = board.create('slider', [[5, -0.5], [10,-0.5], [-2.00, 0, 18.00]], {name:'l', snapWidth: 0.01});
&lt;/script&gt;
</code></pre>
<p>{lang=EN}
Then we proceed to the construction of the circle <em>c</em> with center <em>C</em> and radius <em>r</em>:
{/lang}</p>
<p>{lang=SI}
Then we proceed to the construction of the circle <em>c</em> with center <em>C</em> and radius <em>r</em>:
{/lang}</p>
<p>{lang=CZ}
Pokračujeme sestrojením samotného kruhu <em>c</em> se středem <em>C</em> a poloměrem <em>r</em>:
{/lang}</p>
<pre><code class="language-JS">&lt;div id=&quot;jxgbox&quot; class=&quot;jxgbox&quot; style=&quot;width:400px; height:250px;&quot;&gt;&lt;/div&gt;
&lt;script&gt;
    var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-2, 5, 16, -1], axis:false, showClearTraces: true});
	var M = board.create('point',[-1,0],{name:'M', face:'o', size:1, visible:false});
    var N = board.create('point',[7,0],{name:'N', face:'o', size:1, visible:false});
    var l1 = board.create('line', [M,N], {color:'black'});
	var r = board.create('slider', [[-1, -0.5], [1,-0.5], [0, 1, 3]], {name:'r', snapWidth: 0.1});
    var l = board.create('slider', [[5, -0.5], [10,-0.5], [-2.00, 0, 18.00]], {name:'l', snapWidth: 0.01});
	var C = board.create('point', [function(){return l.Value();},function(){return r.Value();}], {color:'blue', size:1, name:'C'});
    var c = board.create('circle', [C,function(){return r.Value();}], {color:'orange', fillOpacity: 0.1});
&lt;/script&gt;
</code></pre>
<p>{lang=EN}
By defining three fixed points <em>A0</em>, <em>B0</em>, <em>C0</em> with different distances from the circle’s center we contribute to obtaining 
the above mentioned cycloids; <em>curtate</em>, <em>normal</em> and <em>prolate cycloid</em>, respectively:
{/lang}</p>
<p>{lang=SI}
By defining three fixed points <em>A0</em>, <em>B0</em>, <em>C0</em> with different distances from the circle’s center we contribute to obtaining 
the above mentioned cycloids; <em>curtate</em>, <em>normal</em> and <em>prolate cycloid</em>, respectively:
{/lang}</p>
<p>{lang=CZ}
Definováním následujících tří pevných bodů <em>A0</em>, <em>B0</em>, <em>C0</em> s různými vzdálenostmi od 
středu kruhu si připravíme startovní pozice pro získání výše uvedených cykloid; 
<em>zkrácené</em>, <em>normální</em> a <em>prodloužené cykloidy</em>, v daném pořadí:
{/lang}</p>
<pre><code class="language-JS">&lt;div id=&quot;jxgbox&quot; class=&quot;jxgbox&quot; style=&quot;width:400px; height:250px;&quot;&gt;&lt;/div&gt;
&lt;script&gt;
    var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-2, 5, 16, -1], axis:false, showClearTraces: true});
	var M = board.create('point',[-1,0],{name:'M', face:'o', size:1, visible:false});
    var N = board.create('point',[7,0],{name:'N', face:'o', size:1, visible:false});
    var l1 = board.create('line', [M,N], {color:'black'});
	var r = board.create('slider', [[-1, -0.5], [1,-0.5], [0, 1, 3]], {name:'r', snapWidth: 0.1});
    var l = board.create('slider', [[5, -0.5], [10,-0.5], [-2.00, 0, 18.00]], {name:'l', snapWidth: 0.01});
	var C = board.create('point', [function(){return l.Value();},function(){return r.Value();}], {color:'blue', size:1, name:'C'});
    var c = board.create('circle', [C,function(){return r.Value();}], {color:'orange', fillOpacity: 0.1});
	var A0 = board.create('point', [function(){return C.X();}, function(){return 1.5*r.Value();}], {visible:false});
    var B0 = board.create('point', [function(){return C.X();}, function(){return 2*r.Value();}], {visible:false});
    var D0 = board.create('point', [function(){return C.X();}, function(){return 2.5*r.Value();}], {visible:false});
&lt;/script&gt;
</code></pre>
<p>{lang=EN}
In fact, we will not directly move these points <em>A0</em>, <em>B0</em>, <em>C0</em>, but will create their instant images <em>A</em>, <em>B</em>, <em>C</em> dependent on values that variables 
controlled by sliders, especially <em>l</em>, can gain:
{/lang}</p>
<p>{lang=SI}
In fact, we will not directly move these points <em>A0</em>, <em>B0</em>, <em>C0</em>, but will create their instant images <em>A</em>, <em>B</em>, <em>C</em> dependent on values that variables 
controlled by sliders, especially <em>l</em>, can gain:
{/lang}</p>
<p>{lang=CZ}
Je třeba říci, že při animaci nepohybujeme přímo s těmito body <em>A0</em>, <em>B0</em>, <em>C0</em>, ale vytváříme jejich 
okamžité obrazy <em>A</em>, <em>B</em>, <em>C</em> příslušející konkrétním hodnotám proměnných ovládaných posuvníky, především <em>l</em>:
{/lang}</p>
<pre><code class="language-JS">&lt;div id=&quot;jxgbox&quot; class=&quot;jxgbox&quot; style=&quot;width:400px; height:250px;&quot;&gt;&lt;/div&gt;
&lt;script&gt;
    var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-2, 5, 16, -1], axis:false, showClearTraces: true});
	var M = board.create('point',[-1,0],{name:'M', face:'o', size:1, visible:false});
    var N = board.create('point',[7,0],{name:'N', face:'o', size:1, visible:false});
    var l1 = board.create('line', [M,N], {color:'black'});
	var r = board.create('slider', [[-1, -0.5], [1,-0.5], [0, 1, 3]], {name:'r', snapWidth: 0.1});
    var l = board.create('slider', [[5, -0.5], [10,-0.5], [-2.00, 0, 18.00]], {name:'l', snapWidth: 0.01});
	var C = board.create('point', [function(){return l.Value();},function(){return r.Value();}], {color:'blue', size:1, name:'C'});
    var c = board.create('circle', [C,function(){return r.Value();}], {color:'orange', fillOpacity: 0.1});
	var A0 = board.create('point', [function(){return C.X();}, function(){return 1.5*r.Value();}], {visible:false});
    var B0 = board.create('point', [function(){return C.X();}, function(){return 2*r.Value();}], {visible:false});
    var D0 = board.create('point', [function(){return C.X();}, function(){return 2.5*r.Value();}], {visible:false});
	var A = board.create('point',
            [function(){return ((A0.X()-C.X())*Math.cos(l.Value()/r.Value())+(A0.Y()-C.Y())*Math.sin(l.Value()/r.Value()))+C.X();},
             function(){return (-(A0.X()-C.X())*Math.sin(l.Value()/r.Value())+(A0.Y()-C.Y())*Math.cos(l.Value()/r.Value()))+C.Y();}],
            {size:1, color:'red', trace:true});

    var B = board.create('point',
            [function(){return ((B0.X()-C.X())*Math.cos(l.Value()/r.Value())+(B0.Y()-C.Y())*Math.sin(l.Value()/r.Value()))+C.X();},
             function(){return (-(B0.X()-C.X())*Math.sin(l.Value()/r.Value())+(B0.Y()-C.Y())*Math.cos(l.Value()/r.Value()))+C.Y();}],
            {size:1, color:'green', trace:true});

    var D = board.create('point',
            [function(){return ((D0.X()-C.X())*Math.cos(l.Value()/r.Value())+(D0.Y()-C.Y())*Math.sin(l.Value()/r.Value()))+C.X();},
             function(){return (-(D0.X()-C.X())*Math.sin(l.Value()/r.Value())+(D0.Y()-C.Y())*Math.cos(l.Value()/r.Value()))+C.Y();}],
            {size:1, color:'blue', trace:true});
&lt;/script&gt;
</code></pre>
<p>{lang=EN}
The task solution code is now complete.
{/lang}</p>
<p>{lang=SI}
The task solution code is now complete.
{/lang}</p>
<p>{lang=CZ}
Kód řešení úlohy je nyní kompletní.
{/lang}</p>
<h1><a class="header" href="#langentransformationslanglangsifunctions-drawinglanglangczfunctions-drawinglang" id="langentransformationslanglangsifunctions-drawinglanglangczfunctions-drawinglang">{lang=EN}Transformations{/lang}{lang=SI}Functions drawing{/lang}{lang=CZ}Functions drawing{/lang}</a></h1>
<h1><a class="header" href="#langenadvanced-topicslanglangsiadvanced-topicslanglangczadvanced-topicslang" id="langenadvanced-topicslanglangsiadvanced-topicslanglangczadvanced-topicslang">{lang=EN}Advanced topics{/lang}{lang=SI}Advanced topics{/lang}{lang=CZ}Advanced topics{/lang}</a></h1>
<h1><a class="header" href="#langenadding-imageslanglangsifunctions-drawinglanglangczfunctions-drawinglang" id="langenadding-imageslanglangsifunctions-drawinglanglangczfunctions-drawinglang">{lang=EN}Adding images{/lang}{lang=SI}Functions drawing{/lang}{lang=CZ}Functions drawing{/lang}</a></h1>
<h1><a class="header" href="#langencapture-the-construction-as-imagelanglangsicapture-the-construction-as-imagelanglangczcapture-the-construction-as-imagelang" id="langencapture-the-construction-as-imagelanglangsicapture-the-construction-as-imagelanglangczcapture-the-construction-as-imagelang">{lang=EN}Capture the construction as image{/lang}{lang=SI}Capture the construction as image{/lang}{lang=CZ}Capture the construction as image{/lang}</a></h1>
<h1><a class="header" href="#langenjsxgraph-optionslanglangsijsxgraph-optionslanglangczjsxgraph-optionslang" id="langenjsxgraph-optionslanglangsijsxgraph-optionslanglangczjsxgraph-optionslang">{lang=EN}JSXGraph options{/lang}{lang=SI}JSXGraph options{/lang}{lang=CZ}JSXGraph options{/lang}</a></h1>
<h1><a class="header" href="#langentriggerslanglangsitriggerslanglangcztriggerslang" id="langentriggerslanglangsitriggerslanglangcztriggerslang">{lang=EN}Triggers{/lang}{lang=SI}Triggers{/lang}{lang=CZ}Triggers{/lang}</a></h1>
<h1><a class="header" href="#langensaving-user-actionslanglangsisaving-user-actionslanglangczsaving-user-actionslang" id="langensaving-user-actionslanglangsisaving-user-actionslanglangczsaving-user-actionslang">{lang=EN}Saving user actions{/lang}{lang=SI}Saving user actions{/lang}{lang=CZ}Saving user actions{/lang}</a></h1>
<h1><a class="header" href="#langenjessie-codelanglangsifunctions-drawinglanglangczfunctions-drawinglang" id="langenjessie-codelanglangsifunctions-drawinglanglangczfunctions-drawinglang">{lang=EN}Jessie Code{/lang}{lang=SI}Functions drawing{/lang}{lang=CZ}Functions drawing{/lang}</a></h1>
<h1><a class="header" href="#langenjsxgraph-and-moodlelanglangsijsxgraph-and-moodlelanglangczjsxgraph-and-moodlelang" id="langenjsxgraph-and-moodlelanglangsijsxgraph-and-moodlelanglangczjsxgraph-and-moodlelang">{lang=EN}JSXGraph and Moodle{/lang}{lang=SI}JSXGraph and Moodle{/lang}{lang=CZ}JSXGraph and Moodle{/lang}</a></h1>
<h1><a class="header" href="#langenjsxgraph-as-a-moodle-filterlanglangsijsxgraph-as-a-moodle-filterlanglangczjsxgraph-as-a-moodle-filterlang" id="langenjsxgraph-as-a-moodle-filterlanglangsijsxgraph-as-a-moodle-filterlanglangczjsxgraph-as-a-moodle-filterlang">{lang=EN}JSXGraph as a Moodle Filter{/lang}{lang=SI}JSXGraph as a Moodle Filter{/lang}{lang=CZ}JSXGraph as a Moodle Filter{/lang}</a></h1>
<h1><a class="header" href="#langenjsxgraph-and-moodle-formulaslanglangsijsxgraph-and-moodle-formulaslanglangczjsxgraph-and-moodle-formulaslang" id="langenjsxgraph-and-moodle-formulaslanglangsijsxgraph-and-moodle-formulaslanglangczjsxgraph-and-moodle-formulaslang">{lang=EN}JSXGraph and Moodle Formulas{/lang}{lang=SI}JSXGraph and Moodle Formulas{/lang}{lang=CZ}JSXGraph and Moodle Formulas{/lang}</a></h1>
<h1><a class="header" href="#langenjsxgraph-and-stacklanglangsijsxgraph-and-stacklanglangczjsxgraph-and-stacklang" id="langenjsxgraph-and-stacklanglangsijsxgraph-and-stacklanglangczjsxgraph-and-stacklang">{lang=EN}JSXGraph and Stack{/lang}{lang=SI}JSXGraph and Stack{/lang}{lang=CZ}JSXGraph and Stack{/lang}</a></h1>
<h1><a class="header" href="#langentemplateslanglangsitemplateslanglangcztemplateslang" id="langentemplateslanglangsitemplateslanglangcztemplateslang">{lang=EN}Templates{/lang}{lang=SI}Templates{/lang}{lang=CZ}Templates{/lang}</a></h1>
<h1><a class="header" href="#langenjsx-guilanglangsijsx-guilanglangczjsx-guilang" id="langenjsx-guilanglangsijsx-guilanglangczjsx-guilang">{lang=EN}JSX Gui{/lang}{lang=SI}JSX Gui{/lang}{lang=CZ}JSX Gui{/lang}</a></h1>
<h1><a class="header" href="#contributors" id="contributors">Contributors</a></h1>
<ul>
<li>Igor Pesek </li>
<li>Blaž Zmazek</li>
<li>Roman Hašek</li>
<li>Alfred Wassermann</li>
<li>Bernat Martinez</li>
<li>other members of <a href="https://itemspro.eu/">ITEMS</a> project</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="files/jsxbook.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
        
        

    </body>
</html>
